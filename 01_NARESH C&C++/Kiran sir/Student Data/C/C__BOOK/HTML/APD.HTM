<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>

<HEAD>
<!-- This document was created from RTF source by rtftohtml version 3.0.1 -->

	<META NAME="GENERATOR" Content="Symantec Visual Page 1.0">
	<META HTTP-EQUIV="Content-Type" CONTENT="text/html;CHARSET=iso-8859-1">
	<TITLE>Teach Yourself C++ in 21 Days</TITLE>
</HEAD>

<BODY TEXT="#000000" BGCOLOR="#FFFFFF">

<H1></H1>
<H2 ALIGN="CENTER"><A HREF="apc.htm"><IMG SRC="../buttons/BLANPREV.GIF"
WIDTH="37" HEIGHT="37" ALIGN="BOTTOM" BORDER="0"></A><A HREF="http://www.mcp.com/sams"><IMG
SRC="../buttons/BLANHOME.GIF" WIDTH="37" HEIGHT="37" ALIGN="BOTTOM"
BORDER="0"></A><A HREF="../index.htm"><IMG SRC="../buttons/BLANTOC.GIF"
WIDTH="37" HEIGHT="37" ALIGN="BOTTOM" BORDER="0"></A><BR>
<BR>
<BR>
<A NAME="Heading1"></A><FONT COLOR="#000077">Appendix D<BR>
<BR>
Answers</FONT></H2>

<H2 ALIGN="CENTER"><FONT COLOR="#000077"></FONT></H2>
<H3><A NAME="Heading3"></A><FONT COLOR="#000077">Day 1</FONT></H3>
<H4 ALIGN="CENTER"><A NAME="Heading4"></A><FONT COLOR="#000077">Quiz</FONT></H4>

<DL>
	<DD><B>1. What is the difference between interpreters and compilers?<BR>
	</B><BR>
	Interpreters read through source code and translate a program, turning the programmer's
	code, or program instructions, directly into actions. Compilers translate source
	code into an executable program that can be run at a later time.<BR>
	<B><BR>
	2. How do you compile the source code with your compiler?</B><BR>
	<BR>
	Every compiler is different. Be sure to check the documentation that came with your
	compiler.<BR>
	<B><BR>
	3. What does the linker do?</B><BR>
	<BR>
	The linker's job is to tie together your compiled code with the libraries supplied
	by your compiler vendor and other sources. The linker lets you build your program
	in pieces and then link together the pieces into one big program.<BR>
	<B><BR>
	4. What are the steps in the development cycle?</B><BR>
	<BR>
	Edit source code, compile, link, test, repeat.
</DL>

<H4 ALIGN="CENTER"><A NAME="Heading5"></A><FONT COLOR="#000077">Exercises</FONT></H4>

<DL>
	<DD><B>1.</B> Initializes two integer variables and then prints out their sum and
	their product.<BR>
	<B><BR>
	2.</B> See your compiler manual.<BR>
	<B><BR>
	3.</B> You must put a <TT>#</TT> symbol before the word <TT>include</TT> on the first
	line.<BR>
	<B><BR>
	4. </B>This program prints the words <TT>Hello World</TT> to the screen, followed
	by a new line (carriage return).
</DL>

<H3><A NAME="Heading6"></A><FONT COLOR="#000077">Day 2</FONT></H3>
<H4 ALIGN="CENTER"><A NAME="Heading7"></A><FONT COLOR="#000077"><B>Quiz</B></FONT></H4>

<DL>
	<DD><B>1. What is the difference between the compiler and the preprocessor?</B><BR>
	<BR>
	Each time you run your compiler, the preprocessor runs first. It reads through your
	source code and includes the files you've asked for, and performs other housekeeping
	chores. The preprocessor is discussed in detail on Day 18, &quot;Object-Oriented
	Analysis and Design.&quot;<BR>
	<BR>
	<B>2. Why is the function <TT>main()</TT> special?</B><BR>
	<TT><BR>
	main()</TT> is called automatically, each time your program is executed.<BR>
	<BR>
	<B>3. What are the two types of comments, and how do they differ?</B><BR>
	<BR>
	C++-style comments are two slashes (<TT>//</TT>), and they comment out any text until
	the end of the line. C-style comments come in pairs (<TT>/* */</TT>), and everything
	between the matching pairs is commented out. You must be careful to ensure you have
	matched pairs.<BR>
	<BR>
	<B>4. Can comments be nested?</B><BR>
	<BR>
	Yes, C++-style comments can be nested within C-style comments. You can, in fact,
	nest C-style comments within C++-style comments, as long as you remember that the
	C++-style comments end at the end of the line.<BR>
	<B>5. Can comments be longer than one line?<BR>
	</B><BR>
	C-style comments can. If you want to extend C++-style comments to a second line,
	you must put another set of double slashes (<TT>//</TT>).
</DL>

<H4 ALIGN="CENTER"><A NAME="Heading8"></A><FONT COLOR="#000077">Exercises</FONT></H4>

<DL>
	<DD><B>1.</B> Write a program that writes <TT>I love C++</TT> to the screen.
</DL>

<PRE><FONT COLOR="#0066FF">1: #include &lt;iostream.h&gt;
2:
3: int main()
4: {
5:    cout &lt;&lt; &quot;I love C++\n&quot;;
6:    return 0;
7: }
</FONT></PRE>

<DL>
	<DD><B>2.</B> Write the smallest program that can be compiled, linked, and run.
</DL>

<PRE><FONT COLOR="#0066FF">int main(){}
</FONT></PRE>

<DL>
	<DD><B>3</B>. BUG BUSTERS: Enter this program and compile it. Why does it fail? How
	can you fix it?
</DL>

<PRE><FONT COLOR="#0066FF">1: #include &lt;iostream.h&gt;
2: main()
3: {
4:      cout &lt;&lt; Is there a bug here?&quot;;
5: }</FONT></PRE>

<DL>
	<DD>Line 4 is missing an opening quote for the string.<BR>
	<BR>
	<B><BR>
	4.</B> Fix the bug in Exercise 3 and recompile, link, and run it.
</DL>

<PRE><FONT COLOR="#0066FF">1: #include &lt;iostream.h&gt;
2: main()
3: {
4:      cout &lt;&lt; &quot;Is there a bug here?&quot;;
5: }
</FONT></PRE>
<H3><A NAME="Heading9"></A><FONT COLOR="#000077">Day 3</FONT></H3>
<H4 ALIGN="CENTER"><A NAME="Heading10"></A><FONT COLOR="#000077">Quiz</FONT></H4>

<DL>
	<DD><B>1. What is the difference between an integral variable and a floating-point
	variable?<BR>
	</B><BR>
	Integer variables are whole numbers; floating-point variables are &quot;reals&quot;
	and have a &quot;floating&quot; decimal point. Floating-point numbers can be represented
	using a mantissa and an exponent.<BR>
	<BR>
	<B>2. What are the differences between an <TT>unsigned</TT> <TT>short</TT> <TT>int</TT>
	and a <TT>long</TT> <TT>int</TT>?</B><BR>
	<BR>
	The keyword <TT>unsigned</TT> means that the integer will hold only positive numbers.
	On most computers, short integers are 2 bytes and long integers are 4.<BR>
	<BR>
	<B>3. What are the advantages of using a symbolic constant rather than a literal?</B><BR>
	<BR>
	A symbolic constant explains itself; the name of the constant tells what it is for.
	Also, symbolic constants can be redefined at one location in the source code, rather
	than the programmer having to edit the code everywhere the literal is used.<BR>
	<BR>
	<B>4. What are the advantages of using the <TT>const</TT> keyword rather than <TT>#define</TT>?</B><BR>
	<TT><BR>
	const</TT> variables are &quot;typed;&quot; thus the compiler can check for errors
	in how they are used. Also, they survive the preprocessor; thus the name is available
	in the debugger.<BR>
	<BR>
	<B>5. What makes for a good or bad variable name?</B><BR>
	<BR>
	A good variable name tells you what the variable is for; a bad variable name has
	no information. <TT>myAge</TT> and <TT>PeopleOnTheBus</TT> are good variable names,
	but <TT>xjk</TT> and <TT>prndl</TT> are probably less useful.<BR>
	<BR>
	<B>6. Given this <TT>enum</TT>, what is the value of <TT>Blue</TT>?</B>
</DL>

<PRE><FONT COLOR="#0066FF">enum COLOR { WHITE, BLACK = 100, RED, BLUE, GREEN = 300 };
BLUE = 102
</FONT></PRE>

<DL>
	<DD><B>7. Which of the following variable names are good, which are bad, and which
	are invalid?</B>
	<DL>
		<DD><B><BR>
		a. <TT>Age</TT></B><BR>
		Good<BR>
		<BR>
		<B>b. <TT>!ex</TT></B><BR>
		Not legal<BR>
		<BR>
		<B>c. <TT>R79J</TT></B><BR>
		Legal, but a bad choice<BR>
		<BR>
		<B>d. <TT>TotalIncome</TT></B><BR>
		Good<BR>
		<BR>
		<B>e. <TT>__Invalid</TT></B><TT><BR>
		</TT>Legal, but a bad choice
	</DL>
</DL>

<H4 ALIGN="CENTER"><A NAME="Heading11"></A><FONT COLOR="#000077">Exercises</FONT></H4>

<DL>
	<DD><B>1. </B>What would be the correct variable type in which to store the following
	information?
	<DL>
		<DD><B><BR>
		a. </B>Your age.<BR>
		<TT>Unsigned short</TT> integer<BR>
		<BR>
		<B>b. </B>The area of your backyard.<BR>
		<TT>Unsigned long</TT> integer or <TT>unsigned float</TT><BR>
		<BR>
		<B>c. </B>The number of stars in the galaxy.<BR>
		<TT>Unsigned double</TT><BR>
		<BR>
		<B>d. </B>The average rainfall for the month of January.<BR>
		<TT>Unsigned short</TT> integer
	</DL>
	<DD><BR>
	<B>2.</B> Create good variable names for this information.
	<DL>
		<DD><B><BR>
		a</B>. <TT>myAge</TT><BR>
		<BR>
		<B>b</B>. <TT>backYardArea</TT><BR>
		<BR>
		<B>c</B>. <TT>StarsInGalaxy</TT><BR>
		<BR>
		<B>d</B>. <TT>averageRainFall</TT>
	</DL>
	<DD><BR>
	<B>3.</B> Declare a constant for pi as 3.14159.
</DL>



<BLOCKQUOTE>
	<PRE><FONT COLOR="#0066FF">const float PI = 3.14159;</FONT></PRE>

</BLOCKQUOTE>

<PRE><FONT COLOR="#0066FF"></FONT></PRE>

<DL>
	<DD><B>4.</B> Declare a <TT>float</TT> variable and initialize it using your pi constant.
</DL>



<BLOCKQUOTE>
	<PRE><FONT COLOR="#0066FF">float myPi = PI;</FONT></PRE>

</BLOCKQUOTE>

<PRE><FONT COLOR="#0066FF"></FONT></PRE>
<H3><A NAME="Heading12"></A><FONT COLOR="#000077">Day 4</FONT></H3>
<H4 ALIGN="CENTER"><A NAME="Heading13"></A><FONT COLOR="#000077">Quiz</FONT></H4>

<DL>
	<DD><B>1. What is an expression?</B><BR>
	<BR>
	Any statement that returns a value.<BR>
	<BR>
	<B>2. Is <TT>x = 5 + 7</TT> an expression? What is its value?</B><BR>
	<BR>
	Yes. <TT>12</TT><BR>
	<BR>
	<B>3. What is the value of <TT>201 / 4</TT>?</B><BR>
	<TT><BR>
	50</TT><BR>
	<BR>
	<B>4. What is the value of <TT>201 % 4</TT>?</B><BR>
	<TT><BR>
	1</TT><BR>
	<BR>
	<B>5. If <TT>myAge</TT>, <TT>a</TT>, and <TT>b</TT> are all <TT>int</TT> variables,
	what are their values after:</B>
</DL>

<PRE><FONT COLOR="#0066FF">myAge = 39;
a = myAge++;

b = ++myAge;
myAge: 41, a: 39, b: 41
</FONT></PRE>

<DL>
	<DD><B>6. What is the value of <TT>8+2*3</TT>?</B>
</DL>

<PRE><FONT COLOR="#0066FF">14</FONT></PRE>

<DL>
	<DD><FONT COLOR="#0066FF"></FONT>
	<P><B>7. What is the difference between <TT>if(x = 3)</TT> and <TT>if(x == 3)</TT>?</B><BR>
	<BR>
	The first one assigns <TT>3</TT> to <TT>x</TT> and returns true. The second one tests
	whether <TT>x</TT> is equal to <TT>3</TT>; it returns true if the value of <TT>x</TT>
	is equal to 3 and false if it is not.<BR>
	<BR>
	<B>8. Do the following values evaluate to <TT>TRUE</TT> or <TT>FALSE</TT>?</B>
	<DL>
		<DD><B>a. 0</B><TT><BR>
		FALSE</TT><BR>
		<B><BR>
		b. <TT>1</TT></B><BR>
		<TT>TRUE</TT>
	</DL>
	<DD>
	<DL>
		<DD><B>c. <TT>-1</TT></B><BR>
		<TT>TRUE</TT>
	</DL>
	<DD>
	<DL>
		<DD><B>d. <TT>x = 0</TT></B><BR>
		<TT>FALSE</TT>
	</DL>
	<DD>
	<DL>
		<DD><B>e. <TT>x == 0 // assume that x has the value of 0</TT></B><TT><BR>
		TRUE</TT>
	</DL>
</DL>

<H4 ALIGN="CENTER"><A NAME="Heading14"></A><FONT COLOR="#000077">Exercises</FONT></H4>

<DL>
	<DD><B>1.</B> Write a single <TT>if</TT> statement that examines two integer variables
	and changes the larger to the smaller, using only one <TT>else</TT> clause.
</DL>

<PRE><FONT COLOR="#0066FF">if (x &gt; y)
    x = y;
else          // y &gt; x || y == x
    y = x;
</FONT></PRE>

<DL>
	<DD><B>2. </B>Examine the following program. Imagine entering three numbers, and
	write what output you expect.
</DL>

<PRE><FONT COLOR="#0066FF">1:   #include &lt;iostream.h&gt;
2:   int main()
3:   {
4:        int a, b, c;
5:        cout &lt;&lt; &quot;Please enter three numbers\n&quot;;
6:        cout &lt;&lt; &quot;a: &quot;;
7:        cin &gt;&gt; a;
8:        cout &lt;&lt; &quot;\nb: &quot;;
9:        cin &gt;&gt; b;
10:       cout &lt;&lt; &quot;\nc: &quot;;
11:       cin &gt;&gt; c;
12:
13:       if (c = (a-b))
14        {
15:            cout &lt;&lt; &quot;a: &quot; &lt;&lt; a &lt;&lt; &quot; minus b: &quot;;
16:            cout &lt;&lt; b &lt;&lt; &quot; _equals c: &quot; &lt;&lt; c;
17:       }
15:       else
16:            cout &lt;&lt; &quot;a-b does not equal c: &quot;;
17:     return 0;
18:  }
</FONT></PRE>

<DL>
	<DD><B>3.</B> Enter the program from Exercise 2; compile, link, and run it. Enter
	the numbers <TT>20</TT>, <TT>10</TT>, and <TT>50</TT>. Did you get the output you
	expected? Why not?<BR>
	<BR>
	Enter <TT>20</TT>, <TT>10</TT>, <TT>50</TT>.<BR>
	<BR>
	Get back <TT>a</TT>: <TT>20</TT> <TT>b:</TT> <TT>30</TT> <TT>c:</TT> <TT>10</TT>.<BR>
	<BR>
	Line 13 is assigning, not testing for equality.<BR>
	<B><BR>
	4.</B> Examine this program and anticipate the output:
</DL>

<PRE><FONT COLOR="#0066FF">1:     #include &lt;iostream.h&gt;
2:      int main()
3:      {
4:           int a = 2, b = 2, c;
5:           if (c = (a-b))
6:                cout &lt;&lt; &quot;The value of c is: &quot; &lt;&lt; c;
7:     return 0;
</FONT></PRE>
<PRE><FONT COLOR="#0066FF">
8:      }
</FONT></PRE>

<DL>
	<DD><B>5.</B> Enter, compile, link, and run the program from Exercise 4. What was
	the output? Why?<BR>
	<BR>
	Because line 5 is assigning the value of <TT>a-b</TT> to <TT>c</TT>, the value of
	the assignment is <TT>a</TT> (1) minus <TT>b</TT> (1), or <TT>0</TT>. Because <TT>0</TT>
	is evaluated as <TT>FALSE</TT>, the <TT>if</TT> fails and nothing is printed.
</DL>

<H3 ALIGN="CENTER"></H3>
<H3><A NAME="Heading15"></A><FONT COLOR="#000077">Day 5</FONT></H3>
<H4 ALIGN="CENTER"><A NAME="Heading16"></A><FONT COLOR="#000077">Quiz</FONT></H4>

<DL>
	<DD><B>1. What are the differences between the function prototype and the function
	defi-nition?</B><BR>
	<BR>
	The function prototype declares the function; the definition defines it. The prototype
	ends with a semicolon; the definition need not. The declaration can include the keyword
	<TT>inline</TT> and default values for the parameters; the definition cannot. The
	declaration need not include names for the parameters; the definition must.<BR>
	<B><BR>
	2. Do the names of parameters have to agree in the prototype, definition, and call
	to the function?</B><BR>
	<BR>
	No. All parameters are identified by position, not name.<BR>
	<BR>
	<B>3. If a function doesn't return a value, how do you declare the function?</B><BR>
	<BR>
	Declare the function to return <TT>void</TT>.<BR>
	<BR>
	<B>4. If you don't declare a return value, what type of return value is assumed?</B><BR>
	<BR>
	Any function that does not explicitly declare a return type returns <TT>int</TT>.<BR>
	<BR>
	<B>5. What is a local variable?</B><BR>
	<BR>
	A local variable is a variable passed into or declared within a block, typically
	a function. It is visible only within the block.<BR>
	<BR>
	<B>6. What is scope?</B><BR>
	<BR>
	Scope refers to the visibility and lifetime of local and global variables. Scope
	is usually established by a set of braces.<BR>
	<BR>
	<B>7. What is recursion?</B><BR>
	<BR>
	Recursion generally refers to the ability of a function to call itself.<BR>
	<BR>
	<B>8. When should you use global variables?</B><BR>
	<BR>
	Global variables are typically used when many functions need access to the same data.
	Global variables are very rare in C++; once you know how to create static class variables,
	you will almost never create global variables.<BR>
	<BR>
	<B>9. What is function overloading?</B><BR>
	<BR>
	Function overloading is the ability to write more than one function with the same
	name, distinguished by the number or type of the parameters.<BR>
	<BR>
	<B>10. What is polymorphism?</B><BR>
	<BR>
	Polymorphism is the ability to treat many objects of differing but related types
	without regard to their differences. In C++, polymorphism is accomplished by using
	class derivation and virtual functions.
</DL>

<H4 ALIGN="CENTER"><A NAME="Heading17"></A><FONT COLOR="#000077">Exercises</FONT></H4>

<DL>
	<DD><B>1.</B> Write the prototype for a function named <TT>Perimeter</TT>, which
	returns an <TT>unsigned long int</TT> and which takes two parameters, both <TT>unsigned
	short</TT> <TT>int</TT>s.<BR>
	u<TT>nsigned long int</TT> <TT>Perimeter</TT>(<TT>unsigned short int</TT>, <TT>unsigned
	short int</TT>);<BR>
	<BR>
	<B>2.</B> Write the definition of the function <TT>Perimeter</TT> as described in
	Exercise 1. The two parameters represent the length and width of a rectangle and
	have the function return the perimeter (twice the length plus twice the width).
</DL>

<PRE><FONT COLOR="#0066FF"><TT>unsigned long int Perimeter</TT>(<TT>unsigned short int length</TT>, <TT>unsigned short int width</TT>)</FONT>
<FONT COLOR="#0066FF">
{
  return 2*length + 2*width;
}
</FONT></PRE>

<DL>
	<DD><B>3</B>. BUG BUSTERS: What is wrong with the function?
</DL>

<PRE><FONT COLOR="#0066FF">#include &lt;iostream.h&gt;
void myFunc(unsigned short int x);
int main()
{
    unsigned short int x, y;
    y = myFunc(int);
    cout &lt;&lt; &quot;x: &quot; &lt;&lt; x &lt;&lt; &quot; y: &quot; &lt;&lt; y &lt;&lt; &quot;\n&quot;;
return 0;
}

void myFunc(unsigned short int x)
{
    return (4*x);
}</FONT></PRE>

<DL>
	<DD>The function is declared to return <TT>void</TT> and it cannot return a value.<BR>
	<BR>
	<B>4.</B> BUG BUSTERS: What is wrong with the function?
</DL>

<PRE><FONT COLOR="#0066FF">#include &lt;iostream.h&gt;
int myFunc(unsigned short int x);
int main()
{
    unsigned short int x, y;
    y = myFunc(int);
    cout &lt;&lt; &quot;x: &quot; &lt;&lt; x &lt;&lt; &quot; y: &quot; &lt;&lt; y &lt;&lt; &quot;\n&quot;;
return 0;
}

int myFunc(unsigned short int x)
{
    return (4*x);
}
</FONT></PRE>

<DL>
	<DD>This function would be fine, but there is a semicolon at the end of the function
	definition's header.<BR>
	<BR>
	<B>5.</B> Write a function that takes two <TT>unsigned short</TT> <TT>int</TT> arguments
	and returns the result of dividing the first by the second. Do not do the division
	if the second number is <TT>0</TT>, but do return <TT>-1</TT>.<BR>
	<TT>short int Divider</TT>(<TT>unsigned short int valOne</TT>, <TT>unsigned short
	int valTwo</TT>)
</DL>

<PRE><FONT COLOR="#0066FF">{
    if (valTwo == 0)
          return -1;
    else
          return valOne / valTwo;
}
</FONT></PRE>

<DL>
	<DD><B>6.</B> Write a program that asks the user for two numbers and calls the function
	you wrote in Exercise 5. Print the answer, or print an error message if you get <TT>-1</TT>.
</DL>

<PRE><FONT COLOR="#0066FF">#include &lt;iostream.h&gt;
typedef unsigned short int USHORT;
typedef unsigned long int ULONG;
short int Divider(
unsigned short int valone,
unsigned short int valtwo);
int main()
{
    USHORT one, two;
    short int answer;
    cout &lt;&lt; &quot;Enter two numbers.\n Number one: &quot;;
    cin &gt;&gt; one;
    cout &lt;&lt; &quot;Number two: &quot;;
    cin &gt;&gt; two;
    answer = Divider(one, two);
    if (answer &gt; -1)
       cout &lt;&lt; &quot;Answer: &quot; &lt;&lt; answer;
    else
       cout &lt;&lt; &quot;Error, can't divide by zero!&quot;;
return 0;
}
</FONT></PRE>

<DL>
	<DD><B>7. </B>Write a program that asks for a number and a power. Write a recursive
	function that takes the number to the power. Thus, if the number is 2 and the power
	is 4, the function will return <TT>16</TT>.
</DL>

<PRE><FONT COLOR="#0066FF">#include &lt;iostream.h&gt;
typedef unsigned short USHORT;
typedef unsigned long ULONG;
ULONG GetPower(USHORT n, USHORT power);
int main()
{
   USHORT number, power;
   ULONG answer;
   cout &lt;&lt; &quot;Enter a number: &quot;;
   cin &gt;&gt; number;
   cout &lt;&lt; &quot;To what power? &quot;;
   cin &gt;&gt; power;
   answer = GetPower(number,power);
   cout &lt;&lt; number &lt;&lt; &quot; to the &quot; &lt;&lt; power &lt;&lt; &quot;th power is &quot; &lt;&lt;
answer &lt;&lt; endl;
return 0;
}

ULONG GetPower(USHORT n, USHORT power)
{
    if(power == 1)
     return n;
    else
       return (n * GetPower(n,power-1));
}
</FONT></PRE>
<H3 ALIGN="CENTER"><FONT COLOR="#0066FF"></FONT></H3>
<H3><A NAME="Heading18"></A><FONT COLOR="#000077">Day 6</FONT></H3>
<H4 ALIGN="CENTER"><A NAME="Heading19"></A><FONT COLOR="#000077">Quiz</FONT></H4>

<DL>
	<DD><B>1. What is the dot operator, and what is it used for?</B><BR>
	<BR>
	The dot operator is the period (<TT>.</TT>). It is used to access the members of
	the class.<BR>
	<BR>
	<B>2. Which sets aside memory--declaration or definition?</B><BR>
	<BR>
	Definitions of variables set aside memory. Declarations of classes don't set aside
	memory.<BR>
	<BR>
	<B>3. Is the declaration of a class its interface or its implementation?</B><BR>
	<BR>
	The declaration of a class is its interface; it tells clients of the class how to
	interact with the class. The implementation of the class is the set of member functions
	stored--usually in a related CPP file.<BR>
	<BR>
	<B>4. What is the difference between public and private data members?</B><BR>
	<BR>
	Public data members can be accessed by clients of the class. Private data members
	can be accessed only by member functions of the class.<BR>
	<BR>
	<B>5. Can member functions be private?<BR>
	</B><BR>
	Yes. Both member functions and member data can be private.<BR>
	<BR>
	<B>6. Can member data be public?</B><BR>
	<BR>
	Although member data can be public, it is good programming practice to make it private
	and to provide public accessor functions to the data.<BR>
	<BR>
	<B>7. If you declare two <TT>Cat</TT> objects, can they have different values in
	their <TT>itsAge</TT> member data?</B><BR>
	<BR>
	Yes. Each object of a class has its own data members.<BR>
	<BR>
	<B>8. Do class declarations end with a semicolon? Do class method definitions?</B><BR>
	<BR>
	Declarations end with a semicolon after the closing brace; function definitions do
	not.<BR>
	<BR>
	<B>9. What would the header for a <TT>Cat</TT> function, <TT>Meow</TT>, that takes
	no parameters and returns <TT>void</TT> look like?<BR>
	</B><BR>
	The header for a <TT>Cat</TT> function, <TT>Meow()</TT>, that takes no parameters
	and returns <TT>void</TT> looks like this:
</DL>

<PRE><FONT COLOR="#0066FF">void Cat::Meow()
</FONT></PRE>

<DL>
	<DD><B>10. What function is called to initialize a class?<BR>
	</B><BR>
	The constructor is called to initialize a class.
</DL>

<H4 ALIGN="CENTER"><A NAME="Heading20"></A><FONT COLOR="#000077">Exercises</FONT></H4>

<DL>
	<DD><B>1. </B>Write the code that declares a class called <TT>Employee</TT> with
	these data members: <TT>age</TT>, <TT>yearsOfService</TT>, and <TT>Salary</TT>.
</DL>

<PRE><FONT COLOR="#0066FF">class Employee
{
    int Age;
    int YearsOfService;
    int Salary;
};
</FONT></PRE>

<DL>
	<DD><B>2.</B> Rewrite the <TT>Employee</TT> class to make the data members private,
	and provide public accessor methods to get and set each of the data members.
</DL>

<PRE><FONT COLOR="#0066FF">class Employee
{
public:
    int GetAge() const;
    void SetAge(int age);
    int GetYearsOfService()const;
    void SetYearsOfService(int years);
    int GetSalary()const;
    void SetSalary(int salary);

private:
    int Age;
    int YearsOfService;
    int Salary;
};
</FONT></PRE>

<DL>
	<DD><B>3.</B> Write a program with the <TT>Employee</TT> class that makes two <TT>Employee</TT>s;
	sets their <TT>age</TT>, <TT>YearsOfService</TT>, and <TT>Salary</TT>; and prints
	their values.
</DL>

<PRE><FONT COLOR="#0066FF">main()
{
    Employee John;
    Employee Sally;
    John.SetAge(30);
    John.SetYearsOfService(5);
    John.SetSalary(50000);

    Sally.SetAge(32);
    Sally.SetYearsOfService(8);
    Sally.SetSalary(40000);

    cout &lt;&lt; &quot;At AcmeSexist company, John and Sally have the same
job.\n&quot;;
    cout &lt;&lt; &quot;John is &quot; &lt;&lt; John.GetAge() &lt;&lt; &quot; years old and he has
been with&quot;;
    cout &lt;&lt; &quot;the firm for &quot; &lt;&lt; John.GetYearsOfService &lt;&lt; &quot;
years.\n&quot;;
    cout &lt;&lt; &quot;John earns $&quot; &lt;&lt; John.GetSalary &lt;&lt; &quot; dollars per
year.\n\n&quot;;
    cout &lt;&lt; &quot;Sally, on the other hand is &quot; &lt;&lt; Sally.GetAge() &lt;&lt; &quot;
years old and has&quot;;
    cout &lt;&lt; &quot;been with the company &quot; &lt;&lt; Sally.GetYearsOfService;
    cout &lt;&lt; &quot; years. Yet Sally only makes $&quot; &lt;&lt; Sally.GetSalary();
    cout &lt;&lt; &quot; dollars per year!  Something here is unfair.&quot;;
</FONT></PRE>

<DL>
	<DD><B>4.</B> Continuing from Exercise 3, provide a method of <TT>Employee</TT> that
	reports how many thousands of dollars the employee earns, rounded to the nearest
	1,000.
</DL>

<PRE><FONT COLOR="#0066FF">float Employee:GetRoundedThousands()const
{
    return Salary / 1000;
}
</FONT></PRE>

<DL>
	<DD><B>5. </B>Change the <TT>Employee</TT> class so that you can initialize <TT>age</TT>,
	<TT>YearsOfService</TT>, and <TT>Salary</TT> when you create the employee.
</DL>

<PRE><FONT COLOR="#0066FF">class Employee
{
public:

    Employee(int age, int yearsOfService, int salary);
    int GetAge()const;
    void SetAge(int age);
    int GetYearsOfService()const;
    void SetYearsOfService(int years);
    int GetSalary()const;
    void SetSalary(int salary);

private:
    int Age;
    int YearsOfService;
    int Salary;
};
</FONT></PRE>

<DL>
	<DD><B>6.</B> BUG BUSTERS: What is wrong with the following declaration?
</DL>

<PRE><FONT COLOR="#0066FF">class Square
{
public:
    int Side;
}</FONT></PRE>

<DL>
	<DD>Class declarations must end with a semicolon.<BR>
	<BR>
	<B>7</B>. BUG BUSTERS: Why isn't the following class declaration very useful?
</DL>

<PRE><FONT COLOR="#0066FF">class Cat
{
    int GetAge()const;
private:
    int itsAge;
};</FONT></PRE>

<DL>
	<DD>The accessor <TT>GetAge()</TT> is private. Remember: All class members are private
	unless you say otherwise.<BR>
	<BR>
	<B>8</B>. BUG BUSTERS: What three bugs in this code will the compiler find?
</DL>

<PRE><FONT COLOR="#0066FF">class  TV
{
public:
    void SetStation(int Station);
    int GetStation() const;
private:
    int itsStation;
};

main()
{
    TV myTV;
    myTV.itsStation = 9;
    TV.SetStation(10);
    TV myOtherTv(2);
}
</FONT></PRE>

<DL>
	<DD>You can't access <TT>itsStation</TT> directly. It is private.<BR>
	You can't call <TT>SetStation()</TT> on the class. You can call <TT>SetStation()</TT>
	only on objects.<BR>
	You can't initialize <TT>itsStation</TT> because there is no matching constructor.
</DL>

<H3 ALIGN="CENTER"></H3>
<H3><A NAME="Heading21"></A><FONT COLOR="#000077">Day 7</FONT></H3>
<H4 ALIGN="CENTER"><A NAME="Heading22"></A><FONT COLOR="#000077">Quiz</FONT></H4>

<DL>
	<DD><B>1. How do I initialize more than one variable in a <TT>for</TT> loop?</B><BR>
	<BR>
	Separate the initializations with commas, such as
</DL>

<PRE><FONT COLOR="#0066FF">for (x = 0, y = 10; x &lt; 100; x++, y++)
</FONT></PRE>

<DL>
	<DD><B>2. Why is <TT>goto</TT> avoided?<BR>
	</B><TT><BR>
	goto</TT> jumps in any direction to any arbitrary line of code. This makes for source
	code that is difficult to understand and therefore difficult to maintain.<BR>
	<BR>
	<B>3. Is it possible to write a <TT>for</TT> loop with a body that is never executed?</B><BR>
	<BR>
	Yes, if the condition is <TT>FALSE</TT> after the initialization, the body of the
	<TT>for</TT> loop will never execute. Here's an example:
</DL>

<PRE><FONT COLOR="#0066FF">for (int x = 100; x &lt; 100; x++)
</FONT></PRE>

<DL>
	<DD><B>4. Is it possible to nest <TT>while</TT> loops within <TT>for</TT> loops?</B><BR>
	<BR>
	Yes. Any loop can be nested within any other loop.<BR>
	<BR>
	<B>5. Is it possible to create a loop that never ends? Give an example.<BR>
	</B><BR>
	Yes. Following are examples for both a <TT>for</TT> loop and a <TT>while</TT> loop:
</DL>

<PRE><FONT COLOR="#0066FF">for(;;)
{
    // This for loop never ends!
}
while(1)
{
    // This while loop never ends!
</FONT></PRE>
<PRE><FONT COLOR="#0066FF">
}
</FONT></PRE>

<DL>
	<DD><B>6. What happens if you create a loop that never ends?<BR>
	</B><BR>
	Your program hangs, and you usually must reboot the computer.
</DL>

<H4 ALIGN="CENTER"><A NAME="Heading23"></A><FONT COLOR="#000077">Exercises</FONT></H4>

<DL>
	<DD><B>1.</B> What is the value of <TT>x</TT> when the <TT>for</TT> loop completes?
</DL>

<PRE><FONT COLOR="#0066FF">for (int x = 0; x &lt; 100; x++)
100
</FONT></PRE>

<DL>
	<DD><B>2.</B> Write a nested <TT>for</TT> loop that prints a 10x10 pattern of <TT>0</TT>s.
</DL>

<PRE><FONT COLOR="#0066FF">for (int i = 0; i&lt; 10; i++)
{
    for ( int j = 0; j&lt; 10; j++)
       cout &lt;&lt; &quot;0&quot;;
    cout &lt;&lt; &quot;\n&quot;;
}
</FONT></PRE>

<DL>
	<DD><B>3</B>. Write a <TT>for</TT> statement to count from 100 to 200 by 2s.
</DL>

<PRE><FONT COLOR="#0066FF">for (int x = 100; x&lt;=200; x+=2)
</FONT></PRE>

<DL>
	<DD><B>4.</B> Write a <TT>while</TT> loop to count from 100 to 200 by 2s.
</DL>

<PRE><FONT COLOR="#0066FF">int x = 100;
while (x &lt;= 200)
    x+= 2;
</FONT></PRE>

<DL>
	<DD><B>5.</B> Write a <TT>do...while</TT> loop to count from 100 to 200 by 2s.
</DL>

<PRE><FONT COLOR="#0066FF">int x = 100;
do
{
    x+=2;
} while (x &lt;= 200);
</FONT></PRE>

<DL>
	<DD><B>6.</B> BUG BUSTERS: What is wrong with this code?
</DL>

<PRE><FONT COLOR="#0066FF">int counter = 0
while (counter &lt; 10)
{ 
    cout &lt;&lt; &quot;counter: &quot; &lt;&lt; counter;
    counter++;
}
</FONT></PRE>

<DL>
	<DD><TT>counter</TT> is never incremented and the <TT>while</TT> loop will never
	terminate.<BR>
	<BR>
	<B>7.</B> BUG BUSTERS: What is wrong with this code?
</DL>

<PRE><FONT COLOR="#0066FF">for (int counter = 0; counter &lt; 10; counter++);
    cout &lt;&lt; counter &lt;&lt; &quot;\n&quot;;
</FONT></PRE>

<DL>
	<DD>There is a semicolon after the loop, and the loop does nothing. The programmer
	may have intended this, but if <TT>counter</TT> was supposed to print each value,
	it won't.<BR>
	<BR>
	<B>8.</B> BUG BUSTERS: What is wrong with this code?
</DL>

<PRE><FONT COLOR="#0066FF">int counter = 100;
while (counter &lt; 10)
{
    cout &lt;&lt; &quot;counter now: &quot; &lt;&lt; counter;
    counter--;
}
</FONT></PRE>

<DL>
	<DD><TT>counter</TT> is initialized to <TT>100</TT>, but the test condition is that
	if it is less than 10, the test will fail and the body will never be executed. If
	line 1 were changed to <TT>int counter = 5;</TT>, the loop would not terminate until
	it had counted down past the smallest possible <TT>int</TT>. Because <TT>int</TT>
	is <TT>signed</TT> by default, this would not be what was intended.<BR>
	<BR>
	<B>9.</B> BUG BUSTERS: What is wrong with this code?
</DL>

<PRE><FONT COLOR="#0066FF">cout &lt;&lt; &quot;Enter a number between 0 and 5: &quot;;
cin &gt;&gt; theNumber;
switch (theNumber)
{
   case 0:
         doZero();
   case 1:              // fall through
   case 2:              // fall through
   case 3:              // fall through
   case 4:              // fall through
   case 5: 
         doOneToFive();
         break;
   default:
         doDefault();
         break;
}
</FONT></PRE>

<DL>
	<DD><TT>Case 0</TT> probably needs a <TT>break</TT> statement. If it does not, it
	should be documented with a comment.
</DL>

<H3><A NAME="Heading24"></A><FONT COLOR="#000077">Day 8</FONT></H3>
<H4 ALIGN="CENTER"><A NAME="Heading25"></A><FONT COLOR="#000077">Quiz</FONT></H4>

<DL>
	<DD><B>1. What operator is used to determine the address of a variable?<BR>
	</B><BR>
	The address of operator (<TT>&amp;</TT>) is used to determine the address of any
	variable.<BR>
	<B><BR>
	2. What operator is used to find the value stored at an address held in a pointer?<BR>
	</B><BR>
	The dereference operator (<TT>*</TT>) is used to access the value at an address in
	a pointer.<BR>
	<BR>
	<B>3. What is a pointer?<BR>
	</B><BR>
	A pointer is a variable that holds the address of another variable.<BR>
	<BR>
	<B>4. What is the difference between the address stored in a pointer and the value
	at that </B>address?<BR>
	<BR>
	The address stored in the pointer is the address of another variable. The value stored
	at that address is any value stored in any variable. The indirection operator (<TT>*</TT>)
	returns the value stored at the address, which itself is stored in the pointer.<BR>
	<BR>
	<B>5. What is the difference between the indirection operator and the address of
	oper-ator?<BR>
	</B><BR>
	The indirection operator returns the value at the address stored in a pointer. The
	address of operator (<TT>&amp;</TT>) returns the memory address of the variable.<BR>
	<BR>
	<B>6. What is the difference between <TT>const int * ptrOne</TT> and <TT>int * const
	ptrTwo</TT>?<BR>
	</B><BR>
	The <TT>const int * ptrOne</TT> declares that <TT>ptrOne</TT> is a pointer to a constant
	integer. The integer itself cannot be changed using this pointer.<BR>
	The <TT>int * const ptrTwo</TT> declares that <TT>ptrTwo</TT> is a constant pointer
	to an integer. Once it is initialized, this pointer cannot be reassigned.
</DL>

<H4 ALIGN="CENTER"><A NAME="Heading26"></A><FONT COLOR="#000077">Exercises</FONT></H4>

<DL>
	<DD><B>1.</B> What do these declarations do?
	<DL>
		<DD><B><BR>
		a.</B> <TT>int * pOne;</TT><BR>
		<B>b</B>. <TT>int vTwo;</TT><BR>
		<B>c.</B> <TT>int * pThree = &amp;vTwo;</TT><BR>
		<B><BR>
		a.</B> <TT>int * pOne;</TT> declares a pointer to an integer.<BR>
		<B>b.</B> <TT>int vTwo;</TT> declares an integer variable.<BR>
		<B>c.</B> <TT>int * pThree = &amp;vTwo;</TT> declares a pointer to an integer and
		initializes it with the address of another variable.
	</DL>
	<DD><B><BR>
	2.</B> If you have an <TT>unsigned short</TT> variable named <TT>yourAge</TT>, how
	would you declare a pointer to manipulate <TT>yourAge</TT>?
</DL>

<PRE><FONT COLOR="#0066FF">unsigned short *pAge = &amp;yourAge;
</FONT></PRE>

<DL>
	<DD><B>3.</B> Assign the value <TT>50</TT> to the variable <TT>yourAge</TT> by using
	the pointer that you declared in Exercise 2.
</DL>

<PRE><FONT COLOR="#0066FF">*pAge = 50;
</FONT></PRE>

<DL>
	<DD><B>4.</B> Write a small program that declares an integer and a pointer to integer.
	Assign the address of the integer to the pointer. Use the pointer to set a value
	in the integer variable.
</DL>

<PRE><FONT COLOR="#0066FF">int theInteger;
int *pInteger = &amp;theInteger;
*pInteger = 5;
</FONT></PRE>

<DL>
	<DD><B>5.</B> BUG BUSTERS: What is wrong with this code?
</DL>

<PRE><FONT COLOR="#0066FF">#include &lt;iostream.h&gt;
int main()
{
     int *pInt;
     *pInt = 9;
     cout &lt;&lt; &quot;The value at pInt: &quot; &lt;&lt; *pInt;
return 0;
}
</FONT></PRE>

<DL>
	<DD><TT>pInt</TT> should have been initialized. More importantly, because it was
	not initialized and was not assigned the address of any memory, it points to a random
	place in memory. Assigning <TT>9</TT> to that random place is a dangerous bug.<BR>
	<BR>
	<B>6.</B> BUG BUSTERS: What is wrong with this code?
</DL>

<PRE><FONT COLOR="#0066FF">int main()
{
    int SomeVariable = 5;
    cout &lt;&lt; &quot;SomeVariable: &quot; &lt;&lt; SomeVariable &lt;&lt; &quot;\n&quot;;
    int *pVar = &amp; SomeVariable;
    pVar = 9;
    cout &lt;&lt; &quot;SomeVariable: &quot; &lt;&lt; *pVar &lt;&lt; &quot;\n&quot;;
return 0;
}
</FONT></PRE>

<DL>
	<DD>Presumably, the programmer meant to assign <TT>9</TT> to the value at <TT>pVar</TT>.
	Unfortunately, <TT>9</TT> was assigned to be the value of <TT>pVar</TT> because the
	indirection operator (<TT>*</TT>) was left off. This will lead to disaster if <TT>pVar</TT>
	is used to assign a value.
</DL>

<H3 ALIGN="CENTER"></H3>
<H3><A NAME="Heading27"></A><FONT COLOR="#000077">Day 9</FONT></H3>
<H4 ALIGN="CENTER"><A NAME="Heading28"></A><FONT COLOR="#000077">Quiz</FONT></H4>

<DL>
	<DD><B>1. What is the difference between a reference and a pointer?<BR>
	</B><BR>
	A reference is an alias, and a pointer is a variable that holds an address. References
	cannot be null and cannot be assigned to.<BR>
	<BR>
	<B>2. When must you use a pointer rather than a reference?<BR>
	</B><BR>
	When you may need to reassign what is pointed to, or when the pointer may be null.<BR>
	<BR>
	<B>3. What does <TT>new</TT> return if there is insufficient memory to make your
	<TT>new</TT> object?<BR>
	</B><BR>
	A null pointer (<TT>0</TT>).<BR>
	<BR>
	<B>4. What is a constant reference?<BR>
	</B><BR>
	This is a shorthand way of saying &quot;a reference to a constant object.&quot;<BR>
	<BR>
	<B>5. What is the difference between passing by reference and passing a reference?<BR>
	</B><BR>
	Passing by reference means not making a local copy. It can be accomplished by passing
	a reference or by passing a pointer.
</DL>

<H4 ALIGN="CENTER"><A NAME="Heading29"></A><FONT COLOR="#000077">Exercises</FONT></H4>

<DL>
	<DD><B>1</B>. Write a program that declares an <TT>int</TT>, a reference to an <TT>int</TT>,
	and a pointer to an <TT>int</TT>. Use the pointer and the reference to manipulate
	the value in the <TT>int</TT>.
</DL>

<PRE><FONT COLOR="#0066FF">int main()
{
int varOne;
int&amp; rVar = varOne;
int* pVar = &amp;varOne;
rVar = 5;
*pVar = 7;
return 0;
}
</FONT></PRE>

<DL>
	<DD><B>2.</B> Write a program that declares a constant pointer to a constant integer.
	Initialize the pointer to an integer variable, <TT>varOne</TT>. Assign <TT>6</TT>
	to <TT>varOne</TT>. Use the pointer to assign <TT>7</TT> to <TT>varOne</TT>. Create
	a second integer variable, <TT>varTwo</TT>. Reassign the pointer to <TT>varTwo</TT>.
</DL>

<PRE><FONT COLOR="#0066FF">int main()
{
   int varOne;
   const int * const pVar = &amp;varOne;
   *pVar = 7;
   int varTwo;
   pVar = &amp;varTwo;
return 0;
}
</FONT></PRE>

<DL>
	<DD><B>3.</B> Compile the program in Exercise 2. What produces errors? What produces
	warnings?<BR>
	You can't assign a value to a constant object, and you can't reassign a constant
	pointer.<BR>
	<BR>
	<B>4.</B> Write a program that produces a stray pointer.
</DL>

<PRE><FONT COLOR="#0066FF">int main()
{
int * pVar;
*pVar = 9;
return 0;
}
</FONT></PRE>

<DL>
	<DD><B>5.</B> Fix the program from Exercise 4.
</DL>

<PRE><FONT COLOR="#0066FF">int main()
{
int VarOne;
int * pVar = &amp;varOne;
*pVar = 9;
return 0;
}
</FONT></PRE>

<DL>
	<DD><B>6.</B> Write a program that produces a memory leak.
</DL>

<PRE><FONT COLOR="#0066FF">int FuncOne();
int main()
{
   int localVar = FunOne();
   cout &lt;&lt; &quot;the value of localVar is: &quot; &lt;&lt; localVar;
return 0;
}

int FuncOne()
{
   int * pVar = new int (5);
   return *pVar;
}
</FONT></PRE>

<DL>
	<DD><B>7.</B> Fix the program from Exercise 6.
</DL>

<PRE><FONT COLOR="#0066FF">void FuncOne();
int main()
{
   FuncOne();
return 0;
}

void FuncOne()
{
   int * pVar = new int (5);
   cout &lt;&lt; &quot;the value of *pVar is: &quot; &lt;&lt; *pVar ;
}
</FONT></PRE>

<DL>
	<DD><B>8.</B> BUG BUSTERS: What is wrong with this program?
</DL>

<PRE><FONT COLOR="#0066FF">1:     #include &lt;iostream.h&gt;
2:
3:     class CAT
4:     {
5:        public:
6:           CAT(int age) { itsAge = age; }
7:           ~CAT(){}
8:           int GetAge() const { return itsAge;}
9:        private:
10:          int itsAge;
11:    };
12:
13:    CAT &amp; MakeCat(int age);
14:    int main()
15:    {
16:       int age = 7;
17:       CAT Boots = MakeCat(age);
18:       cout &lt;&lt; &quot;Boots is &quot; &lt;&lt; Boots.GetAge() &lt;&lt; &quot; years old\n&quot;;
19:     return 0;
20:    }
21:
22:    CAT &amp; MakeCat(int age)
23:    {
24:       CAT * pCat = new CAT(age);
25:       return *pCat;
26:    }
</FONT></PRE>

<DL>
	<DD><TT>MakeCat</TT> returns a reference to the <TT>CAT</TT> created on the free
	store. There is no way to free that memory, and this produces a memory leak.<BR>
	<BR>
	<B>9.</B> Fix the program from Exercise 8.
</DL>

<PRE><FONT COLOR="#0066FF">1:     #include &lt;iostream.h&gt;
2:
3:     class CAT
4:     {
5:        public:
6:           CAT(int age) { itsAge = age; }
7:           ~CAT(){}
8:           int GetAge() const { return itsAge;}
9:        private:
10:          int itsAge;
11:    };
12:
13:    CAT * MakeCat(int age);
14:    int main()
15:    {
16:       int age = 7;
17:       CAT * Boots = MakeCat(age);
18:       cout &lt;&lt; &quot;Boots is &quot; &lt;&lt; Boots-&gt;GetAge() &lt;&lt; &quot; years old\n&quot;;
19:       delete Boots;
20:     return 0;
21:    }
22:
23:    CAT * MakeCat(int age)
24:    {
25:       return new CAT(age);
26:    }
</FONT></PRE>
<H3 ALIGN="CENTER"><FONT COLOR="#0066FF"></FONT></H3>
<H3><A NAME="Heading30"></A><FONT COLOR="#000077">Day 10</FONT></H3>
<H4 ALIGN="CENTER"><A NAME="Heading31"></A><FONT COLOR="#000077">Quiz</FONT></H4>

<DL>
	<DD><B>1. When you overload member functions, in what ways must they differ?<BR>
	</B><BR>
	Overloaded member functions are functions in a class that share a name but differ
	in the number or type of their parameters.<BR>
	<B>2. What is the difference between a declaration and a definition?<BR>
	</B><BR>
	A definition sets aside memory, but a declaration does not. Almost all declarations
	are definitions; the major exceptions are class declarations, function prototypes,
	and <TT>typedef</TT> statements.<BR>
	<B><BR>
	3. When is the copy constructor called?<BR>
	</B><BR>
	Whenever a temporary copy of an object is created. This happens every time an object
	is passed by value.<BR>
	<BR>
	<B>4. When is the destructor called?<BR>
	</B><BR>
	The destructor is called each time an object is destroyed, either because it goes
	out of scope or because you call <TT>delete</TT> on a pointer pointing to it.<BR>
	<B><BR>
	5. How does the copy constructor differ from the assignment operator (<TT>=</TT>)?<BR>
	</B><BR>
	The assignment operator acts on an existing object; the copy constructor creates
	a new one.<BR>
	<B><BR>
	6. What is the <TT>this</TT> pointer?<BR>
	</B><BR>
	The <TT>this</TT> pointer is a hidden parameter in every member function that points
	to the object itself.<BR>
	<BR>
	<B>7. How do you differentiate between overloading the prefix and postfix increments?<BR>
	</B><BR>
	The prefix operator takes no parameters. The postfix operator takes a single <TT>int</TT>
	parameter, which is used as a signal to the compiler that this is the postfix variant.<BR>
	<BR>
	<B>8. Can you overload the operator<TT>+</TT> for <TT>short</TT> integers?<BR>
	</B><BR>
	No, you cannot overload any operator for built-in types.<BR>
	<BR>
	<B>9. Is it legal in C++ to overload <TT>operator++</TT> so that it decrements a
	value in your class?<BR>
	</B><BR>
	It is legal, but it is a bad idea. Operators should be overloaded in a way that is
	likely to be readily understood by anyone reading your code.<BR>
	<BR>
	<B>10. What return value must conversion operators have in their declaration?<BR>
	</B><BR>
	None. Like constructors and destructors, they have no return values.
</DL>

<H4 ALIGN="CENTER"><A NAME="Heading32"></A><FONT COLOR="#000077">Exercises</FONT></H4>

<DL>
	<DD><B>1.</B> Write a <TT>SimpleCircle</TT> class declaration (only) with one member
	variable: <TT>itsRadius</TT>. Include a default constructor, a destructor, and accessor
	methods for <TT>itsRadius</TT>.
</DL>

<PRE><FONT COLOR="#0066FF">class SimpleCircle
{
public:
     SimpleCircle();
     ~SimpleCircle();
     void SetRadius(int);
     int GetRadius();
private:
     int itsRadius;
};
</FONT></PRE>

<DL>
	<DD><B>2.</B> Using the class you created in Exercise 1, write the implementation
	of the default constructor, initializing <TT>itsRadius</TT> with the value <TT>5</TT>.
</DL>

<PRE><FONT COLOR="#0066FF">SimpleCircle::SimpleCircle():
itsRadius(5)
{}
</FONT></PRE>

<DL>
	<DD><B>3.</B> Using the same class, add a second constructor that takes a value as
	its parameter and assigns that value to <TT>itsRadius</TT>.
</DL>

<PRE><FONT COLOR="#0066FF">SimpleCircle::SimpleCircle(int radius):
itsRadius(radius)
{}
</FONT></PRE>

<DL>
	<DD><B>4. </B>Create a prefix and postfix increment operator for your <TT>SimpleCircle</TT>
	class that increments <TT>itsRadius</TT>.
</DL>

<PRE><FONT COLOR="#0066FF">const SimpleCircle&amp; SimpleCircle::operator++()
{
     ++(itsRadius);
     return *this;
}

// Operator ++(int) postfix. 
// Fetch then increment
const SimpleCircle SimpleCircle::operator++ (int)
{
// declare local SimpleCircle and initialize to value of *this
    SimpleCircle temp(*this);  
    ++(itsRadius);
    return temp;  
}
</FONT></PRE>

<DL>
	<DD><B>5.</B> Change <TT>SimpleCircle</TT> to store <TT>itsRadius</TT> on the free
	store, and fix the existing methods.
</DL>

<PRE><FONT COLOR="#0066FF">class SimpleCircle
{
public:
     SimpleCircle();
     SimpleCircle(int);
     ~SimpleCircle();
     void SetRadius(int);
     int GetRadius();
     const SimpleCircle&amp; operator++();
     const SimpleCircle operator++(int);
private:
     int *itsRadius;
};


SimpleCircle::SimpleCircle()
{itsRadius = new int(5);}

SimpleCircle::SimpleCircle(int radius)
{itsRadius = new int(radius);}

const SimpleCircle&amp; SimpleCircle::operator++()
{
     ++(itsRadius);
     return *this;
}

// Operator ++(int) postfix. 
// Fetch then increment
const SimpleCircle SimpleCircle::operator++ (int)
{
// declare local SimpleCircle and initialize to value of *this
    SimpleCircle temp(*this);  
    ++(itsRadius);
    return temp;  
}
</FONT></PRE>

<DL>
	<DD><B>6. </B>Provide a copy constructor for <TT>SimpleCircle</TT>.
</DL>

<PRE><FONT COLOR="#0066FF">SimpleCircle::SimpleCircle(const SimpleCircle &amp; rhs)
{
     int val = rhs.GetRadius();
     itsRadius = new int(val);
}
</FONT></PRE>

<DL>
	<DD><B>7.</B> Provide an <TT>operator=</TT> for <TT>SimpleCircle</TT>.
</DL>

<PRE><FONT COLOR="#0066FF">SimpleCircle&amp; SimpleCircle::operator=(const SimpleCircle &amp; rhs)
{
     if (this == &amp;rhs)
          return *this;
     delete itsRadius;
    itsRadius = new int;
    *itsRadius = rhs.GetRadius();
    return *this;
}
</FONT></PRE>

<DL>
	<DD><B>8.</B> Write a program that creates two <TT>SimpleCircle</TT> objects. Use
	the default constructor on one and instantiate the other with the value <TT>9</TT>.
	Call <TT>increment</TT> on each and then print their values. Finally, assign the
	second to the first and print its values.
</DL>

<PRE><FONT COLOR="#0066FF">#include &lt;iostream.h&gt;

class SimpleCircle
{
public:
      // constructors
     SimpleCircle();
     SimpleCircle(int);
     SimpleCircle(const SimpleCircle &amp;);
     ~SimpleCircle() {}

// accessor functions
     void SetRadius(int);
     int GetRadius()const;

// operators
     const SimpleCircle&amp; operator++();
     const SimpleCircle operator++(int);
     SimpleCircle&amp; operator=(const SimpleCircle &amp;);

private:
     int *itsRadius;
};


SimpleCircle::SimpleCircle()
{itsRadius = new int(5);}

SimpleCircle::SimpleCircle(int radius)
{itsRadius = new int(radius);}

SimpleCircle::SimpleCircle(const SimpleCircle &amp; rhs)
{
     int val = rhs.GetRadius();
     itsRadius = new int(val);
}
SimpleCircle&amp; SimpleCircle::operator=(const SimpleCircle &amp; rhs)
{
     if (this == &amp;rhs)
          return *this;
     *itsRadius = rhs.GetRadius();
     return *this;
}

const SimpleCircle&amp; SimpleCircle::operator++()
{
     ++(itsRadius);
     return *this;
}

// Operator ++(int) postfix. 
// Fetch then increment
const SimpleCircle SimpleCircle::operator++ (int)
{
// declare local SimpleCircle and initialize to value of *this
    SimpleCircle temp(*this);  
    ++(itsRadius);
    return temp;  
}
int SimpleCircle::GetRadius() const
{
     return *itsRadius;
}
int main()
{
     SimpleCircle CircleOne, CircleTwo(9);
     CircleOne++;
     ++CircleTwo;
     cout &lt;&lt; &quot;CircleOne: &quot; &lt;&lt; CircleOne.GetRadius() &lt;&lt; endl;
     cout &lt;&lt; &quot;CircleTwo: &quot; &lt;&lt; CircleTwo.GetRadius() &lt;&lt; endl;
     CircleOne = CircleTwo;
     cout &lt;&lt; &quot;CircleOne: &quot; &lt;&lt; CircleOne.GetRadius() &lt;&lt; endl;
     cout &lt;&lt; &quot;CircleTwo: &quot; &lt;&lt; CircleTwo.GetRadius() &lt;&lt; endl;
return 0;
}
</FONT></PRE>

<DL>
	<DD><B>9.</B> BUG BUSTERS: What is wrong with this implementation of the assignment
	operator?
</DL>

<PRE><FONT COLOR="#0066FF">SQUARE SQUARE ::operator=(const SQUARE &amp; rhs)
{
      itsSide = new int;
      *itsSide = rhs.GetSide();
      return *this;
}
</FONT></PRE>

<DL>
	<DD>You must check to see whether <TT>rhs</TT> equals <TT>this</TT>, or the call
	to <TT>a = a</TT> will crash your program.<BR>
	<BR>
	<B>10.</B> BUG BUSTERS: What is wrong with this implementation of <TT>operator+</TT>?
</DL>

<PRE><FONT COLOR="#0066FF">VeryShort  VeryShort::operator+ (const VeryShort&amp; rhs)
{
   itsVal += rhs.GetItsVal();
   return *this;
}
</FONT></PRE>

<DL>
	<DD>This <TT>operator+</TT> is changing the value in one of the operands, rather
	than creating a new <TT>VeryShort</TT> object with the sum. The right way to do this
	is as follows:
</DL>

<PRE><FONT COLOR="#0066FF">VeryShort  VeryShort::operator+ (const VeryShort&amp; rhs)
{
   return VeryShort(itsVal + rhs.GetItsVal());
}
</FONT></PRE>
<H3 ALIGN="CENTER"><FONT COLOR="#0066FF"></FONT></H3>
<H3><A NAME="Heading33"></A><FONT COLOR="#000077">Day 11</FONT></H3>
<H4 ALIGN="CENTER"><A NAME="Heading34"></A><FONT COLOR="#000077">Quiz</FONT></H4>

<DL>
	<DD><B>1. What are the first and last elements in <TT>SomeArray[25]</TT>?<BR>
	</B><TT><BR>
	SomeArray[0]</TT>,<TT> SomeArray[24]</TT><BR>
	<BR>
	<B>2. How do you declare a multidimensional array?<BR>
	</B><BR>
	Write a set of subscripts for each dimension. For example, <TT>SomeArray[2][3][2]</TT>
	is a three-dimensional array. The first dimension has two elements, the second has
	three, and <BR>
	the third has two.<BR>
	<BR>
	<B>3. Initialize the members of the array in Question 2.</B>
</DL>

<PRE><FONT COLOR="#0066FF">SomeArray[2][3][2] = { { {1,2},{3,4},{5,6} } , { {7,8},{9,10},{11,12} } };
</FONT></PRE>

<DL>
	<DD><B>4. How many elements are in the array <TT>SomeArray[10][5][20]</TT>?<BR>
	</B><BR>
	10x5x20=1,000<BR>
	<BR>
	<B>5. What is the maximum number of elements that you can add to a linked list?<BR>
	</B><BR>
	There is no fixed maximum. It depends on how much memory you have available.<BR>
	<BR>
	<B>6. Can you use subscript notation on a linked list?<BR>
	</B><BR>
	You can use subscript notation on a linked list only by writing your own class to
	contain the linked list and overloading the subscript operator.<BR>
	<BR>
	<B>7. What is the last character in the string &quot;Brad is a nice guy&quot;?<BR>
	</B><BR>
	The null character.
</DL>

<H4 ALIGN="CENTER"><A NAME="Heading35"></A><FONT COLOR="#000077">Exercises</FONT></H4>

<DL>
	<DD><B>1. </B>Declare a two-dimensional array that represents a tic-tac-toe game
	board.
</DL>

<PRE><FONT COLOR="#0066FF">int GameBoard[3][3];
</FONT></PRE>

<DL>
	<DD><B>2.</B> Write the code that initializes all the elements in the array you created
	in Exercise 1 to the value <TT>0</TT>.
</DL>

<PRE><FONT COLOR="#0066FF">int GameBoard[3][3] = { {0,0,0},{0,0,0},{0,0,0} }
</FONT></PRE>

<DL>
	<DD><B>3.</B> Write the declaration for a <TT>Node</TT> class that holds <TT>unsigned</TT>
	<TT>short</TT> integers.
</DL>

<PRE><FONT COLOR="#0066FF"> class Node
 {
 public:
    Node ();
    Node (int);
    ~Node();
    void SetNext(Node * node) { itsNext = node; }
    Node * GetNext() const { return itsNext; }
    int GetVal() const { return itsVal; }
    void Insert(Node *);
    void Display();
 private:
    int itsVal;
    Node * itsNext;
 };
</FONT></PRE>

<DL>
	<DD><B>4.</B> BUG BUSTERS: What is wrong with this code fragment?
</DL>

<PRE><FONT COLOR="#0066FF">unsigned short SomeArray[5][4];
for (int i = 0; i&lt;4; i++)
     for (int j = 0; j&lt;5; j++)
          SomeArray[i][j] = i+j;
</FONT></PRE>

<DL>
	<DD>The array is 5 elements by 4 elements, but the code initializes 4x5.<BR>
	<B><BR>
	5.</B> BUG BUSTERS: What is wrong with this code fragment?
</DL>

<PRE><FONT COLOR="#0066FF">unsigned short SomeArray[5][4];
for (int i = 0; i&lt;=5; i++)
     for (int j = 0; j&lt;=4; j++)
          SomeArray[i][j] = 0;
</FONT></PRE>

<DL>
	<DD>You wanted to write <TT>i&lt;5</TT>, but you wrote <TT>i&lt;=5</TT> instead.
	The code will run when <TT>i == 5</TT> and <TT>j == 4</TT>, but there is no such
	element as <TT>SomeArray[5][4]</TT>.
</DL>

<H3 ALIGN="CENTER"></H3>
<H3><A NAME="Heading36"></A><FONT COLOR="#000077">Day 12</FONT></H3>
<H4 ALIGN="CENTER"><A NAME="Heading37"></A><FONT COLOR="#000077">Quiz</FONT></H4>

<DL>
	<DD><B>1. What is a v-table?<BR>
	</B><BR>
	A v-table, or virtual function table, is a common way for compilers to manage virtual
	functions in C++. The table keeps a list of the addresses of all the virtual functions
	and, depending on the runtime type of the object pointed to, invokes the right function.<BR>
	<BR>
	<B>2. What is a virtual destructor?<BR>
	</B><BR>
	A destructor of any class can be declared to be virtual. When the pointer is deleted,
	the runtime type of the object will be assessed and the correct derived destructor
	invoked.<BR>
	<BR>
	<B>3. How do you show the declaration of a virtual constructor?<BR>
	</B><BR>
	There are no virtual constructors.<BR>
	<BR>
	<B>4. How can you create a virtual copy constructor?<BR>
	</B><BR>
	By creating a virtual method in your class, which itself calls the copy constructor.<BR>
	<BR>
	<B>5. How do you invoke a base member function from a derived class in which you've
	overridden that function?</B>
</DL>

<PRE><FONT COLOR="#0066FF">Base::FunctionName();
</FONT></PRE>

<DL>
	<DD><B>6. How do you invoke a base member function from a derived class in which
	you have not <BR>
	overridden that function?</B>
</DL>

<PRE><FONT COLOR="#0066FF">FunctionName();
</FONT></PRE>

<DL>
	<DD><B>7. If a base class declares a function to be virtual, and a derived class
	does not use the term <TT>virtual</TT> when overriding that class, is it still virtual
	when inherited by a third-generation class?</B><BR>
	<BR>
	Yes, the virtuality is inherited and cannot be turned off.<BR>
	<BR>
	<B>8. What is the <TT>protected</TT> keyword used for?</B><BR>
	<TT><BR>
	protected</TT> members are accessible to the member functions of derived objects.
</DL>

<H4 ALIGN="CENTER"><A NAME="Heading38"></A><FONT COLOR="#000077">Exercises</FONT></H4>

<DL>
	<DD><B>1. </B>Show the declaration of a virtual function taking an integer parameter
	and returning <TT>void</TT>.
</DL>

<PRE><FONT COLOR="#0066FF">virtual void SomeFunction(int);
</FONT></PRE>

<DL>
	<DD><B>2.</B> Show the declaration of a class <TT>Square</TT>, which derives from
	<TT>Rectangle</TT>, which in turn derives from <TT>Shape</TT>.
</DL>

<PRE><FONT COLOR="#0066FF">class Square : public Rectangle
{};
</FONT></PRE>

<DL>
	<DD><B>3.</B> If, in Exercise 2, <TT>Shape</TT> takes no parameters, <TT>Rectangle</TT>
	takes two (<TT>length</TT> and <TT>width</TT>), and <TT>Square</TT> takes only one
	(<TT>length</TT>), show the constructor initialization for <TT>Square</TT>.
</DL>

<PRE><FONT COLOR="#0066FF">Square::Square(int length):
     Rectangle(length, length){}
</FONT></PRE>

<DL>
	<DD><B>4.</B> Write a virtual copy constructor for the class <TT>Square</TT> (from
	the preceding question).
</DL>

<PRE><FONT COLOR="#0066FF">class Square
      {
         public:
         // ...
         virtual Square * clone() const { return new Square(*this); }
       // ...
     };
</FONT></PRE>

<DL>
	<DD><B>5.</B> BUG BUSTERS: What is wrong with this code snippet?
</DL>

<PRE><FONT COLOR="#0066FF">void SomeFunction (Shape);
Shape * pRect = new Rectangle;
SomeFunction(*pRect);
</FONT></PRE>

<DL>
	<DD>Perhaps nothing. <TT>SomeFunction</TT> expects a <TT>Shape</TT> object. You've
	passed it a <TT>Rectangle</TT> &quot;sliced&quot; down to a <TT>Shape</TT>. As long
	as you don't need any of the <TT>Rectangle</TT> parts, this will be fine. If you
	do need the <TT>Rectangle</TT> parts, you'll need to change <TT>SomeFunction</TT>
	to take a pointer or a reference to a <TT>Shape</TT>.<BR>
	<B><BR>
	6.</B> BUG BUSTERS: What is wrong with this code snippet?
</DL>

<PRE><FONT COLOR="#0066FF">class Shape()
{
public:
     Shape();
     virtual ~Shape();
     virtual Shape(const Shape&amp;);
};
</FONT></PRE>

<DL>
	<DD>You can't declare a copy constructor to be virtual.
</DL>

<H3 ALIGN="CENTER"></H3>
<H3><A NAME="Heading39"></A><FONT COLOR="#000077">Day 13</FONT></H3>
<H4 ALIGN="CENTER"><A NAME="Heading40"></A><FONT COLOR="#000077">Quiz</FONT></H4>

<DL>
	<DD><B>1. What is a down cast?<BR>
	</B><BR>
	A down cast (also called &quot;casting down&quot;) is a declaration that a pointer
	to a base class is to be treated as a pointer to a derived class.<BR>
	<BR>
	<B>2. What is the v-ptr?<BR>
	</B><BR>
	The v-ptr, or virtual-function pointer, is an implementation detail of virtual functions.
	Each object in a class with virtual functions has a v-ptr, which points to the virtual
	function table for that class.<BR>
	<BR>
	<B>3. If a round rectangle has straight edges and rounded corners, your <TT>RoundRect</TT>
	class inherits both from <TT>Rectangle</TT> and from <TT>Circle</TT>, and they in
	turn both inherit from <TT>Shape</TT>, how many <TT>Shape</TT>s are created when
	you create a <TT>RoundRect</TT>?</B><BR>
	<BR>
	If neither class inherits using the keyword <TT>virtual</TT>, two <TT>Shapes</TT>
	are created: one for <TT>Rectangle</TT> and one for <TT>Shape</TT>. If the keyword
	<TT>virtual</TT> is used for both classes, only one shared <TT>Shape</TT> is created.<BR>
	<BR>
	<B>4. If <TT>Horse</TT> and <TT>Bird</TT> inherit <TT>virtual</TT> <TT>public</TT>
	from <TT>Animal</TT>, do their constructors initialize the <TT>Animal</TT> constructor?
	If <TT>Pegasus</TT> inherits from both <TT>Horse</TT> and <TT>Bird</TT>, how does
	it initialize <TT>Animal</TT>'s constructor?</B><BR>
	<BR>
	Both <TT>Horse</TT> and <TT>Bird</TT> initialize their base class, <TT>Animal</TT>,
	in their constructors. <TT>Pegasus</TT> does as well, and when a <TT>Pegasus</TT>
	is created, the <TT>Horse</TT> and <TT>Bird</TT> initializations of <TT>Animal</TT>
	are ignored.<BR>
	<B><BR>
	5. Declare a class <TT>Vehicle</TT> and make it an abstract data type.</B>
</DL>

<PRE><FONT COLOR="#0066FF">class Vehicle
{
     virtual void Move() = 0;
}
</FONT></PRE>

<DL>
	<DD><B>6. If a base class is an ADT, and it has three pure virtual functions, how
	many of these functions must be overridden in its derived classes?</B><BR>
	<BR>
	None must be overridden unless you want to make the class non-abstract, in which
	case all three must be overridden.
</DL>

<H4 ALIGN="CENTER"><A NAME="Heading41"></A><FONT COLOR="#000077">Exercises</FONT></H4>

<DL>
	<DD><B>1.</B> Show the declaration for a class <TT>JetPlane</TT>, which inherits
	from <TT>Rocket</TT> and <TT>Airplane</TT>.
</DL>

<PRE><FONT COLOR="#0066FF">class JetPlane : public Rocket, public Airplane
</FONT></PRE>

<DL>
	<DD><B>2. </B>Show the declaration for <TT>747</TT>, which inherits from the <TT>JetPlane</TT>
	class described in Exercise 1.
</DL>

<PRE><FONT COLOR="#0066FF">class 747 : public JetPlane
</FONT></PRE>

<DL>
	<DD><B>3.</B> Show the declarations for the classes <TT>Car</TT> and <TT>Bus</TT>,
	which each derive from the class <TT>Vehicle</TT>. Make <TT>Vehicle</TT> an ADT with
	two pure virtual functions. Make <TT>Car</TT> and <TT>Bus</TT> not be ADTs.
</DL>

<PRE><FONT COLOR="#0066FF">class Vehicle
{
     virtual void Move() = 0;
     virtual void Haul() = 0;
};

class Car : public Vehicle
{
     virtual void Move();
     virtual void Haul();
};

class Bus : public Vehicle
{
     virtual void Move();
     virtual void Haul();
};
</FONT></PRE>

<DL>
	<DD><B>4. </B>Modify the program in Exercise 1 so that <TT>Car</TT> is an ADT, and
	derive <TT>SportsCar</TT> and <TT>Coupe</TT> from <TT>Car</TT>. In the <TT>Car</TT>
	class, provide an implementation for one of the pure virtual functions in <TT>Vehicle</TT>
	and make it non-pure.
</DL>

<PRE><FONT COLOR="#0066FF">class Vehicle
{
     virtual void Move() = 0;
     virtual void Haul() = 0;
};

class Car : public Vehicle
{
     virtual void Move();
};

class Bus : public Vehicle
{
     virtual void Move();
     virtual void Haul();
};

class SportsCar : public Car
{
     virtual void Haul();
};

class Coupe : public Car
{
     virtual void Haul();
};
</FONT></PRE>
<H3 ALIGN="CENTER"><FONT COLOR="#0066FF"></FONT></H3>
<H3><A NAME="Heading42"></A><FONT COLOR="#000077">Day 14</FONT></H3>
<H4 ALIGN="CENTER"><A NAME="Heading43"></A><FONT COLOR="#000077">Quiz</FONT></H4>

<DL>
	<DD><B>1. Can static member variables be private?</B><BR>
	<BR>
	Yes. They are member variables, and their access can be controlled like any other.
	If they are private, they can be accessed only by using member functions or, more
	commonly, static member functions.<BR>
	<B><BR>
	2. Show the declaration for a static member variable.</B>
</DL>

<PRE><FONT COLOR="#0066FF">static int itsStatic;
</FONT></PRE>

<DL>
	<DD><B>3. Show the declaration for a static function pointer.</B>
</DL>

<PRE><FONT COLOR="#0066FF">static int SomeFunction();
</FONT></PRE>

<DL>
	<DD><B>4. Show the declaration for a pointer <TT>to</TT> function returning <TT>long</TT>
	and taking an integer parameter.</B>
</DL>

<PRE><FONT COLOR="#0066FF">long (* function)(int);
</FONT></PRE>

<DL>
	<DD><B>5. Modify the pointer in Exercise 4 to be a pointer to member function of
	class <TT>Car</TT></B>
</DL>

<PRE><FONT COLOR="#0066FF">long ( Car::*function)(int);
</FONT></PRE>

<DL>
	<DD><B>6. Show the declaration for an array of 10 pointers as defined in Exercise
	5.</B>
</DL>

<PRE><FONT COLOR="#0066FF">(long ( Car::*function)(int) theArray [10];
</FONT></PRE>
<H4 ALIGN="CENTER"><A NAME="Heading44"></A><FONT COLOR="#000077">Exercises</FONT></H4>

<DL>
	<DD><B>1.</B> Write a short program declaring a class with one member variable and
	one static member variable. Have the constructor initialize the member variable and
	increment the static member variable. Have the destructor decrement the member variable.
</DL>

<PRE><FONT COLOR="#0066FF">1:     class myClass
2:     {
3:     public:
4:        myClass();
5:        ~myClass();
6:     private:
7:        int itsMember;
8:        static int itsStatic;
9:     };
10:
11:    myClass::myClass():
12:     itsMember(1)
13:    {
14:       itsStatic++;
15:    }
16:
17:    myClass::~myClass()
18:    {
19:       itsStatic--;
20:    }
21:
22:    int myClass::itsStatic = 0;
23:
24:    int main()
25:    {}
</FONT></PRE>

<DL>
	<DD><B>2. </B>Using the program from Exercise 1, write a short driver program that
	makes three objects and then displays their member variables and the static member
	variable. Then destroy each object and show the effect on the static member variable.
</DL>

<PRE><FONT COLOR="#0066FF">1:     #include &lt;iostream.h&gt;
2:
3:     class myClass
4:     {
5:     public:
6:        myClass();
7:        ~myClass();
8:        void ShowMember();
9:        void ShowStatic();
10:    private:
11:       int itsMember;
12:       static int itsStatic;
13:    };
14:
15:    myClass::myClass():
16:     itsMember(1)
17:    {
18:       itsStatic++;
19:    }
20:
21:    myClass::~myClass()
22:    {
23:       itsStatic--;
24:       cout &lt;&lt; &quot;In destructor. ItsStatic: &quot; &lt;&lt; itsStatic &lt;&lt; endl;
25:    }
26:
27:    void myClass::ShowMember()
28:    {
29:       cout &lt;&lt; &quot;itsMember: &quot; &lt;&lt; itsMember &lt;&lt; endl;
30:    }
31:
32:    void myClass::ShowStatic()
33:    {
34:       cout &lt;&lt; &quot;itsStatic: &quot; &lt;&lt; itsStatic &lt;&lt; endl;
35:    }
36:    int myClass::itsStatic = 0;
37:
38:    int main()
39:    {
40:       myClass obj1;
41:       obj1.ShowMember();
42:       obj1.ShowStatic();
43:
44:       myClass obj2;
45:       obj2.ShowMember();
46:       obj2.ShowStatic();
47:
48:       myClass obj3;
49:       obj3.ShowMember();
50:       obj3.ShowStatic();
51:     return 0;
52:    }
</FONT></PRE>

<DL>
	<DD><B>3. </B>Modify the program from Exercise 2 to use a static member function
	to access the static member variable. Make the static member variable private.
</DL>

<PRE><FONT COLOR="#0066FF">1:     #include &lt;iostream.h&gt;
2:
3:     class myClass
4:     {
5:     public:
6:        myClass();
7:        ~myClass();
8:        void ShowMember();
9:        static int GetStatic();
10:    private:
11:       int itsMember;
12:       static int itsStatic;
13:    };
14:
15:    myClass::myClass():
16:     itsMember(1)
17:    {
18:       itsStatic++;
19:    }
20:
21:    myClass::~myClass()
22:    {
23:       itsStatic--;
24:       cout &lt;&lt; &quot;In destructor. ItsStatic: &quot; &lt;&lt; itsStatic &lt;&lt; endl;
25:    }
26:
27:    void myClass::ShowMember()
28:    {
29:       cout &lt;&lt; &quot;itsMember: &quot; &lt;&lt; itsMember &lt;&lt; endl;
30:    }
31:
32:    int myClass::itsStatic = 0;
33:
34:    void myClass::GetStatic()
35:    {
36:       return itsStatic;
37:    }
38:
39:    int main()
40:    {
41:       myClass obj1;
42:       obj1.ShowMember();
43:       cout &lt;&lt; &quot;Static: &quot; &lt;&lt; myClass::GetStatic() &lt;&lt; endl;
44:
45:       myClass obj2;
46:       obj2.ShowMember();
47:       cout &lt;&lt; &quot;Static: &quot; &lt;&lt; myClass::GetStatic() &lt;&lt; endl;
48:
49:       myClass obj3;
50:       obj3.ShowMember();
51:       cout &lt;&lt; &quot;Static: &quot; &lt;&lt; myClass::GetStatic() &lt;&lt; endl;
52:     return 0;
53:    }
</FONT></PRE>

<DL>
	<DD><B>4.</B> Write a pointer to a member function to access the non-static member
	data in the program in Exercise 3, and use that pointer to print the value of that
	data.
</DL>

<PRE><FONT COLOR="#0066FF">1:     #include &lt;iostream.h&gt;
2:
3:     class myClass
4:     {
5:     public:
6:        myClass();
7:        ~myClass();
8:        void ShowMember();
9:        static int GetStatic();
10:    private:
11:       int itsMember;
12:       static int itsStatic;
13:    };
14:
15:    myClass::myClass():
16:     itsMember(1)
17:    {
18:       itsStatic++;
19:    }
20:
21:    myClass::~myClass()
22:    {
23:       itsStatic--;
24:       cout &lt;&lt; &quot;In destructor. ItsStatic: &quot; &lt;&lt; itsStatic &lt;&lt; endl;
25:    }
26:
27:    void myClass::ShowMember()
28:    {
29:       cout &lt;&lt; &quot;itsMember: &quot; &lt;&lt; itsMember &lt;&lt; endl;
30:    }
31:
32:    int myClass::itsStatic = 0;
33:
34:    int myClass::GetStatic()
35:    {
36:       return itsStatic;
37:    }
38:
39:    int main()
40:    {
41:       void (myClass::*PMF) ();
42:
43:       PMF=myClass::ShowMember;
44:
45:       myClass obj1;
46:       (obj1.*PMF)();
47:       cout &lt;&lt; &quot;Static: &quot; &lt;&lt; myClass::GetStatic() &lt;&lt; endl;
48:
49:       myClass obj2;
50:       (obj2.*PMF)();
51:       cout &lt;&lt; &quot;Static: &quot; &lt;&lt; myClass::GetStatic() &lt;&lt; endl;
52:
53:       myClass obj3;
54:       (obj3.*PMF)();
55:       cout &lt;&lt; &quot;Static: &quot; &lt;&lt; myClass::GetStatic() &lt;&lt; endl;
56:     return 0;
57:    }
</FONT></PRE>

<DL>
	<DD><B>5.</B> Add two more member variables to the class from the previous questions.
	Add accessor functions that get the value of this data and give all the member functions
	the same return values and signatures. Use the pointer to the member function to
	access these functions.
</DL>

<PRE><FONT COLOR="#0066FF">1:     #include &lt;iostream.h&gt;
2:
3:     class myClass
4:     {
5:     public:
6:        myClass();
7:        ~myClass();
8:        void ShowMember();
9:        void ShowSecond();
10:       void ShowThird();
11:       static int GetStatic();
12:    private:
13:       int itsMember;
14:       int itsSecond;
15:       int itsThird;
16:       static int itsStatic;
17:    };
18:
19:    myClass::myClass():
20:     itsMember(1),
21:     itsSecond(2),
22:     itsThird(3)
23:    {
24:       itsStatic++;
25:    }
26:
27:    myClass::~myClass()
28:    {
29:       itsStatic--;
30:       cout &lt;&lt; &quot;In destructor. ItsStatic: &quot; &lt;&lt; itsStatic &lt;&lt; endl;
31:    }
32:
33:    void myClass::ShowMember()
34:    {
35:       cout &lt;&lt; &quot;itsMember: &quot; &lt;&lt; itsMember &lt;&lt; endl;
36:    }
37:
38:    void myClass::ShowSecond()
39:    {
40:       cout &lt;&lt; &quot;itsSecond: &quot; &lt;&lt; itsSecond &lt;&lt; endl;
41:    }
42:
43:    void myClass::ShowThird()
44:    {
45:       cout &lt;&lt; &quot;itsThird: &quot; &lt;&lt; itsThird &lt;&lt; endl;
46:    }
47:    int myClass::itsStatic = 0;
48:
49:    int myClass::GetStatic()
50:    {
51:       return itsStatic;
52:    }
53:
54:    int main()
55:    {
56:       void (myClass::*PMF) ();
57:
58:       myClass obj1;
59:       PMF=myClass::ShowMember;
60:       (obj1.*PMF)();
61:       PMF=myClass::ShowSecond;
62:       (obj1.*PMF)();
63:       PMF=myClass::ShowThird;
64:       (obj1.*PMF)();
65:       cout &lt;&lt; &quot;Static: &quot; &lt;&lt; myClass::GetStatic() &lt;&lt; endl;
66:
67:       myClass obj2;
68:       PMF=myClass::ShowMember;
69:       (obj2.*PMF)();
70:       PMF=myClass::ShowSecond;
71:       (obj2.*PMF)();
72:       PMF=myClass::ShowThird;
73:       (obj2.*PMF)();
74:       cout &lt;&lt; &quot;Static: &quot; &lt;&lt; myClass::GetStatic() &lt;&lt; endl;
75:
76:       myClass obj3;
77:       PMF=myClass::ShowMember;
78:       (obj3.*PMF)();
79:       PMF=myClass::ShowSecond;
80:       (obj3.*PMF)();
81:       PMF=myClass::ShowThird;
82:       (obj3.*PMF)();
83:       cout &lt;&lt; &quot;Static: &quot; &lt;&lt; myClass::GetStatic() &lt;&lt; endl;
84:     return 0;
85:    }
</FONT></PRE>
<H3 ALIGN="CENTER"><FONT COLOR="#0066FF"></FONT></H3>
<H3><A NAME="Heading45"></A><FONT COLOR="#000077">Day 15</FONT></H3>
<H4 ALIGN="CENTER"><A NAME="Heading46"></A><FONT COLOR="#000077">Quiz</FONT></H4>

<DL>
	<DD><B>1. How do you establish an is-a relationship?</B><BR>
	<BR>
	With public inheritance.<BR>
	<BR>
	<B>2. How do you establish a has-a relationship?</B><BR>
	<BR>
	With containment; that is, one class has a member that is an object of another type.<BR>
	<BR>
	<B>3. What is the difference between containment and delegation?<BR>
	</B><BR>
	Containment describes the idea of one class having a data member that is an object
	of another type. Delegation expresses the idea that one class uses another class
	to accomplish a task or goal. Delegation is usually accomplished by containment.<BR>
	<BR>
	<B>4. What is the difference between delegation and implemented-in-terms-of?<BR>
	</B><BR>
	Delegation expresses the idea that one class uses another class to accomplish a task
	or goal. Implemented-in-terms-of expresses the idea of inheriting implementation
	from another class.<BR>
	<B><BR>
	5. What is a friend function?<BR>
	</B><BR>
	A friend function is a function declared to have access to the protected and private
	members of your <BR>
	class.<BR>
	<BR>
	<B>6. What is a friend class?<BR>
	</B><BR>
	A friend class is a class declared so that all its member functions are friend functions
	of your class.<BR>
	<BR>
	<B>7. If <TT>Dog</TT> is a friend of <TT>Boy</TT>, is <TT>Boy</TT> a friend of <TT>Dog</TT>?<BR>
	</B><BR>
	No, friendship is not commutative.<BR>
	<BR>
	<B>8. If <TT>Dog</TT> is a friend of <TT>Boy</TT>, and <TT>Terrier</TT> derives from
	<TT>Dog</TT>, is <TT>Terrier</TT> a friend of <TT>Boy</TT>?<BR>
	</B><BR>
	No, friendship is not inherited.<BR>
	<BR>
	<B>9. If <TT>Dog</TT> is a friend of <TT>Boy</TT> and <TT>Boy</TT> is a friend of
	<TT>House</TT>, is <TT>Dog</TT> a friend of <TT>House</TT>?<BR>
	</B><BR>
	No, friendship is not associative.<BR>
	<BR>
	<B>10. Where must the declaration of a friend function appear?<BR>
	</B><BR>
	Anywhere within the class declaration. It makes no difference whether you put the
	declaration within the <TT>public:</TT>, <TT>protected:</TT>, or <TT>private:</TT>
	access areas.
</DL>

<H4 ALIGN="CENTER"><A NAME="Heading47"></A><FONT COLOR="#000077">Exercises</FONT></H4>

<DL>
	<DD><B>1.</B> Show the declaration of a class <TT>Animal</TT> that contains a data
	member that is a <TT>String</TT> object.
</DL>

<PRE><FONT COLOR="#0066FF">class Animal:
{
private:
   String itsName;
};
</FONT></PRE>

<DL>
	<DD><B>2.</B> Show the declaration of a class <TT>BoundedArray</TT> that is an array.
</DL>

<PRE><FONT COLOR="#0066FF">class boundedArray : public Array
{
//...
}
</FONT></PRE>

<DL>
	<DD><B>3.</B> Show the declaration of a class <TT>Set</TT> that is declared in terms
	of an array.
</DL>

<PRE><FONT COLOR="#0066FF">class Set : private Array
{
// ...
}
</FONT></PRE>

<DL>
	<DD><B>4.</B> Modify Listing 15.1 to provide the <TT>String</TT> class with an extraction
	operator (<TT>&gt;&gt;</TT>).
</DL>

<PRE><FONT COLOR="#0066FF">1:        #include &lt;iostream.h&gt;
2:        #include &lt;string.h&gt;
3:
4:        class String
5:        {
6:           public:
7:              // constructors
8:              String();
9:               String(const char *const);
10:              String(const String &amp;);
11:             ~String();
12:
13:             // overloaded operators
14:             char &amp; operator[](int offset);
15:             char operator[](int offset) const;
16:             String operator+(const String&amp;);
17:             void operator+=(const String&amp;);
18:             String &amp; operator= (const String &amp;);
19:             friend ostream&amp; operator&lt;&lt;
20:                 ( ostream&amp;   _theStream,String&amp; theString);
21:             friend istream&amp; operator&gt;&gt;
22:                ( istream&amp; _theStream,String&amp; theString);
23:             // General accessors
24:             int GetLen()const { return itsLen; }
25:             const char * GetString() const { return itsString; }
26:             // static int ConstructorCount;
27:
28:          private:
29:             String (int);         // private constructor
30:             char * itsString;
31:             unsigned short itsLen;
32:
33       };
34:
35:       ostream&amp; operator&lt;&lt;( ostream&amp; theStream,String&amp; theString)
36:       {
37:           theStream &lt;&lt; theString.GetString();
38:           return theStream;
39:       }
40:
41:       istream&amp; operator&gt;&gt;( istream&amp; theStream,String&amp; theString)
42:       {
43:           theStream &gt;&gt; theString.GetString();
44:           return theStream;
45:       }
46:
47:       int main()
48:       {
49:          String theString(&quot;Hello world.&quot;);
50:          cout &lt;&lt; theString;
51:     return 0;
52:       }
</FONT></PRE>

<DL>
	<DD><B>5.</B> BUG BUSTERS: What is wrong with this program?
</DL>

<PRE><FONT COLOR="#0066FF">1:     #include &lt;iostream.h&gt;
2:
3:     class Animal;
4:
5:     void setValue(Animal&amp; , int);
6:
7:
8:     class Animal
9:     {
10:    public:
11:       int GetWeight()const { return itsWeight; }
12:       int GetAge() const { return itsAge; }
13:    private:
14:       int itsWeight;
15:       int itsAge;
16:    };
17:
18:    void setValue(Animal&amp; theAnimal, int theWeight)
19:    {
20:       friend class Animal;
21:       theAnimal.itsWeight = theWeight;
22:    }
23:
24:    int main()
25:    {
26:       Animal peppy;
27:       setValue(peppy,5);
28:     return 0;
29:    }
</FONT></PRE>

<DL>
	<DD>You can't put the <TT>friend</TT> declaration into the function. You must declare
	the function to be a friend in the class.<BR>
	<BR>
	<B>6.</B> Fix the listing in Exercise 5 so that it will compile.
</DL>

<PRE><FONT COLOR="#0066FF">1:     #include &lt;iostream.h&gt;
2:
3:     class Animal;
4:
5:     void setValue(Animal&amp; , int);
6:
7:
8:     class Animal
9:     {
10:    public:
11:       friend void setValue(Animal&amp;, int);
12:       int GetWeight()const { return itsWeight; }
13:       int GetAge() const { return itsAge; }
14:    private:
15:       int itsWeight;
16:       int itsAge;
17:    };
18:
19:    void setValue(Animal&amp; theAnimal, int theWeight)
20:    {
21:       theAnimal.itsWeight = theWeight;
22:    }
23:
24:    int main()
25:    {
26:       Animal peppy;
27:       setValue(peppy,5);
28:     return 0;
29:    }
</FONT></PRE>

<DL>
	<DD><B>7. </B>BUG BUSTERS: What is wrong with this code?
</DL>

<PRE><FONT COLOR="#0066FF">1:     #include &lt;iostream.h&gt;
2:
3:     class Animal;
4:
5:     void setValue(Animal&amp; , int);
6:     void setValue(Animal&amp; ,int,int);
7:
8:     class Animal
9:     {
10:    friend void setValue(Animal&amp; ,int); // here's the change!
11:    private:
12:       int itsWeight;
13:       int itsAge;
14:    };
15:
16:    void setValue(Animal&amp; theAnimal, int theWeight)
17:    {
18:        theAnimal.itsWeight = theWeight;
19:    }
20:
21:
22:    void setValue(Animal&amp; theAnimal, int theWeight, int theAge)
23:    {
24:       theAnimal.itsWeight = theWeight;
25:       theAnimal.itsAge = theAge;
26:    }
27:
28:    int main()
29:    {
30:       Animal peppy;
31:       setValue(peppy,5);
32:       setValue(peppy,7,9);
33:     return 0;
34:    }
</FONT></PRE>

<DL>
	<DD>The function <TT>setValue(Animal&amp;,int)</TT> was declared to be a friend,
	but the overloaded function <TT>setValue(Animal&amp;,int,int)</TT> was not declared
	to be a friend.<BR>
	<BR>
	<B>8.</B> Fix Exercise 7 so it compiles.
</DL>

<PRE><FONT COLOR="#0066FF">1:     #include &lt;iostream.h&gt;
2:
3:     class Animal;
4:
5:     void setValue(Animal&amp; , int);
6:     void setValue(Animal&amp; ,int,int); // here's the change!
7:
8:     class Animal
9:     {
10:    friend void setValue(Animal&amp; ,int);
11:    friend void setValue(Animal&amp; ,int,int);
12:    private:
13:       int itsWeight;
14:       int itsAge;
15:    };
16:
17:    void setValue(Animal&amp; theAnimal, int theWeight)
18:    {
19:        theAnimal.itsWeight = theWeight;
20:    }
21:
22:
23:    void setValue(Animal&amp; theAnimal, int theWeight, int theAge)
24:    {
25:       theAnimal.itsWeight = theWeight;
26:       theAnimal.itsAge = theAge;
27:    }
28:
29:    int main()
30:    {
31:       Animal peppy;
32:       setValue(peppy,5);
33:       setValue(peppy,7,9);
34:     return 0;
35:    }
</FONT></PRE>
<H3 ALIGN="CENTER"><FONT COLOR="#0066FF"></FONT></H3>
<H3><A NAME="Heading48"></A><FONT COLOR="#000077">Day 16</FONT></H3>
<H4 ALIGN="CENTER"><A NAME="Heading49"></A><FONT COLOR="#000077">Quiz</FONT></H4>

<DL>
	<DD><B>1. What is the insertion operator and what does it do?<BR>
	</B><BR>
	The insertion operator (<TT>&lt;&lt;</TT>) is a member operator of the <TT>ostream</TT>
	object and is used for writing to the output device.<BR>
	<BR>
	<B>2. What is the extraction operator and what does it do?<BR>
	</B><BR>
	The extraction operator (<TT>&gt;&gt;</TT>) is a member operator of the <TT>istream</TT>
	object and is used for writing to your program's variables.<BR>
	<BR>
	<B>3. What are the three forms of <TT>cin.get()</TT> and what are their differences?<BR>
	</B><BR>
	The first form of <TT>get()</TT> is without parameters. This returns the value of
	the character found, and will return <TT>EOF</TT> (end of file) if the end of the
	file is reached.<BR>
	The second form of <TT>cin.get()</TT> takes a character reference as its parameter;
	that character is filled with the next character in the input stream. The return
	value is an <TT>iostream</TT> object.<BR>
	The third form of <TT>cin.get()</TT> takes an array, a maximum number of characters
	to get, and a terminating character. This form of <TT>get()</TT> fills the array
	with up to one fewer characters than the maximum (appending null) unless it reads
	the terminating character, in which case it immediately <BR>
	writes a null and leaves the terminating character in the buffer.<BR>
	<BR>
	<B>4. What is the difference between <TT>cin.read()</TT> and <TT>cin.getline()</TT>?<BR>
	</B><TT><BR>
	cin.read()</TT> is used for reading binary data structures.<BR>
	<TT>getline()</TT> is used to read from the <TT>istream</TT>'s buffer.<BR>
	<BR>
	<B>5. What is the default width for ouputting a <TT>long</TT> integer using the insertion
	operator?<BR>
	</B><BR>
	Wide enough to display the entire number.<BR>
	<BR>
	<B>6. What is the return value of the insertion operator?<BR>
	</B><BR>
	A reference to an <TT>istream</TT> object.<BR>
	<BR>
	<B>7. What parameter does the constructor to an <TT>ofstream</TT> object take?<BR>
	</B><BR>
	The filename to be opened.<BR>
	<BR>
	<B>8. What does the <TT>ios::ate</TT> argument do?<BR>
	</B><TT><BR>
	ios::ate</TT> places you at the end of the file, but you can write data anywhere
	in the file.
</DL>

<H4 ALIGN="CENTER"><A NAME="Heading50"></A><FONT COLOR="#000077">Exercises</FONT></H4>

<DL>
	<DD><B>1. </B>Write a program that writes to the four standard <TT>iostream</TT>
	objects: <TT>cin</TT>, <TT>cout</TT>, <TT>cerr</TT>, and <TT>clog</TT>.
</DL>

<PRE><FONT COLOR="#0066FF">1:     #include &lt;iostream.h&gt;
2:     int main()
3:     {
4:        int x;
5:        cout &lt;&lt; &quot;Enter a number: &quot;;
6:        cin &gt;&gt; x;
7:        cout &lt;&lt; &quot;You entered: &quot; &lt;&lt; x &lt;&lt; endl;
8:        cerr &lt;&lt; &quot;Uh oh, this to cerr!&quot; &lt;&lt; endl;
9:        clog &lt;&lt; &quot;Uh oh, this to clog!&quot; &lt;&lt; endl;
10:     return 0;
11:    }
</FONT></PRE>

<DL>
	<DD><B>2.</B> Write a program that prompts the user to enter her full name and then
	displays it on the screen.
</DL>

<PRE><FONT COLOR="#0066FF">1:     #include &lt;iostream.h&gt;
2:     int main()
3:     {
4:        char name[80];
5:        cout &lt;&lt; &quot;Enter your full name: &quot;;
6:        cin.getline(name,80);
7:        cout &lt;&lt; &quot;\nYou entered: &quot; &lt;&lt; name &lt;&lt; endl;
8:     return 0;
9:     }
</FONT></PRE>

<DL>
	<DD><B>3.</B> Rewrite Listing 16.9 to do the same thing, but without using <TT>putback()</TT>
	or <TT>ignore()</TT>.
</DL>

<PRE><FONT COLOR="#0066FF">1:      // Listing
2:      #include &lt;iostream.h&gt;
3:      
4:      int main()
5:      {
6:         char ch;
7:         cout &lt;&lt; &quot;enter a phrase: &quot;;
8:         while ( cin.get(ch) )
9:         {
10:           switch (ch)
11:           {
12:             case `!':
13:                cout &lt;&lt; `$';
14:                break;
15:             case `#':
16:                break;
17:             default:
18:                cout &lt;&lt; ch;
19:                break;
20:          }
21:        }
22:     return 0;
23:     }
</FONT></PRE>

<DL>
	<DD><B>4.</B> Write a program that takes a filename as a parameter and opens the
	file for reading. Read every character of the file and display only the letters and
	punctuation to the screen. (Ignore all non-printing characters.) Then close the file
	and exit.
</DL>

<PRE><FONT COLOR="#0066FF">1:     #include &lt;fstream.h&gt;
2:     enum BOOL { FALSE, TRUE };
3:     
4:     int main(int argc, char**argv)   // returns 1 on error
5:     {
6:     
7:        if (argc != 2)
8:        {
9:           cout &lt;&lt; &quot;Usage: argv[0] &lt;infile&gt;\n&quot;;
10:          return(1);
11:       }
12:    
13:    // open the input stream
14:       ifstream fin (argv[1],ios::binary);
15:       if (!fin)
16:       {
17:          cout &lt;&lt; &quot;Unable to open &quot; &lt;&lt; argv[1] &lt;&lt; &quot; for reading.\n&quot;;
18:          return(1);
19:       }
20:    
21:       char ch;
22:       while ( fin.get(ch))
23:          if ((ch &gt; 32 &amp;&amp; ch &lt; 127) || ch == `\n' || ch == `\t')
24:             cout &lt;&lt; ch;
25:       fin.close();
26:    }
</FONT></PRE>

<DL>
	<DD><B>5.</B> Write a program that displays its command-line arguments in reverse
	order and does not display the program name.
</DL>

<PRE><FONT COLOR="#0066FF">1:     #include &lt;fstream.h&gt;
2:     
3:     int main(int argc, char**argv)   // returns 1 on error
4:     {
5:        for (int ctr = argc; ctr ; ctr--)
6:          cout &lt;&lt; argv[ctr] &lt;&lt; &quot; &quot;;
7:     }
</FONT></PRE>
<H3><A NAME="Heading51"></A><FONT COLOR="#000077">Day 17</FONT></H3>
<H4 ALIGN="CENTER"><A NAME="Heading52"></A><FONT COLOR="#000077">Quiz</FONT></H4>

<DL>
	<DD><B>1. What is an inclusion guard?<BR>
	</B><BR>
	Inclusion guards are used to protect a header file from being included into a program
	more than once.<BR>
	<BR>
	<B>2. How do you instruct your compiler to print the contents of the intermediate
	file showing the effects of the preprocessor?<BR>
	</B><BR>
	This quiz question must be answered by you, depending on the compiler you are using.<BR>
	<BR>
	<B>3. What is the difference between <TT>#define debug 0</TT> and <TT>#undef debug</TT>?<BR>
	</B><TT><BR>
	#define debug 0</TT> defines the term <TT>debug</TT> to equal 0 (zero). Everywhere
	the word <TT>debug</TT> is found, the character 0 will be substituted. <TT>#undef
	debug</TT> removes any definition of <TT>debug</TT>; when the word <TT>debug</TT>
	is found in the file, it will be left unchanged.<BR>
	<BR>
	<B>4. Name four predefined macros.<BR>
	</B><TT><BR>
	__DATE__</TT>, <TT>__TIME__</TT>, <TT>__FILE__</TT>, <TT>__LINE__</TT><BR>
	<BR>
	<B>5. Why can't you call <TT>invariants()</TT> as the first line of your constructor?<BR>
	</B><BR>
	The job of your constructor is to create the object. The class invariants cannot
	and should not exist before the object is fully created, so any meaningful use of
	<TT>invariants()</TT> will return false until the constructor is finished.
</DL>

<H4 ALIGN="CENTER"><A NAME="Heading53"></A><FONT COLOR="#000077">Exercises</FONT></H4>

<DL>
	<DD><B>1.</B> Write the inclusion guard statements for the header file <TT>STRING.H</TT>.
</DL>

<PRE><FONT COLOR="#0066FF">#ifndef STRING_H
#define STRING_H
...
#endif
</FONT></PRE>

<DL>
	<DD><B>2. </B>Write an <TT>assert()</TT> macro that prints an error message and the
	file and line number if debug level is 2, prints just a message (without file and
	line number) if the level is 1, and does nothing if the level is 0.
</DL>

<PRE><FONT COLOR="#0066FF">1:     #include &lt;iostream.h&gt;
2:     
3:     #ifndef DEBUG
4:     #define ASSERT(x)
5:     #elif DEBUG == 1
6:     #define ASSERT(x) \
7:       if (! (x)) \
8:       { \
9:          cout &lt;&lt; &quot;ERROR!! Assert &quot; &lt;&lt; #x &lt;&lt; &quot; failed\n&quot;; \
10:                 }
11:    #elif DEBUG == 2
12:    #define ASSERT(x) \
13:      if (! (x) ) \
14:      { \
15:       cout &lt;&lt; &quot;ERROR!! Assert &quot; &lt;&lt; #x &lt;&lt; &quot; failed\n&quot;; \
16:      cout &lt;&lt; &quot; on line &quot; &lt;&lt; __LINE__  &lt;&lt; &quot;\n&quot;; \
17:       cout &lt;&lt; &quot; in file &quot; &lt;&lt; __FILE__ &lt;&lt; &quot;\n&quot;;  \
18:  }
19:    #endif
</FONT></PRE>

<DL>
	<DD><B>3.</B> Write a macro <TT>DPrint</TT> that tests whether debug is defined,
	and if it is, prints the value passed in as a parameter.
</DL>

<PRE><FONT COLOR="#0066FF">#ifndef DEBUG
#define DPRINT(string)
#else
#define DPRINT(STRING) cout &lt;&lt; #STRING ;
#endif
</FONT></PRE>

<DL>
	<DD><B>4.</B> Write a function that prints an error message. The function should
	print the line number and filename where the error occurred. Note that the line number
	and filename are passed in to this function.
</DL>

<PRE><FONT COLOR="#0066FF">1:     #include &lt;iostream.h&gt;
2:      
3:       void ErrorFunc(
4:          int LineNumber, 
5:          const char * FileName)
6:      {
7:          cout &lt;&lt; &quot;An error occurred in file &quot;;
8:           cout &lt;&lt; FileName;
9:           cout &lt;&lt; &quot; at line &quot; 
10:          cout &lt;&lt; LineNumber &lt;&lt; endl;
11:     }
</FONT></PRE>

<DL>
	<DD><B>5.</B> How would you call the preceding error function?
</DL>

<PRE><FONT COLOR="#0066FF">1:      // driver program to exercise ErrorFunc
2:      int main()
3:      {
4:           cout &lt;&lt; &quot;An error occurs on next line!&quot;;
5:           ErrorFunc(__LINE__, __FILE__);
6:     return 0;
7:      }
</FONT></PRE>

<DL>
	<DD>Note that the <TT>__LINE__</TT> and <TT>__FILE__</TT> macros are used at the
	point of the error, and not in the error function. If you used them in the error
	function, they would report the line and file for the error function itself.<BR>
	<B><BR>
	6.</B> Write an <TT>assert()</TT> macro that uses the error function from Exercise
	4, and write a driver program that calls that <TT>assert()</TT> macro.
</DL>

<PRE><FONT COLOR="#0066FF">1:     #include &lt;iostream.h&gt;
2:      
3:      #define DEBUG // turn error handling on
4:      
5:      #ifndef DEBUG
6:      #define ASSERT(x)
7:      #else
8:      #define ASSERT(X) \
9:         if (! (X)) \
10:         {   \
11:            ErrorFunc(__LINE__, __FILE__); \
12:         }
13:      #endif
14:      
15:      void ErrorFunc(int LineNumber, const char * FileName)
16:      {
17:           cout &lt;&lt; &quot;An error occurred in file &quot;;
18:           cout &lt;&lt; FileName;
19:           cout &lt;&lt; &quot; at line &quot;;
20:           cout &lt;&lt; LineNumber &lt;&lt; endl;
21:      }
22:      
23:      // driver program to exercise ErrorFunc
24:      int main()
25:      {
26:         int x = 5;
27:         ASSERT(x &gt;= 5);  // no error
28:         x = 3;
29:         ASSERT(x &gt;= 5); // error!
30:     return 0;
31:      }
</FONT></PRE>

<DL>
	<DD>Note that in this case, the <TT>__LINE__</TT> and <TT>__FILE__</TT> macros can
	be called in the <TT>assert()</TT> macro and will still give the correct line (line
	29). This is because the <TT>assert()</TT> macro is expanded in place, where it is
	called. Therefore, this program is evaluated exactly as if <TT>main()</TT> were written
	as
</DL>

<PRE><FONT COLOR="#0066FF">1:      // driver program to exercise ErrorFunc
2:      int main()
3:      {
4:         int x = 5;
5:         if (! (x &gt;= 5)) {ErrorFunc(__LINE__, __FILE__);}
6:         x = 3;
7:         if (! (x &gt;= 5)) {ErrorFunc(__LINE__, __FILE__);}
8:     return 0;
9:     }
</FONT></PRE>
<H3 ALIGN="CENTER"><FONT COLOR="#0066FF"></FONT></H3>
<H3><A NAME="Heading54"></A><FONT COLOR="#000077">Day 18</FONT></H3>
<H4 ALIGN="CENTER"><A NAME="Heading55"></A><FONT COLOR="#000077">Quiz</FONT></H4>

<DL>
	<DD><B>1. What is the difference between object-oriented programming and procedural
	programming?<BR>
	</B><BR>
	Procedural programming focuses on functions separate from data. Object-oriented programming
	ties data and functionality together into objects, and focuses on the interaction
	among the objects.<BR>
	<BR>
	<B>2. To what does &quot;event-driven&quot; refer?<BR>
	</B><BR>
	Event-driven programs are distinguished by the fact that action is taken only in
	response to some form of (usually external) simulation, such as a user's keyboard
	or mouse input.<BR>
	<BR>
	<B>3. What are the stages in the development cycle?<BR>
	</B><BR>
	Typically, the development cycle includes analysis, design, coding, testing, programming,
	and interaction and feedback among these stages.<BR>
	<BR>
	<B>4. What is a rooted hierarchy?<BR>
	</B><BR>
	A rooted hierarchy is one in which all the classes in the program derive directly
	or indirectly from a single base class.<BR>
	<BR>
	<B>5. What is a driver program?<BR>
	</B><BR>
	A driver program is simply a function that is designed to exercise whatever objects
	and functions you are currently programming.<BR>
	<BR>
	<B>6. What is encapsulation?<BR>
	</B><BR>
	Encapsulation refers to the (desirable) trait of bringing together in one class all
	the data and functionality of one discrete entity.
</DL>

<H4 ALIGN="CENTER"><A NAME="Heading56"></A><FONT COLOR="#000077">Exercises</FONT></H4>

<DL>
	<DD><B>1. </B>Suppose you had to simulate the intersection of Massachusetts Avenue
	and Vassar Street--two typical two-lane roads with traffic lights and crosswalks.
	The purpose of the simulation is to determine whether the timing of the traffic signal
	allows for a smooth flow of traffic.<BR>
	<BR>
	<I>What kinds of objects should be modeled in the simulation? What should be the
	classes defined for the simulation?<BR>
	</I><BR>
	Cars, motorcycles, trucks, bicycles, pedestrians, and emergency vehicles all use
	the intersection. In addition, there is a traffic signal with Walk/Don't Walk lights.<BR>
	<BR>
	<I>Should the road surface be included in the simulation?</I><B><BR>
	</B><BR>
	Certainly, road quality can have an effect on the traffic, but for a first design,
	it may be simpler to leave this consideration aside. The first object is probably
	the intersection itself. Perhaps the intersection object maintains lists of cars
	waiting to pass through the signal in each direction, as well as lists of people
	waiting to cross at the crosswalks. It will need methods to choose which and how
	many cars and people go through the intersection.<BR>
	<BR>
	There will be only one intersection, so you may want to consider how you will ensure
	that only one object is instantiated (hint: think about static methods and protected
	access).<BR>
	<BR>
	People and cars are both clients of the intersection. They share a number of characteristics:
	they can appear at any time, there can be any number of them, and they both wait
	at the signal (although in different lines). This suggests that you will want to
	consider a common base class for pedestrians and cars.<BR>
	<BR>
	The classes would therefore include
</DL>

<PRE><FONT COLOR="#0066FF">class Entity;   // a client of the intersection

// the root of all cars, trucks, bicycles and emergency vehicles.
class Vehicle : Entity ...;         

// the root of all People
class Pedestrian : Entity...;     

class Car : public Vehicle...;
class Truck : public Vehicle...;
class Motorcycle : public Vehicle...;
class Bicycle : public Vehicle...;
class Emergency_Vehicle : public Vehicle...;

// contains lists of cars and people waiting to pass
</FONT></PRE>
<PRE><FONT COLOR="#0066FF">
class Intersection;          
</FONT></PRE>

<DL>
	<DD><B>2.</B> Suppose the intersections from Exercise 1 were in a suburb of Boston,
	which has arguably the unfriendliest streets in the United States. At any time, there
	are three kinds of Boston drivers:
	<DL>
		<DD><BR>
		Locals, who continue to drive through intersections after the light turns red<BR>
		<BR>
		Tourists, who drive slowly and cautiously (in a rental car, typically) <BR>
		<BR>
		Taxis, which have a wide variation of driving patterns, depending on the kinds of
		passengers in the cabs
	</DL>
	<DD><BR>
	Also, Boston has two kinds of pedestrians:
	<DL>
		<DD><BR>
		Locals, who cross the street whenever they feel like it and seldom use the crosswalk
		buttons<BR>
		<BR>
		Tourists, who always use the crosswalk buttons and only cross when the Walk/Don't
		Walk light permits.
	</DL>
	<DD><BR>
	Finally, Boston has bicyclists who never pay attention to stoplights<BR>
	<BR>
	<I>How do these considerations change the model?</I><BR>
	<BR>
	A reasonable start on this would be to create derived objects that model the refinements
	suggested by the problem:
</DL>

<PRE><FONT COLOR="#0066FF">class Local_Car : public Car...;
          class Tourist_Car : public Car...;
          class Taxi : public Car...;
          class Local_Pedestrian : public
Pedestrian...;
          class Tourist_Pedestrian : public
Pedestrian...;
          class Boston_Bicycle : public Bicycle...;
</FONT></PRE>

<DL>
	<DD>By using virtual methods, each class can modify the generic behavior to meet
	its own specifications. For example, the Boston driver can react to a red light differently
	than a tourist does, while still inheriting the generic behaviors that continue to
	apply.<BR>
	<BR>
	<B>3. </B>You are asked to design a group scheduler. The software allows you to arrange
	meetings among individuals or groups, and to reserve a limited number of conference
	rooms. Identify the principal subsystems.<BR>
	<BR>
	Two discrete programs need to be written for this project: the client, which the
	users run; and the server, which would run on a separate machine. In addition, the
	client machine would have an administrative component to enable a system administrator
	to add new people and rooms.<BR>
	<BR>
	If you decide to implement this as a client/server model, the client would accept
	input from users and generate a request to the server. The server would service the
	request and send back the results to the client. With this model, many people can
	schedule meetings at the same time.<BR>
	<BR>
	On the client's side, there are two major subsystems in addition to the administrative
	module: the user interface and the communications subsystem. The server's side consists
	of three main subsystems: communications, scheduling, and a mail interface that would
	announce to the user when changes have occurred in the schedule.<BR>
	<BR>
	<B>4. </B>Design and show the interfaces to the classes in the room-reservation portion
	of the program discussed in Exercise 3.<BR>
	<BR>
	A meeting is defined as a group of people reserving a room for a certain amount of
	time. The person making the schedule might want a specific room, or a specified time;
	but the scheduler must always be told how long the meeting will last and who is required
	to attend.<BR>
	<BR>
	The objects will probably include the users of the system as well as the conference
	rooms. Don't forget to include classes for the calendar, and perhaps a <TT>Meeting</TT>
	class that encapsulates all that is known about a particular event.<BR>
	<BR>
	The prototypes for the classes might include:
</DL>

<PRE><FONT COLOR="#0066FF">class Calendar_Class;          // forward reference
class Meeting;               // forward reference
class Configuration
{
public:
     Configuration();
     ~Configuration();
     Meeting Schedule( ListOfPerson&amp;, Delta Time
duration );
     Meeting Schedule( ListOfPerson&amp;, Delta Time
duration, Time );
     Meeting Schedule( ListOfPerson&amp;, Delta Time
duration, Room );
     ListOfPerson&amp;     People();     // public
accessors
     ListOfRoom&amp;     Rooms();     // public accessors
protected:
     ListOfRoom     rooms;
     ListOfPerson     people;
};
typedef long      Room_ID;
class Room
{
public:     
     Room( String name, Room_ID id, int capacity,
String directions = &quot;&quot;, String description = &quot;&quot; );
     ~Room();
     Calendar_Class Calendar();
     
protected:
     Calendar_Class     calendar;
     int          capacity;
     Room_ID     id;
     String          name;
     String          directions;          // where is
this room?
     String          description;
};
typedef long Person_ID;
class Person
{
public:
     Person( String name, Person_ID id );
     ~Person();
     Calendar_Class Calendar();          // the access
point to add meetings
protected:
     Calendar_Class     calendar;
     Person_ID     id;
     String          name;
};
class Calendar_Class
{
public:
     Calendar_Class();
     ~Calendar_Class();
     
     void Add( const Meeting&amp; );               // add a
meeting to the calendar
     void Delete( const Meeting&amp; );                    
     Meeting* Lookup( Time );               // see if
there is a meeting at the 
                                   // given time
     
     Block( Time, Duration, String reason = &quot;&quot; );    
// allocate time to yourself...

protected:
     OrderedListOfMeeting meetings;
};
class Meeting
{
public:
     Meeting( ListOfPerson&amp;, Room room, 
          Time when, Duration duration, String purpose
= &quot;&quot; );
     ~Meeting();
protected:
     ListOfPerson     people;
     Room          room;
     Time          when;
     Duration     duration;
     String          purpose;
};
</FONT></PRE>
<H3><A NAME="Heading57"></A><FONT COLOR="#000077">Day 19</FONT></H3>
<H4 ALIGN="CENTER"><A NAME="Heading58"></A><FONT COLOR="#000077">Quiz</FONT></H4>

<DL>
	<DD><B>1. What is the difference between a template and a macro?<BR>
	</B><BR>
	Templates are built into the C++ language and are type-safe. Macros are implemented
	by the preprocessor and are not type-safe.<BR>
	<BR>
	<B>2. What is the difference between the parameter to a template and the parameter
	to a function?<BR>
	</B><BR>
	The parameter to the template creates an instance of the template for each type.
	If you create six template instances, six different classes or functions are created.
	The parameters to the function change the behavior or data of the function, but only
	one function is created.<BR>
	<BR>
	<B>3. What is the difference between a type-specific template friend class and a
	general template friend class?</B><BR>
	<BR>
	The general template friend function creates one function for every type of the parameterized
	class; the type-specific function creates a type-specific instance for each instance
	of the parameterized class.<BR>
	<BR>
	<B>4. Is it possible to provide special behavior for one instance of a template but
	not for other instances?</B><BR>
	<BR>
	Yes, create a specialized function for the particular instance. In addition to creating
	<TT>Array&lt;t&gt;::SomeFunction()</TT>, also create <TT>Array&lt;int&gt;::SomeFunction()</TT>
	to change the behavior for integer arrays.<BR>
	<BR>
	<B>5. How many static variables are created if you put one static member into a template
	class definition?</B><BR>
	One for each instance of the class.
</DL>

<H4 ALIGN="CENTER"><A NAME="Heading59"></A><FONT COLOR="#000077">Exercises</FONT></H4>

<DL>
	<DD><B>1.</B> Create a template based on this <TT>List</TT> class:
</DL>

<PRE><FONT COLOR="#0066FF">class List
{
private:

public:
     List():head(0),tail(0),theCount(0) {}
     virtual ~List();

     void insert( int value );
     void append( int value );
     int is_present( int value ) const;
     int is_empty() const { return head == 0; }
     int count() const { return theCount; }
private:
     class ListCell
     {
     public:
          ListCell(int value, ListCell *cell = 0):val(value),next(cell){}
          int val;
          ListCell *next;
     };
     ListCell *head;
     ListCell *tail;
     int theCount;
};
</FONT></PRE>
<P>Here is one way to implement this template:</P>
<PRE><FONT COLOR="#0066FF">template &lt;class Type&gt;
class List
{

public:
     List():head(0),tail(0),theCount(0) { }
     virtual ~List();

     void insert( Type value );
     void append( Type value );
     int is_present( Type value ) const;
     int is_empty() const { return head == 0; }
     int count() const { return theCount; }

private:
     class ListCell
     {
     public:
          ListCell(Type value, ListCell *cell = 0):val(value),next(cell){}
          Type val;
          ListCell *next;
     };

     ListCell *head;
     ListCell *tail;
     int theCount;
};
</FONT></PRE>

<DL>
	<DD><B>2. </B>Write the implementation for the <TT>List</TT> class (non-template)
	version.
</DL>

<PRE><FONT COLOR="#0066FF">void List::insert(int value)
{
     ListCell *pt = new ListCell( value, head );
     assert (pt != 0);

     // this line added to handle tail
     if ( head == 0 ) tail = pt;

     head = pt;
     theCount++;
}

void List::append( int value )
{
     ListCell *pt = new ListCell( value );
     if ( head == 0 )
          head = pt;
     else
          tail-&gt;next = pt;
     
     tail = pt;
     theCount++;
}

int List::is_present( int value ) const
{
     if ( head == 0 ) return 0;
     if ( head-&gt;val == value || tail-&gt;val == value )
          return 1;
     
     ListCell *pt = head-&gt;next;
     for (; pt != tail; pt = pt-&gt;next)
          if ( pt-&gt;val == value )
               return 1;
          
     return 0;
}
</FONT></PRE>

<DL>
	<DD><B>3. </B>Write the template version of the implementations.
</DL>

<PRE><FONT COLOR="#0066FF">template &lt;class Type&gt;
List&lt;Type&gt;::~List()
{
     ListCell *pt = head;
     
     while ( pt )
     {
          ListCell *tmp = pt;
          pt = pt-&gt;next;
          delete tmp;
     }
     head = tail = 0;
}

template &lt;class Type&gt;
void List&lt;Type&gt;::insert(Type value)
{
     ListCell *pt = new ListCell( value, head );
     assert (pt != 0);
     
     // this line added to handle tail
     if ( head == 0 ) tail = pt;
     
     head = pt;
     theCount++;
}

template &lt;class Type&gt;
void List&lt;Type&gt;::append( Type value )
{
     ListCell *pt = new ListCell( value );
     if ( head == 0 )
          head = pt;
     else
          tail-&gt;next = pt;
     
     tail = pt;
     theCount++;
}

template &lt;class Type&gt;
int List&lt;Type&gt;::is_present( Type value ) const
{
     if ( head == 0 ) return 0;
     if ( head-&gt;val == value || tail-&gt;val == value )
          return 1;
     
     ListCell *pt = head-&gt;next;
     for (; pt != tail; pt = pt-&gt;next)
          if ( pt-&gt;val == value )
               return 1;
          
     return 0;
}
</FONT></PRE>

<DL>
	<DD><B>4.</B> Declare three <TT>List</TT> objects: a list of strings, a list of <TT>Cat</TT>s
	and a list of <TT>int</TT>s.
</DL>

<PRE><FONT COLOR="#0066FF">List&lt;String&gt; string_list;
List&lt;Cat&gt; Cat_List;
List&lt;int&gt; int_List;
</FONT></PRE>

<DL>
	<DD><B>5. </B>BUG BUSTERS: What is wrong with the following code? (Assume the <TT>List</TT>
	template is defined, and <TT>Cat</TT> is the class defined earlier in the book.)
</DL>

<PRE><FONT COLOR="#0066FF">List&lt;Cat&gt; Cat_List;
Cat Felix;
CatList.append( Felix );
cout &lt;&lt; &quot;Felix is &quot; &lt;&lt;
     ( Cat_List.is_present( Felix ) ) ? &quot;&quot; : &quot;not &quot; &lt;&lt; &quot;present\n&quot;;
</FONT></PRE>

<DL>
	<DD>Hint: (this is tough)<I> What makes <TT>Cat</TT> different from <TT>int</TT>?</I><BR>
	<TT><BR>
	Cat</TT> doesn't have <TT>operator ==</TT> defined; all operations that compare the
	values in the <TT>List</TT> cells, such as <TT>is_present</TT>, will result in compiler
	errors. To reduce the chance of this, put copious comments before the template definition
	stating what operations must be defined for the instantiation to compile.<BR>
	<BR>
	<B>6.</B> Declare friend <TT>operator ==</TT> for <TT>List</TT>.
</DL>

<PRE><FONT COLOR="#0066FF">friend int operator==( const Type&amp; lhs, const Type&amp; rhs );
</FONT></PRE>

<DL>
	<DD><B>7.</B> Implement friend <TT>operator ==</TT> for <TT>List</TT>.
</DL>

<PRE><FONT COLOR="#0066FF">template &lt;class Type&gt;
int List&lt;Type&gt;::operator==( const Type&amp; lhs, const Type&amp; rhs )
{
     // compare lengths first
     if ( lhs.theCount != rhs.theCount )
          return 0;     // lengths differ

     ListCell *lh = lhs.head;
     ListCell *rh = rhs.head;

     for(; lh != 0; lh = lh.next, rh = rh.next )
          if ( lh.value != rh.value )
               return 0;

     return 1;          // if they don't differ, they must match
}
</FONT></PRE>

<DL>
	<DD><B>8.</B> <I>Does <TT>operator==</TT> have the same problem as in Exercise 4?</I><BR>
	<BR>
	Yes, because comparing the array involves comparing the elements, <TT>operator!=</TT>
	must be defined for the elements as well.<BR>
	<BR>
	<B>9.</B> Implement a template function for <TT>swap</TT>, which exchanges two variables.
</DL>

<PRE><FONT COLOR="#0066FF">// template swap:
// must have assignment and the copy constructor defined for the Type.
template &lt;class Type&gt;
void swap( Type&amp; lhs, Type&amp; rhs)
{
     Type temp( lhs );
     lhs = rhs;
     rhs = temp;
}
</FONT></PRE>
<H3><A NAME="Heading60"></A><FONT COLOR="#000077">Day 20</FONT></H3>
<H4 ALIGN="CENTER"><A NAME="Heading61"></A><FONT COLOR="#000077">Quiz</FONT></H4>

<DL>
	<DD><BR>
	<B>1. What is an exception?<BR>
	</B><BR>
	An exception is an object that is created as a result of invoking the keyword <TT>throw</TT>.
	It is used to signal an exceptional condition, and is passed up the call stack to
	the first <TT>catch</TT> statement that handles its type.<BR>
	<BR>
	<B>2. What is a <TT>try</TT> block?<BR>
	</B><BR>
	A <TT>try</TT> block is a set of statements that might generate an exception.<BR>
	<BR>
	<B>3. What is a <TT>catch</TT> statement?<BR>
	</B><BR>
	A <TT>catch</TT> statement has a signature of the type of exception it handles. It
	follows a <TT>try</TT> block and acts as the receiver of exceptions raised within
	the <TT>try</TT> block.<BR>
	<BR>
	<B>4. What information can an exception contain?<BR>
	</B><BR>
	An exception is an object and can contain any information that can be defined within
	a user-created class.<BR>
	<BR>
	<B>5. When are exception objects created?<BR>
	</B><BR>
	Exception objects are created when you invoke the keyword <TT>throw</TT>.<BR>
	<BR>
	<B>6. Should you pass exceptions by value or by reference?<BR>
	</B><BR>
	In general, exceptions should be passed by reference. If you don't intend to modify
	the contents of the exception object, you should pass a <TT>const</TT> reference.<BR>
	<BR>
	<B>7. Will a <TT>catch</TT> statement catch a derived exception if it is looking
	for the base class?<BR>
	</B><BR>
	Yes, if you pass the exception by reference.<BR>
	<BR>
	<B>8. If there are two <TT>catch</TT> statements, one for base and one for derived,
	which should come first?<BR>
	</B><TT><BR>
	catch</TT> statements are examined in the order they appear in the source code. The
	first <TT>catch</TT> statement whose signature matches the exception is used.<BR>
	<BR>
	<B>9. What does <TT>catch(...)</TT> mean?<BR>
	</B><TT><BR>
	catch(...)</TT> will catch any exception of any type.<BR>
	<BR>
	<B>10. What is a breakpoint?<BR>
	</B><BR>
	A breakpoint is a place in the code where the debugger will stop execution.
</DL>

<H4 ALIGN="CENTER"><A NAME="Heading62"></A><FONT COLOR="#000077">Exercises</FONT></H4>

<DL>
	<DD><B>1.</B> Create a <TT>try</TT> block, a <TT>catch</TT> statement, and a simple
	exception.
</DL>

<PRE><FONT COLOR="#0066FF">#include &lt;iostream.h&gt;
class OutOfMemory {};
int main()
{

     try
     {
          int *myInt = new int;
          if (myInt == 0)
               throw OutOfMemory();
     }
     catch (OutOfMemory)
     {
          cout &lt;&lt; &quot;Unable to allocate memory!\n&quot;;
     }
return 0;
 }
</FONT></PRE>

<DL>
	<DD><B>2.</B> Modify the answer from Exercise 1, put data into the exception along
	with an accessor function, and use it in the <TT>catch</TT> block.
</DL>

<PRE><FONT COLOR="#0066FF">#include &lt;iostream.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
class OutOfMemory
{
public:
     OutOfMemory(char *);
     char* GetString() { return itsString; }
private:
     char* itsString;
};

OutOfMemory::OutOfMemory(char * theType)
{
     itsString = new char[80];
     char warning[] = &quot;Out Of Memory! Can't allocate room for: &quot;;
     strncpy(itsString,warning,60);
     strncat(itsString,theType,19);
}

int main()
{

     try
     {
          int *myInt = new int;
          if (myInt == 0)
               throw OutOfMemory(&quot;int&quot;);
     }
     catch (OutOfMemory&amp; theException)
     {
          cout &lt;&lt; theException.GetString();
     }
return 0;
 }
</FONT></PRE>

<DL>
	<DD><B>3. </B>Modify the class from Exercise 2 to be a hierarchy of exceptions. Modify
	the <TT>catch</TT> block to use the derived objects and the base objects.
</DL>

<PRE><FONT COLOR="#0066FF">1:     #include &lt;iostream.h&gt;
2:
3:     // Abstract exception data type
4:     class Exception
5:     {
6:     public:
7:        Exception(){}
8:        virtual ~Exception(){}
9:        virtual void PrintError() = 0;
10:    };
11:
12:    // Derived class to handle memory problems.
13:    // Note no allocation of memory in this class!
14:    class OutOfMemory : public Exception
15:    {
16:    public:
17:       OutOfMemory(){}
18:       ~OutOfMemory(){}
19:       virtual void PrintError();
20:    private:
21:    };
22:
23:    void OutOfMemory::PrintError()
24:    {
25:       cout &lt;&lt; &quot;Out of Memory!!\n&quot;;
26:    }
27:
28:    // Derived class to handle bad numbers
29:    class RangeError : public Exception
30:    {
31:    public:
32:       RangeError(unsigned long number){badNumber = number;}
33:       ~RangeError(){}
34:       virtual void PrintError();
35:       virtual unsigned long GetNumber() { return badNumber; }
36:       virtual void SetNumber(unsigned long number) {badNumber =                        &#194;number;}
37:    private:
38:       unsigned long badNumber;
39:    };
40:
41:    void RangeError::PrintError()
42:    {
43:       cout &lt;&lt; &quot;Number out of range. You used &quot; &lt;&lt; GetNumber() &lt;&lt;                                &#194;&quot;!!\n&quot;;
44:    }
45:
46:    void MyFunction();  // func. prototype
47:
48:    int main()
49:    {
50:       try
51:       {
52:          MyFunction();
53:       }
54:       // Only one catch required, use virtual functions to do the
55:       // right thing.
56:       catch (Exception&amp; theException)
57:       {
58:          theException.PrintError();
59:       }
60:       return 0;
61:     }
62:
63:     void MyFunction()
64:     {
65:          unsigned int *myInt = new unsigned int;
66:          long testNumber;
67:          if (myInt == 0)
68:             throw OutOfMemory();
69:          cout &lt;&lt; &quot;Enter an int: &quot;;
70:          cin &gt;&gt; testNumber;
71:          // this weird test should be replaced by a series
72:          // of tests to complain about bad user input
73:          if (testNumber &gt; 3768 || testNumber &lt; 0)
74:             throw RangeError(testNumber);
75:
76:          *myInt = testNumber;
77:          cout &lt;&lt; &quot;Ok. myInt: &quot; &lt;&lt; *myInt;
78:          delete myInt;
79:    }
</FONT></PRE>

<DL>
	<DD><B>4. </B>Modify the program from Exercise 3 to have three levels of function
	calls.
</DL>

<PRE><FONT COLOR="#0066FF">1:     #include &lt;iostream.h&gt;
2:
3:     // Abstract exception data type
4:     class Exception
5:     {
6:     public:
7:        Exception(){}
8:        virtual ~Exception(){}
9:        virtual void PrintError() = 0;
10:    };
11:
12:    // Derived class to handle memory problems.
13:    // Note no allocation of memory in this class!
14:    class OutOfMemory : public Exception
15:    {
16:    public:
17:       OutOfMemory(){}
18:       ~OutOfMemory(){}
19:       virtual void PrintError();
20:    private:
21:    };
22:
23:    void OutOfMemory::PrintError()
24:    {
25:       cout &lt;&lt; &quot;Out of Memory!!\n&quot;;
26:    }
27:
28:    // Derived class to handle bad numbers
29:    class RangeError : public Exception
30:    {
31:    public:
32:       RangeError(unsigned long number){badNumber = number;}
33:       ~RangeError(){}
34:       virtual void PrintError();
35:       virtual unsigned long GetNumber() { return badNumber; }
36:       virtual void SetNumber(unsigned long number) {badNumber =                        &#194;number;}
37:    private:
38:       unsigned long badNumber;
39:    };
40:
41:    void RangeError::PrintError()
42:    {
43:       cout &lt;&lt; &quot;Number out of range. You used &quot; &lt;&lt; GetNumber() &lt;&lt;                        &#194;&quot;!!\n&quot;;
44:    }
45:
46:    // func. prototypes
47:    void MyFunction();
48:    unsigned int * FunctionTwo();
49:    void FunctionThree(unsigned int *);
50:
51:    int main()
52:    {
53:       try
54:       {
55:          MyFunction();
56:       }
57:       // Only one catch required, use virtual functions to do the
58:       // right thing.
59:       catch (Exception&amp; theException)
60:       {
61:          theException.PrintError();
62:       }
63:       return 0;
64:     }
65:
66:    unsigned int * FunctionTwo()
67:    {
68:       unsigned int *myInt = new unsigned int;
69:      if (myInt == 0)
70:        throw OutOfMemory();
71:      return myInt;
72:   }
73:
74:     void MyFunction()
75:     {
76:          unsigned int *myInt = FunctionTwo();
77:
78:          FunctionThree(myInt);
79:          cout &lt;&lt; &quot;Ok. myInt: &quot; &lt;&lt; *myInt;
80:          delete myInt;
81:    }
82:
83:    void FunctionThree(unsigned int *ptr)
84:    {
85:          long testNumber;
86:          cout &lt;&lt; &quot;Enter an int: &quot;;
87:          cin &gt;&gt; testNumber;
88:          // this weird test should be replaced by a series
89:          // of tests to complain about bad user input
90:          if (testNumber &gt; 3768 || testNumber &lt; 0)
91:             throw RangeError(testNumber);
92:          *ptr = testNumber;
93:    }
</FONT></PRE>

<DL>
	<DD><B>5.</B> BUG BUSTERS: What is wrong with the following code?
</DL>

<PRE><FONT COLOR="#0066FF">#include &quot;stringc.h&quot;          // our string class

class xOutOfMemory
{
public:
     xOutOfMemory( const String&amp; where ) : location( where ){}
     ~xOutOfMemory(){}
     virtual String where(){ return location };
private:
     String location;
}

main()
{
     try {
          char *var = new char;
          if ( var == 0 )
               throw xOutOfMemory();
     }
     catch( xOutOfMemory&amp; theException )
     {
          cout &lt;&lt; &quot;Out of memory at &quot; &lt;&lt; theException.location() &lt;&lt; &quot;\n&quot;;
     }
}
</FONT></PRE>

<DL>
	<DD>In the process of handling an &quot;out of memory&quot; condition, a <TT>string</TT>
	object is created by the constructor of <TT>xOutOfMemory</TT>. This exception can
	only be raised when the program is out of memory, so this allocation must fail.<BR>
	<BR>
	It is possible that trying to create this string will raise the same exception, creating
	an infinite loop until the program crashes. If this string is really required, you
	can allocate the space in a static buffer before beginning the program, and then
	use it as needed when the exception is thrown.
</DL>

<H3 ALIGN="CENTER"></H3>
<H3><A NAME="Heading63"></A><FONT COLOR="#000077">Day 21</FONT></H3>
<H4 ALIGN="CENTER"><A NAME="Heading64"></A><FONT COLOR="#000077">Quiz</FONT></H4>

<DL>
	<DD><B>1. What is the difference between <TT>strcpy()</TT> and <TT>strncpy()</TT>?<BR>
	</B><TT><BR>
	strcpy(char* destination, char* source)</TT> copies <TT>source</TT> to <TT>destination</TT>,
	and puts a null at the end of <TT>destination</TT>. <TT>destination</TT> must be
	large enough to accommodate <TT>source</TT>, or <TT>strcpy()</TT> will simply write
	past the end of the array. <TT>strncpy(char* destination char* source, int howmany)</TT>
	will write <TT>howmany</TT> bytes of <TT>source</TT> to <TT>destination</TT>, but
	will not put a terminating null.<BR>
	<BR>
	<B>2. What does <TT>ctime()</TT> do?<BR>
	</B><TT><BR>
	ctime()</TT> takes a <TT>time_t</TT> variable and returns an ASCII string with the
	current time. The <TT>time_t</TT> variable is typically filled by passing its address
	to <TT>time()</TT>.<BR>
	<BR>
	<B>3. What is the function to call to turn an ASCII string into a <TT>long</TT>?</B>
</DL>

<PRE><FONT COLOR="#0066FF">atol()
</FONT></PRE>

<DL>
	<DD><B>4. What does the complement operator do?<BR>
	</B><BR>
	It flips every bit in a number.<BR>
	<BR>
	<B>5. What is the difference between <TT>OR</TT> and exclusive <TT>OR</TT>?<BR>
	</B><TT><BR>
	OR</TT> returns <TT>TRUE</TT> if either or both bits are set; exclusive <TT>OR</TT>
	returns <TT>TRUE</TT> only if one, but not both, is set.<BR>
	<BR>
	<B>6. What is the difference between <TT>&amp;</TT> and <TT>&amp;&amp;</TT>?<BR>
	</B><TT><BR>
	&amp;</TT> is the bitwise <TT>AND</TT> operator, and <TT>&amp;&amp;</TT> is the logical
	<TT>AND</TT> operator.<BR>
	<BR>
	<B>7. What is the difference between <TT>|</TT> and <TT>||</TT>?<BR>
	</B><TT><BR>
	|</TT> is the bitwise <TT>OR</TT> operator, and <TT>||</TT> is the logical <TT>OR</TT>
	operator.
</DL>

<H4 ALIGN="CENTER"><BR>
<A NAME="Heading65"></A><FONT COLOR="#000077">Exercises</FONT></H4>

<DL>
	<DD><B>1. </B>Write a program to safely copy the contents of a 20-byte string into
	a 10-byte string, truncating whatever won't fit.
</DL>

<PRE><FONT COLOR="#0066FF">1:     #include &lt;iostream.h&gt;
2:     #include &lt;string.h&gt;
3:
4:     int main()
5:     {
6:        char bigString[21] = &quot;12345678901234567890&quot;;
7:        char smallString[10];
8:        strncpy(smallString,bigString,9);
9:        smallString[9]='\0';
10:       cout &lt;&lt; &quot;BigString: &quot; &lt;&lt; bigString &lt;&lt; endl;
11:       cout &lt;&lt; &quot;smallString: &quot; &lt;&lt; smallString &lt;&lt; endl;
12:       return 0;
13:    }
</FONT></PRE>

<DL>
	<DD><B>2.</B> Write a program that tells the current date in the form <TT>7/28/94</TT>.
</DL>

<PRE><FONT COLOR="#0066FF">1:     #include &lt;iostream.h&gt;
2:     #include &lt;time.h&gt;
3:
4:     int main()
5:     {
6:        time_t currentTime;
7:        struct tm *timeStruct;
8:        time (&amp;currentTime);
9:        timeStruct = localtime(&amp;currentTime);
10:
11:       cout &lt;&lt; timeStruct-&gt;tm_mon+1 &lt;&lt; &quot;/&quot;;
12:       cout &lt;&lt; timeStruct-&gt;tm_mday &lt;&lt; &quot;/&quot;;
13:       cout &lt;&lt; timeStruct-&gt;tm_year &lt;&lt; &quot; &quot;;
14:       return 0;
15:    }
</FONT></PRE>

<DL>
	<DD><B>3. </B>Write the definition of a class that uses bit fields to store whether
	the computer is monochrome or color, a PC or Macintosh, a laptop or a desktop, and
	whether it has a CD-ROM.
</DL>

<PRE><FONT COLOR="#0066FF">#include &lt;iostream.h&gt;
enum Boolean { FALSE = 0, TRUE = 1 };

class Computer
{
public:  // types
     enum Machine { Mac = 0, PC };

public:  // methods
     Computer( Boolean color, Boolean laptop, Machine kind, Boolean cdrom )
          : Color( color ), Laptop( laptop ), Kind( kind ), CDRom( cdrom ){}
     ~Computer(){}

     friend ostream&amp; operator&lt;&lt;( ostream&amp; os, const Computer&amp; computer );

private:
     Boolean Color : 1;
     Boolean Laptop : 1;
     Machine Kind : 1;
     Boolean CDRom : 1;
};

     ostream&amp;
operator&lt;&lt;( ostream&amp; os, const Computer&amp; computer )
{
     os &lt;&lt; &quot;[&quot;;
     ( computer.Color ) ? os &lt;&lt; &quot;color&quot; : os &lt;&lt; &quot;monochrome&quot;;
     os &lt;&lt; &quot;, &quot;;
     ( computer.Laptop ) ? os &lt;&lt; &quot;laptop&quot; : os &lt;&lt; &quot;desktop&quot;;
     os &lt;&lt; &quot;, &quot;;
     ( computer.Kind ) ? os &lt;&lt; &quot;PC&quot; : os &lt;&lt; &quot;Mac&quot;;
     os &lt;&lt; &quot;, &quot;;
     ( computer.CDRom ) ? os &lt;&lt; &quot;&quot; : os &lt;&lt; &quot;no &quot;;
     os &lt;&lt; &quot;CD-Rom&quot;;
     os &lt;&lt; &quot;]&quot;;
     return os;
}
 int main()
{
     Computer pc( TRUE, TRUE, Computer :: PC, TRUE );

     cout &lt;&lt; pc &lt;&lt; `\n';
     return 0;
}
</FONT></PRE>

<DL>
	<DD><B>4. </B>Write a program that creates a 26-bit mask. Prompt the user to enter
	a word, and then quickly report on which letters were used in setting and reading
	the bits (one bit per character). The program should treat upper- and lowercase letters
	as the same.
</DL>

<PRE><FONT COLOR="#0066FF">#include &lt;ctype.h&gt;
#include &lt;iostream.h&gt;
#include &lt;string.h&gt;

class Bits
{
public:
     enum { BITS_PER_INT = 16 };
     Bits( int cnt );
     virtual ~Bits();

     void clear();
     void set( int position );
     void reset( int position );
     int is_set( int position );
private:
     unsigned int * bits;
     int count;
     int Ints_Needed;
};

class AlphaBits : private Bits
{
public:
     AlphaBits() : Bits( 26 ){}
     ~AlphaBits(){}

     void clear() { Bits::clear(); }
     void set( char );
     void reset( char );
     int is_set( char );
};

Bits :: Bits( int cnt ) : count( cnt )
{
     Ints_Needed = count / BITS_PER_INT;

     // if there is a remainder, you need one more member in array
     if ( 0 != count % BITS_PER_INT )
          Ints_Needed++;

     // create an array of ints to hold all the bits
     bits = new unsigned int[ Ints_Needed ];

     clear();
}

Bits :: ~Bits()
{
     delete [] bits;
}

void Bits :: clear()
{
     // clear the bits
     for ( int i = 0; i &lt; Ints_Needed; i++ )
          bits[ i ] = 0;
}

void Bits :: set( int position )
{
     // find the bit to set
     int Int_Number = position / BITS_PER_INT;
     int Bit_Number = position % BITS_PER_INT;

     // create mask with that one bit set
     unsigned int mask = 1 &lt;&lt; Bit_Number;

     // set the bit
     bits[ Int_Number ] |= mask;
}

// clear the bit
void Bits :: reset( int position )
{
     int Int_Number = position / BITS_PER_INT;
     int Bit_Number = position % BITS_PER_INT;

     unsigned int mask = ~( 1 &lt;&lt; Bit_Number );

     bits[ Int_Number ] &amp;= mask;
}

int Bits :: is_set( int position )
{
     int Int_Number = position / BITS_PER_INT;
     int Bit_Number = position % BITS_PER_INT;

     unsigned int mask = 1 &lt;&lt; Bit_Number;

     return ( 0 != ( bits[ Int_Number ] &amp; mask ) );
}

void AlphaBits :: set( char s )
{

     // make sure the requested character is an alphabetic character
     // if so, force it to lower case, then subtract the ascii value
     // of `a' to get its ordinal (where a = 0, b =1) and set that bit
     if ( isalpha( s ) )
          Bits :: set( tolower( s ) - `a' );
}

void AlphaBits :: reset( char s )
{
     if ( isalpha( s ) )
          Bits :: reset( tolower( s ) - `a' );
}

int AlphaBits :: is_set( char s )
{
     if ( isalpha( s ) )
          return Bits :: is_set( tolower( s ) - `a' );
     else
          return 0;
}

int main()
{
     AlphaBits letters;

     char buffer[512];

     for (;;)
     {
          cout &lt;&lt; &quot;\nPlease type a word (0 to quit): &quot;;
          cin &gt;&gt; buffer;

          if (strcmp(buffer,&quot;0&quot;) == 0)
             break;

          // set the bits
          for ( char *s = buffer; *s; s++ )
               letters.set( *s );

          // print the results
          cout &lt;&lt; &quot;The letters used were: &quot;;
          for ( char c = `a'; c &lt;= `z'; c++ )
               if ( letters.is_set( c ) )
                    cout &lt;&lt; c &lt;&lt; ` `;
          cout &lt;&lt; `\n';

          // clear the bits
          letters.clear();
     }
    return 0;

</FONT></PRE>

<DL>
	<DD><B>5.</B> Write a program that sorts the command-line parameters. If the user
	enters <TT>SortFunc cat bird fish dog</TT>, the program prints <TT>bird cat dog fish</TT>.
</DL>

<PRE><FONT COLOR="#0066FF">#include &lt;string.h&gt;
#include &lt;iostream.h&gt;

void swap ( char* &amp;s, char* &amp;t )
{
     char* temp = s;
     s = t;
     t = temp;
}

int main( int argc, char* argv[] )
{
     // Since argv[0] is the program name, 
     //we don't want to sort or print it;
// we start sorting at element 1 (not 0).

     // a &quot;Bubble Sort&quot; is used because of the small number of items.
     int i,j;
     for ( i = 1; i &lt; argc; i++ )
          for ( j = i + 1; j &lt; argc; j++ )
               if ( 0 &lt; strcmp( argv[i], argv[j] ) )
                    swap( argv[i], argv[j] );


     for ( i = 1; i &lt; argc; i++ )
          cout &lt;&lt; argv[i] &lt;&lt; ` `;

     cout &lt;&lt; `\n';
    return 0;
}
</FONT></PRE>

<DL>
	<DD><B>6.</B> Write a program that adds two numbers without using the addition operator
	(<TT>+</TT>), subtraction <BR>
	operator (<TT>-</TT>), increment (<TT>++</TT>), or decrement (<TT>--</TT>). Hint:
	Use the bit operators!<BR>
	<BR>
	If you take a look at the addition of two bits, you'll notice the answer will contain
	two bits: the result bit and the carry bit. Thus, adding 1 and 1 in binary results
	in 1 with a carry of 1. If we add 101 to 001, here are the results:
</DL>

<PRE><FONT COLOR="#0066FF">101  // 5
001  //1
110  //6
</FONT></PRE>

<DL>
	<DD>If you add two &quot;set&quot; bits (each is valued as one), the result is that
	the result bit is 0 but the carry bit is 1. If you add two clear bits, both the result
	and the carry are 0. If you add two bits with one set and the other clear, the result
	bit is 1, but the carry bit is 0. Here is a table that summarizes these rules:
</DL>

<PRE><FONT COLOR="#0066FF">lhs   rhs   |   carry   result
------------+------------------
0     0     |   0       0
0     1     |   0       1
1     0     |   0       1
1     1     |   1       0
</FONT></PRE>

<DL>
	<DD>Examine the logic of the carry bit. If both bits to be added (<TT>lhs</TT> and
	<TT>rhs</TT>) are 0 or either side is 0, the answer is 0. Only if both bits are 1
	is the answer 1. This is exactly the same as the <TT>AND</TT> operator (<TT>&amp;</TT>).<BR>
	<BR>
	In the same way, the result is an <TT>XOR</TT> (<TT>^</TT>) operation: if either
	bit is 1 (but not both), the answer is 1; otherwise, the answer is 0.<BR>
	<BR>
	When you get a carry, it is added to the next most significant (leftmost) bit. This
	implies either iterating through each bit or recursion.
</DL>

<PRE><FONT COLOR="#0066FF">
#include &lt;iostream.h&gt;

unsigned int add( unsigned int lhs, unsigned int rhs )
{
     unsigned int result, carry;

     while ( 1 )
     {
          result = lhs ^ rhs;
          carry = lhs &amp; rhs;

          if ( carry == 0 )
               break;

          lhs = carry &lt;&lt; 1;
          rhs = result;
     };

     return result;
}

int main()
{
     unsigned long a, b;
     for (;;)
     {
          cout &lt;&lt; &quot;Enter two numbers. (0 0 to stop): &quot;;
          cin &gt;&gt; a &gt;&gt; b;
          if (!a &amp;&amp; !b)
               break;
          cout &lt;&lt;a &lt;&lt; &quot; + &quot; &lt;&lt; b &lt;&lt; &quot; =  &quot; &lt;&lt; add(a,b) &lt;&lt; endl;
     }
    return 0;
}
</FONT></PRE>

<DL>
	<DD>Alternatively, you can solve this problem with recursion:
</DL>

<PRE><FONT COLOR="#0066FF">#include &lt;iostream.h&gt;

unsigned int add( unsigned int lhs, unsigned int rhs )
{
     unsigned int carry = lhs &amp; rhs;
     unsigned int result = lhs ^ rhs;

     if ( carry )
          return add( result, carry &lt;&lt; 1 );
     else
          return result;
}

int main()
{
     unsigned long a, b;
     for (;;)
     {
          cout &lt;&lt; &quot;Enter two numbers. (0 0 to stop): &quot;;
          cin &gt;&gt; a &gt;&gt; b;
          if (!a &amp;&amp; !b)
               break;
          cout &lt;&lt;a &lt;&lt; &quot; + &quot; &lt;&lt; b &lt;&lt; &quot; =  &quot; &lt;&lt; add(a,b) &lt;&lt; endl;
     }
    return 0;
}

</FONT></PRE>
<H2 ALIGN="CENTER"><A HREF="apc.htm"><IMG SRC="../buttons/BLANPREV.GIF"
WIDTH="37" HEIGHT="37" ALIGN="BOTTOM" BORDER="0"></A><A HREF="http://www.mcp.com/sams"><IMG
SRC="../buttons/BLANHOME.GIF" WIDTH="37" HEIGHT="37" ALIGN="BOTTOM"
BORDER="0"></A><A HREF="../index.htm"><IMG SRC="../buttons/BLANTOC.GIF"
WIDTH="37" HEIGHT="37" ALIGN="BOTTOM" BORDER="0"></A><A HREF="#heading1"><IMG SRC="../buttons/BLANTOP.GIF"
WIDTH="37" HEIGHT="37" ALIGN="BOTTOM" BORDER="0"></A>


</BODY>

</HTML>