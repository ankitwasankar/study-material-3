<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>

<HEAD>
<!-- This document was created from RTF source by rtftohtml version 3.0.1 -->

	<META NAME="GENERATOR" Content="Symantec Visual Page 1.0">
	<META HTTP-EQUIV="Content-Type" CONTENT="text/html;CHARSET=iso-8859-1">
	<TITLE>Teach Yourself C++ in 21 Days</TITLE>
</HEAD>

<BODY TEXT="#000000" BGCOLOR="#FFFFFF">

<H1 ALIGN="CENTER"><A HREF="ch14rv2.htm"><IMG SRC="../buttons/BLANPREV.GIF"
WIDTH="37" HEIGHT="37" ALIGN="BOTTOM" BORDER="0"></A><A HREF="http://www.mcp.com/sams"><IMG
SRC="../buttons/BLANHOME.GIF" WIDTH="37" HEIGHT="37" ALIGN="BOTTOM"
BORDER="0"></A><A HREF="../index.htm"><IMG SRC="../buttons/BLANTOC.GIF"
WIDTH="37" HEIGHT="37" ALIGN="BOTTOM" BORDER="0"></A><A HREF="ch16.htm"><IMG SRC="../buttons/BLANNEXT.GIF"
WIDTH="37" HEIGHT="37" ALIGN="BOTTOM" BORDER="0"></A></H1>
<H1></H1>

<UL>
	<LI><A HREF="#Heading1">Day 15</A>
	<UL>
		<LI><A HREF="#Heading2">Advanced Inheritance</A>
		<UL>
			<LI><A HREF="#Heading3">Containment</A>
			<LI><A HREF="#Heading4">Listing 15.1. The String class</A><A HREF="#Heading5">.</A>
			<LI><A HREF="#Heading6">Listing 15.2. The Employee class and driver program</A><A
			HREF="#Heading7">.</A>
			<UL>
				<LI><A HREF="#Heading8">Accessing Members of the Contained Class</A>
				<LI><A HREF="#Heading9">Filtering Access to Contained Members</A>
				<LI><A HREF="#Heading10">Cost of Containment</A>
			</UL>
			<LI><A HREF="#Heading11">Listing 15.3. Contained class constructors</A><A HREF="#Heading12">.</A>
			<UL>
				<LI><A HREF="#Heading13">Copying by Value</A>
			</UL>
			<LI><A HREF="#Heading14">Listing 15.4. Passing by value</A><A HREF="#Heading15">.</A>
			<LI><A HREF="#Heading16">Implementation in Terms of Inheritance/Containment Versus
			Delegation</A>
			<UL>
				<LI><A HREF="#Heading17">Delegation</A>
			</UL>
			<LI><A HREF="#Heading18">Listing 15.5. Delegating to a contained LinkedList</A><A
			HREF="#Heading19">.</A>
			<LI><A HREF="#Heading20">Private Inheritance</A>
			<LI><A HREF="#Heading21">Listing 15.6. Private</A>
			<LI><A HREF="#Heading22">inheritance</A><A HREF="#Heading23">.</A>
			<LI><A HREF="#Heading24">Friend Classes</A>
			<LI><A HREF="#Heading25">Listing 15.7. Friend class illustrated</A><A HREF="#Heading26">.</A>
			<LI><A HREF="#Heading27">Friend Class</A>
			<LI><A HREF="#Heading28">Friend Functions</A>
			<LI><A HREF="#Heading29">Friend Functions and Operator Overloading</A>
			<LI><A HREF="#Heading30">Listing 15.8. Friendly operator+.</A>
			<LI><A HREF="#Heading31">Friend Functions</A>
			<LI><A HREF="#Heading32">Overloading the Insertion Operator</A>
			<LI><A HREF="#Heading33">Listing 15.9. Overloading operator&lt;&lt;().</A>
			<LI><A HREF="#Heading34">Summary</A>
			<LI><A HREF="#Heading35">Q&amp;A</A>
			<LI><A HREF="#Heading36">Workshop</A>
			<UL>
				<LI><A HREF="#Heading37">Quiz</A>
				<LI><A HREF="#Heading38">Exercises</A>
			</UL>
		</UL>
	</UL>
</UL>

<P>
<HR SIZE="4">

<H2 ALIGN="CENTER"><A NAME="Heading1"></A><FONT COLOR="#000077">Day 15</FONT></H2>

<H2 ALIGN="CENTER"><A NAME="Heading2"></A><FONT COLOR="#000077">Advanced Inheritance</FONT></H2>
<P>So far you have worked with single and multiple inheritance to create is-a relationships.
Today you will learn

<UL>
	<LI>What containment is and how to model it.
	<P>
	<LI>What delegation is and how to model it.
	<P>
	<LI>How to implement one class in terms of another.
	<P>
	<LI>How to use private inheritance.
</UL>

<H3 ALIGN="CENTER"><A NAME="Heading3"></A><FONT COLOR="#000077">Containment</FONT></H3>
<P>As you have seen in previous examples, it is possible for the member data of a
class to include objects of another class. C++ programmers say that the outer class
contains the inner class. Thus, an <TT>Employee</TT> class might contain string objects
(for the name of the employee), as well as integers (for the employee's salary and
so forth).</P>
<P>Listing 15.1 describes an incomplete, but still useful, <TT>String</TT> class.
This listing does not produce any output. Instead Listing 15.1 will be used with
later listings.</P>

<P><A NAME="Heading4"></A><FONT SIZE="4" COLOR="#000077"><B>Listing 15.1. The String
class.</B></FONT>
<PRE><FONT COLOR="#0066FF">1:     #include &lt;iostream.h&gt;
2:     #include &lt;string.h&gt;
3:
4:     class String
5:     {
6:        public:
7:           // constructors
8:           String();
9:            String(const char *const);
10:           String(const String &amp;);
11:          ~String();
12:
13:          // overloaded operators
14:          char &amp; operator[](int offset);
15:          char operator[](int offset) const;
16:          String operator+(const String&amp;);
17:          void operator+=(const String&amp;);
18:          String &amp; operator= (const String &amp;);
19:
20:          // General accessors
21:          int GetLen()const { return itsLen; }
22:          const char * GetString() const { return itsString; }
23:          // static int ConstructorCount;
24:
25:       private:
26:          String (int);         // private constructor
27:          char * itsString;
28:          unsigned short itsLen;
29:
30:    };
31:
32:    // default constructor creates string of 0 bytes
33:    String::String()
34:    {
35:       itsString = new char[1];
36:       itsString[0] = `\0';
37:       itsLen=0;
38:       // cout &lt;&lt; &quot;\tDefault string constructor\n&quot;;
39:       // ConstructorCount++;
40:    }
41:
42:    // private (helper) constructor, used only by
43:    // class methods for creating a new string of
44:    // required size.  Null filled.
45:    String::String(int len)
46:    {
47:       itsString = new char[len+1];
48:       for (int i = 0; i&lt;=len; i++)
49:          itsString[i] = `\0';
50:       itsLen=len;
51:       // cout &lt;&lt; &quot;\tString(int) constructor\n&quot;;
52:       // ConstructorCount++;
53:    }
54:
55:    // Converts a character array to a String
56:    String::String(const char * const cString)
57:    {
58:       itsLen = strlen(cString);
59:       itsString = new char[itsLen+1];
60:       for (int i = 0; i&lt;itsLen; i++)
61:          itsString[i] = cString[i];
62:       itsString[itsLen]='\0';
63:       // cout &lt;&lt; &quot;\tString(char*) constructor\n&quot;;
64:       // ConstructorCount++;
65:    }
66:
67:    // copy constructor
68:    String::String (const String &amp; rhs)
69:    {
70:       itsLen=rhs.GetLen();
71:       itsString = new char[itsLen+1];
72:       for (int i = 0; i&lt;itsLen;i++)
73:          itsString[i] = rhs[i];
74:       itsString[itsLen] = `\0';
75:       // cout &lt;&lt; &quot;\tString(String&amp;) constructor\n&quot;;
76:       // ConstructorCount++;
77:    }
78:
79:    // destructor, frees allocated memory
80:    String::~String ()
81:    {
82:       delete [] itsString;
83:       itsLen = 0;
84:       // cout &lt;&lt; &quot;\tString destructor\n&quot;;
85:    }
86:
87:    // operator equals, frees existing memory
88:    // then copies string and size
89:    String&amp; String::operator=(const String &amp; rhs)
90:    {
91:       if (this == &amp;rhs)
92:          return *this;
93:       delete [] itsString;
94:       itsLen=rhs.GetLen();
95:       itsString = new char[itsLen+1];
96:       for (int i = 0; i&lt;itsLen;i++)
97:          itsString[i] = rhs[i];
98:       itsString[itsLen] = `\0';
99:       return *this;
100:      // cout &lt;&lt; &quot;\tString operator=\n&quot;;
101:   }
102:
103:   //non constant offset operator, returns
104:   // reference to character so it can be
105:   // changed!
106:   char &amp; String::operator[](int offset)
107:   {
108:      if (offset &gt; itsLen)
109:         return itsString[itsLen-1];
110:      else
111:         return itsString[offset];
112:   }
113:
114:   // constant offset operator for use
115:   // on const objects (see copy constructor!)
116:   char String::operator[](int offset) const
117:   {
118:      if (offset &gt; itsLen)
119:         return itsString[itsLen-1];
120:      else
121:         return itsString[offset];
122:   }
123:
124:   // creates a new string by adding current
125:   // string to rhs
126:   String String::operator+(const String&amp; rhs)
127:   {
128:      int  totalLen = itsLen + rhs.GetLen();
129:      String temp(totalLen);
130:      int i, j;
131:      for (i = 0; i&lt;itsLen; i++)
132:         temp[i] = itsString[i];
133:      for (j = 0; j&lt;rhs.GetLen(); j++, i++)
134:         temp[i] = rhs[j];
135:      temp[totalLen]='\0';
136:      return temp;
137:   }
138:
139:   // changes current string, returns nothing
140:   void String::operator+=(const String&amp; rhs)
141:   {
142:      unsigned short rhsLen = rhs.GetLen();
143:      unsigned short totalLen = itsLen + rhsLen;
144:      String  temp(totalLen);
145:      for (int i = 0; i&lt;itsLen; i++)
146:         temp[i] = itsString[i];
147:      for (int j = 0; j&lt;rhs.GetLen(); j++, i++)
148:         temp[i] = rhs[i-itsLen];
149:      temp[totalLen]='\0';
150:      *this = temp;
151:   }
152:
<TT>153: // int String::ConstructorCount = 0;</TT></FONT></PRE>
<P><TT><BR>
</TT><B>Output: </B>None.</P>
<P><FONT COLOR="#000077"><B>Analysis:</B></FONT><B> </B>Listing 15.1 provides a <TT>String</TT>
class much like the one used in Listing 11.14 of Day 11, &quot;Arrays.&quot; The
significant difference here is that the constructors and a few other functions in
Listing 11.14 have print statements to show their use, which are currently commented
out in Listing 15.1. These functions will be used in later examples.</P>
<P>On line 23, the static member variable <TT>ConstructorCount</TT> is declared,
and on line 153 it is initialized. This variable is incremented in each string constructor.
All of this is currently commented out; it will be used in a later listing.</P>
<P>Listing 15.2 describes an <TT>Employee</TT> class that contains three string objects.
Note that a number of statements are commented out; they will be used in later listings.</P>

<P><A NAME="Heading6"></A><FONT SIZE="4" COLOR="#000077"><B>Listing 15.2. The Employee
class and driver program.</B></FONT><FONT SIZE="4" COLOR="#0066FF"><B></B></FONT>
<PRE><FONT COLOR="#0066FF">1:     class Employee
2:     {
3:
4:     public:
5:        Employee();
6:        Employee(char *, char *, char *, long);
7:        ~Employee();
8:        Employee(const Employee&amp;);
9:        Employee &amp; operator= (const Employee &amp;);
10:
11:       const String &amp; GetFirstName() const 
12:          { return itsFirstName; }
13:       const String &amp; GetLastName() const { return itsLastName; }
14:       const String &amp; GetAddress() const { return itsAddress; }
15:       long GetSalary() const { return itsSalary; }
16:
17:       void SetFirstName(const String &amp; fName) 
18:           { itsFirstName = fName; }
19:       void SetLastName(const String &amp; lName) 
20:          { itsLastName = lName; }
21:       void SetAddress(const String &amp; address) 
22:            { itsAddress = address; }
23:       void SetSalary(long salary) { itsSalary = salary; }
24:    private:
25:       String    itsFirstName;
26:       String    itsLastName;
27:       String    itsAddress;
28:       long      itsSalary;
29:    };
30:
31:    Employee::Employee():
32:       itsFirstName(&quot;&quot;),
33:       itsLastName(&quot;&quot;),
34:       itsAddress(&quot;&quot;),
35:       itsSalary(0)
36:    {}
37:
38:    Employee::Employee(char * firstName, char * lastName,
39:       char * address, long salary):
40:       itsFirstName(firstName),
41:       itsLastName(lastName),
42:       itsAddress(address),
43:       itsSalary(salary)
44:    {}
45:
46:    Employee::Employee(const Employee &amp; rhs):
47:       itsFirstName(rhs.GetFirstName()),
48:       itsLastName(rhs.GetLastName()),
49:       itsAddress(rhs.GetAddress()),
50:       itsSalary(rhs.GetSalary())
51:    {}
52:
53:    Employee::~Employee() {}
54:
55:    Employee &amp; Employee::operator= (const Employee &amp; rhs)
56:    {
57:       if (this == &amp;rhs)
58:          return *this;
59:
60:       itsFirstName = rhs.GetFirstName();
61:       itsLastName = rhs.GetLastName();
62:       itsAddress = rhs.GetAddress();
63:       itsSalary = rhs.GetSalary();
64:
65:       return *this;
66:    }
67:
68:    int main()
69:    {
70:       Employee Edie(&quot;Jane&quot;,&quot;Doe&quot;,&quot;1461 Shore Parkway&quot;, 20000);
71:       Edie.SetSalary(50000);
72:       String LastName(&quot;Levine&quot;);
73:       Edie.SetLastName(LastName);
74:       Edie.SetFirstName(&quot;Edythe&quot;);
75:
76:       cout &lt;&lt; &quot;Name: &quot;;
77:       cout &lt;&lt; Edie.GetFirstName().GetString();
78:       cout &lt;&lt; &quot; &quot; &lt;&lt; Edie.GetLastName().GetString();
79:       cout &lt;&lt; &quot;.\nAddress: &quot;;
80:       cout &lt;&lt; Edie.GetAddress().GetString();
81:       cout &lt;&lt; &quot;.\nSalary: &quot; ;
82:       cout &lt;&lt; Edie.GetSalary();
83:     return 0;
<TT>84: }</TT></FONT></PRE>


<BLOCKQUOTE>
	<P>
<HR>
<FONT COLOR="#000077"><B>NOTE: </B></FONT>Put the code from Listing 15.1 into a file
	called <TT>STRING.HPP</TT>. Then any time you need the <TT>String</TT> class you
	can include Listing 15.1 by using <TT>#include</TT>. For example, at the top of Listing
	15.2 add the line <TT>#include String.hpp</TT>. This will add the <TT>String</TT>
	class to your program. 
<HR>


</BLOCKQUOTE>

<PRE><FONT COLOR="#0066FF">Output: Name: Edythe Levine.
Address: 1461 Shore Parkway.
Salary: 50000
</FONT></PRE>
<P><FONT COLOR="#000077"><B>Analysis:</B></FONT><B> </B>Listing 15.2 shows the <TT>Employee</TT>
class, which contains three string objects: <TT>itsFirstName</TT>,<TT> itsLastName</TT>,
and <TT>itsAddress</TT>.</P>
<P>On line 70, an <TT>Employee</TT> object is created, and four values are passed
in to initialize the <TT>Employee</TT> object. On line 71, the <TT>Employee</TT>
access function <TT>SetSalary()</TT> is called, with the constant value <TT>50000</TT>.
Note that in a real program this would either be a dynamic value (set at runtime)
or a constant.</P>
<P>On line 72, a string is created and initialized using a C++ string constant. This
string object is then used as an argument to <TT>SetLastName()</TT> on line 73.</P>
<P>On line 74, the <TT>Employee</TT> function <TT>SetFirstName()</TT> is called with
yet another string constant. However, if you are paying close attention, you will
notice that <TT>Employee</TT> does not have a function <TT>SetFirstName()</TT> that
takes a character string as its argument; <TT>SetFirstName()</TT> requires a constant
string reference.</P>
<P>The compiler resolves this because it knows how to make a string from a constant
character string. It knows this because you told it how to do so on line 9 of Listing
15.1.
<H4 ALIGN="CENTER"><A NAME="Heading8"></A><FONT COLOR="#000077">Accessing Members
of the Contained Class</FONT></H4>
<P><TT>Employee</TT> objects do not have special access to the member variables of
<TT>String</TT>. If the <TT>Employee</TT> object <TT>Edie</TT> tried to access the
member variable <TT>itsLen</TT> of its own <TT>itsFirstName</TT> member variable,
it would get a compile-time error. This is not much of a burden, however. The accessor
functions provide an interface for the <TT>String</TT> class, and the <TT>Employee</TT>
class need not worry about the implementation details, any more than it worries about
how the integer variable, <TT>itsSalary</TT>, stores its information.
<H4 ALIGN="CENTER"><A NAME="Heading9"></A><FONT COLOR="#000077">Filtering Access
to Contained Members</FONT></H4>
<P>Note that the <TT>String</TT> class provides the <TT>operator+</TT>. The designer
of the <TT>Employee</TT> class has blocked access to the <TT>operator+</TT> being
called on <TT>Employee</TT> objects by declaring that all the string accessors, such
as <TT>GetFirstName()</TT>, return a constant reference. Because <TT>operator+</TT>
is not (and can't be) a <TT>const</TT> function (it changes the object it is called
on), attempting to write the following will cause a compile-time error:</P>
<PRE><FONT COLOR="#0066FF">String buffer = Edie.GetFirstName() + Edie.GetLastName();
</FONT></PRE>
<P><TT>GetFirstName()</TT> returns a constant <TT>String</TT>, and you can't call
<TT>operator+</TT> on a constant object.</P>
<P>To fix this, overload <TT>GetFirstName()</TT> to be non-<TT>const</TT>:</P>
<PRE><FONT COLOR="#0066FF">const String &amp; GetFirstName() const { return itsFirstName; }
String &amp; GetFirstName()  { return itsFirstName; }
</FONT></PRE>
<P>Note that the return value is no longer <TT>const</TT> and that the member function
itself is no longer <TT>const</TT>. Changing the return value is not sufficient to
overload the function name; you must change the constancy of the function itself.
<H4 ALIGN="CENTER"><A NAME="Heading10"></A><FONT COLOR="#000077">Cost of Containment</FONT></H4>
<P>It is important to note that the user of an <TT>Employee</TT> class pays the price
of each of those string objects each time one is constructed, or a copy of the <TT>Employee</TT>
is made.</P>
<P>Uncommenting the <TT>cout</TT> statements in Listing 15.1, lines 38, 51, 63, 75,
84, and 100, reveals how often these are called. Listing 15.3 rewrites the driver
program to add <TT>print</TT> statements indicating where in the program objects
are being created:


<BLOCKQUOTE>
	<P>
<HR>
<FONT COLOR="#000077"><B>NOTE: </B></FONT>To compile this listing, follow these steps:
	1. Uncomment lines 38, 51, 63, 75, 84, and 100 in Listing 15.1. 2. Edit Listing 15.2.
	Remove lines 64-80 and substitute Listing 15.3. 3. Add <TT>#include string.hpp</TT>
	as previously noted. 
<HR>


</BLOCKQUOTE>

<P><A NAME="Heading11"></A><FONT SIZE="4" COLOR="#000077"><B>Listing 15.3. Contained
class constructors.</B></FONT>
<PRE><FONT COLOR="#0066FF">1:     int main()
2:     {
3:        cout &lt;&lt; &quot;Creating Edie...\n&quot;;
4:        Employee Edie(&quot;Jane&quot;,&quot;Doe&quot;,&quot;1461 Shore Parkway&quot;, 20000);
5:        Edie.SetSalary(20000);
6:        cout &lt;&lt; &quot;Calling SetFirstName with char *...\n&quot;;
7:        Edie.SetFirstName(&quot;Edythe&quot;);
8:        cout &lt;&lt; &quot;Creating temporary string LastName...\n&quot;;
9:        String LastName(&quot;Levine&quot;);
10:       Edie.SetLastName(LastName);
11:
12:       cout &lt;&lt; &quot;Name: &quot;;
13:       cout &lt;&lt; Edie.GetFirstName().GetString();
14:       cout &lt;&lt; &quot; &quot; &lt;&lt; Edie.GetLastName().GetString();
15:       cout &lt;&lt; &quot;\nAddress: &quot;;
16:       cout &lt;&lt; Edie.GetAddress().GetString();
17:       cout &lt;&lt; &quot;\nSalary: &quot; ;
18:       cout &lt;&lt; Edie.GetSalary();
19:       cout &lt;&lt; endl;
20:     return 0;
<TT>21: }</TT></FONT>
<FONT COLOR="#0066FF">
Output: 1:   Creating Edie...
2:           String(char*) constructor
3:           String(char*) constructor
4:           String(char*) constructor
5:   Calling SetFirstName with char *...
6:           String(char*) constructor
7:           String destructor
8:   Creating temporary string LstName...
9:           String(char*) constructor
10:  Name: Edythe Levine
11:  Address: 1461 Shore Parkway
12:  Salary: 20000
13:          String destructor
14:          String destructor
15:          String destructor
16:          String destructor
</FONT></PRE>
<P><B>Analysis: </B>Listing 15.3 uses the same class declarations as Listings 15.1
and 15.2. However, the <TT>cout</TT> statements have been uncommented. The output
from Listing 15.3 has been numbered to make analysis easier.</P>
<P>On line 3 of Listing 15.3, the statement <TT>Creating Edie...</TT> is printed,
as reflected on line 1 of the output. On line 4 an <TT>Employee</TT> object, <TT>Edie</TT>,
is created with four parameters. The output reflects the constructor for <TT>String</TT>
being called three times, as expected.</P>
<P>Line 6 prints an information statement, and then on line 7 is the statement <TT>Edie.SetFirstName(&quot;Edythe&quot;)</TT>.
This statement causes a temporary string to be created from the character string
<TT>&quot;Edythe&quot;</TT>, as reflected on lines 6 and 7 of the output. Note that
the temporary is destroyed immediately after it is used in the assignment statement.</P>
<P>On line 9, a <TT>String</TT> object is created in the body of the program. Here
the programmer is doing explicitly what the compiler did implicitly on the previous
statement. This time you see the constructor on line 9 of the output, but no destructor.
This object will not be destroyed until it goes out of scope at the end of the function.</P>
<P>On lines 13-19, the strings in the employee object are destroyed as the <TT>Employee</TT>
object falls out of scope, and the string <TT>LastName</TT>, created on line 9, is
destroyed as well when it falls out of scope.
<H4 ALIGN="CENTER"><A NAME="Heading13"></A><FONT COLOR="#000077">Copying by Value</FONT></H4>
<P>Listing 15.3 illustrates how the creation of one <TT>Employee</TT> object caused
five string constructor calls. Listing 15.4 again rewrites the driver program. This
time the <TT>print</TT> statements are not used, but the string static member variable
<TT>ConstructorCount</TT> is uncommented and used.</P>
<P>Examination of Listing 15.1 shows that <TT>ConstructorCount</TT> is incremented
each time a string constructor is called. The driver program in 15.4 calls the <TT>print</TT>
functions, passing in the <TT>Employee</TT> object, first by reference and then by
value. <TT>ConstructorCount</TT> keeps track of how many string objects are created
when the employee is passed as a parameter.


<BLOCKQUOTE>
	<P>
<HR>
<FONT COLOR="#000077"><B>NOTE:</B></FONT><B> </B>To compile this listing: 1. Uncomment
	lines 23, 39, 52, 64, 76, and 152 in Listing 15.1. 2. Edit Listing 15.2. Remove lines
	68-84 and substitute Listing 15.4. 3. Add <TT>#include string.hpp</TT> as previously
	noted. 
<HR>


</BLOCKQUOTE>

<P><A NAME="Heading14"></A><FONT SIZE="4" COLOR="#000077"><B>Listing 15.4. Passing
by value</B></FONT>
<PRE><FONT COLOR="#0066FF">1:     void PrintFunc(Employee);
2:     void rPrintFunc(const Employee&amp;);
3:
4:     int main()
5:     {
6:        Employee Edie(&quot;Jane&quot;,&quot;Doe&quot;,&quot;1461 Shore Parkway&quot;, 20000);
7:        Edie.SetSalary(20000);
8:        Edie.SetFirstName(&quot;Edythe&quot;);
9:        String LastName(&quot;Levine&quot;);
10:       Edie.SetLastName(LastName);
11:
12:       cout &lt;&lt; &quot;Constructor count: &quot; ;
13:       cout &lt;&lt; String::ConstructorCount &lt;&lt; endl;
14:       rPrintFunc(Edie);
15:       cout &lt;&lt; &quot;Constructor count: &quot;;
16:        cout &lt;&lt; String::ConstructorCount &lt;&lt; endl;
17:       PrintFunc(Edie);
18:       cout &lt;&lt; &quot;Constructor count: &quot;;
19:        cout &lt;&lt; String::ConstructorCount &lt;&lt; endl;
20:     return 0;
21:    }
22:    void PrintFunc (Employee Edie)
23:    {
24:
25:       cout &lt;&lt; &quot;Name: &quot;;
26:       cout &lt;&lt; Edie.GetFirstName().GetString();
27:       cout &lt;&lt; &quot; &quot; &lt;&lt; Edie.GetLastName().GetString();
28:       cout &lt;&lt; &quot;.\nAddress: &quot;;
29:       cout &lt;&lt; Edie.GetAddress().GetString();
30:       cout &lt;&lt; &quot;.\nSalary: &quot; ;
31:       cout &lt;&lt; Edie.GetSalary();
32:       cout &lt;&lt; endl;
33:
34:    }
35:
36:    void rPrintFunc (const Employee&amp; Edie)
37:    {
38:       cout &lt;&lt; &quot;Name: &quot;;
39:       cout &lt;&lt; Edie.GetFirstName().GetString();
40:       cout &lt;&lt; &quot; &quot; &lt;&lt; Edie.GetLastName().GetString();
41:       cout &lt;&lt; &quot;\nAddress: &quot;;
42:       cout &lt;&lt; Edie.GetAddress().GetString();
43:       cout &lt;&lt; &quot;\nSalary: &quot; ;
44:       cout &lt;&lt; Edie.GetSalary();
45:       cout &lt;&lt; endl;
<TT>46: }</TT>
Output: String(char*) constructor
        String(char*) constructor
        String(char*) constructor
        String(char*) constructor
        String destructor
        String(char*) constructor
Constructor count: 5
Name: Edythe Levine
Address: 1461 Shore Parkway
Salary: 20000
Constructor count: 5
        String(String&amp;) constructor
        String(String&amp;) constructor
        String(String&amp;) constructor
Name: Edythe Levine.
Address: 1461 Shore Parkway.
Salary: 20000
        String destructor
        String destructor
        String destructor
Constructor count: 8
String destructor
        String destructor
        String destructor
        String destructor
</FONT></PRE>
<P><FONT COLOR="#000077"><B>Analysis:</B></FONT><B> </B>The output shows that five
string objects were created as part of creating one <TT>Employee</TT> object. When
the <TT>Employee</TT> object is passed to <TT>rPrintFunc()</TT> by reference, no
additional <TT>Employee</TT> objects are created, and so no additional <TT>String</TT>
objects are created. (They too are passed by reference.)</P>
<P>When, on line 14, the <TT>Employee</TT> object is passed to <TT>PrintFunc()</TT>
by value, a copy of the <TT>Employee</TT> is created, and three more string objects
are created (by calls to the copy constructor).
<H3 ALIGN="CENTER"><A NAME="Heading16"></A><FONT COLOR="#000077">Implementation in
Terms of Inheritance/Containment Versus Delegation</FONT></H3>
<P>At times, one class wants to draw on some of the attributes of another class.
For example, let's say you need to create a <TT>PartsCatalog</TT> class. The specification
you've been given defines a <TT>PartsCatalog</TT> as a collection of parts; each
part has a unique part number. The <TT>PartsCatalog</TT> does not allow duplicate
entries, and does allow access by part number.</P>
<P>The listing for the Week in Review for Week 2 provides a <TT>LinkedList</TT> class.
This <TT>LinkedList</TT> is well-tested and understood, and you'd like to build on
that technology when making your <TT>PartsCatalog</TT>, rather than inventing it
from scratch.</P>
<P>You could create a new <TT>PartsCatalog</TT> class and have it contain a <TT>LinkedList</TT>.
The <TT>PartsCatalog</TT> could delegate management of the linked list to its contained
<TT>LinkedList</TT> object.</P>
<P>An alternative would be to make the <TT>PartsCatalog</TT> derive from <TT>LinkedList</TT>
and thereby inherit the properties of a <TT>LinkedList</TT>. Remembering, however,
that public inheritance provides an is-a relationship, you should question whether
a <TT>PartsCatalog</TT> really is a type of <TT>LinkedList</TT>.</P>
<P>One way to answer the question of whether <TT>PartsCatalog</TT> is a <TT>LinkedList</TT>
is to assume that <TT>LinkedList</TT> is the base and <TT>PartsCatalog</TT> is the
derived class, and then to ask these other questions:

<DL>
	<DD><B>1.</B> Is there anything in the base class that should not be in the derived?
	For example, does the <TT>LinkedList</TT> base class have functions that are inappropriate
	for the <TT>PartsCatalog</TT> <BR>
	class? If so, you probably don't want public inheritance.<BR>
	<BR>
	<B>2.</B> Might the class you are creating have more than one of the base? For example,
	might a <TT>PartsCatalog</TT> need two <TT>LinkedList</TT>s in each object? If it
	might, you almost certainly want to use containment.<BR>
	<BR>
	<B>3.</B> Do you need to inherit from the base class so that you can take advantage
	of virtual functions or access protected members? If so, you must use inheritance,
	public or private.
</DL>

<P>Based on the answers to these questions, you must chose between public inheritance
(the is-a relationship) and either private inheritance or containment.

<DL>
	<DD>
<HR>
<FONT COLOR="#000077"><B>New Term:</B></FONT>
	<UL>
		<P>
	</UL>
	<DD><B>Contained --</B>An object declared as a member of another class contained
	by that class.<BR>
	<BR>
	<B>Delegation -</B>-Using the attributes of a contained class to accomplish functions
	not otherwise available to the containing class.<BR>
	<BR>
	<B>Implemented in terms of --</B>Building one class on the capabilities of another
	without using public inheritance. 
<HR>

</DL>

<H4 ALIGN="CENTER"><A NAME="Heading17"></A><FONT COLOR="#000077">Delegation</FONT></H4>
<P>Why not derive <TT>PartsCatalog</TT> from <TT>LinkedList</TT>? The <TT>PartsCatalog</TT>
isn't a <TT>LinkedList</TT> because <TT>LinkedList</TT>s are ordered collections
and each member of the collection can repeat. The <TT>PartsCatalog</TT> has unique
entries that are not ordered. The fifth member of the <TT>PartsCatalog</TT> is not
part number 5.</P>
<P>Certainly it would have been possible to inherit publicly from <TT>PartsList</TT>
and then override <TT>Insert()</TT> and the offset operators (<TT>[]</TT>) to do
the right thing, but then you would have changed the essence of the <TT>PartsList</TT>
class. Instead you'll build a <TT>PartsCatalog</TT> that has no offset operator,
does not allow duplicates, and defines the <TT>operator+</TT> to combine two sets.</P>
<P>The first way to accomplish this is with containment. The <TT>PartsCatalog</TT>
will delegate list management to a contained <TT>LinkedList</TT>. Listing 15.5 illustrates
this approach.</P>

<P><A NAME="Heading18"></A><FONT SIZE="4" COLOR="#000077"><B>Listing 15.5. Delegating
to a contained LinkedList.</B></FONT>
<PRE><FONT COLOR="#0066FF">0:      #include &lt;iostream.h&gt;
1:    
2:      typedef unsigned long ULONG;
3:      typedef unsigned short USHORT;
4:    
5:    
6:      // **************** Part ************
7:    
8:      // Abstract base class of parts
9:      class Part
10:      {
11:      public:
12:         Part():itsPartNumber(1) {}
13:         Part(ULONG PartNumber):
14:             itsPartNumber(PartNumber){}
15:         virtual ~Part(){}
16:         ULONG GetPartNumber() const 
17:             { return itsPartNumber; }
18:         virtual void Display() const =0; 
19:      private:
20:         ULONG itsPartNumber;
21:      };
22:    
23:      // implementation of pure virtual function so that
24:      // derived classes can chain up
25:      void Part::Display() const
26:      {
27:          cout &lt;&lt; &quot;\nPart Number: &quot; &lt;&lt; itsPartNumber &lt;&lt; endl;
28:      }
29:    
30:      // **************** Car Part ************
31:    
32:      class CarPart : public Part
33:      {
34:      public:
35:         CarPart():itsModelYear(94){}
36:         CarPart(USHORT year, ULONG partNumber);
37:         virtual void Display() const 
38:         { 
39:             Part::Display(); 
40:             cout &lt;&lt; &quot;Model Year: &quot;;
41:             cout &lt;&lt; itsModelYear &lt;&lt; endl;  
42:         }
43:      private:
44:         USHORT itsModelYear;
45:      };
46:    
47:      CarPart::CarPart(USHORT year, ULONG partNumber):
48:         itsModelYear(year),
49:         Part(partNumber)
50:      {}
51:    
52:    
53:      // **************** AirPlane Part ************
54:    
55:      class AirPlanePart : public Part
56:      {
57:      public:
58:         AirPlanePart():itsEngineNumber(1){};
59:         AirPlanePart
60:             (USHORT EngineNumber, ULONG PartNumber);
61:         virtual void Display() const
62:         { 
63:             Part::Display(); 
64:             cout &lt;&lt; &quot;Engine No.: &quot;;
65:             cout &lt;&lt; itsEngineNumber &lt;&lt; endl;  
66:         }
67:      private:
68:         USHORT itsEngineNumber;
69:      };
70:    
71:      AirPlanePart::AirPlanePart
72:          (USHORT EngineNumber, ULONG PartNumber):
73:         itsEngineNumber(EngineNumber),
74:         Part(PartNumber)
75:      {}
76:    
77:      // **************** Part Node ************
78:      class PartNode
79:      {
80:      public:
81:         PartNode (Part*);
82:         ~PartNode();
83:         void SetNext(PartNode * node) 
84:            { itsNext = node; }
85:         PartNode * GetNext() const;
86:         Part * GetPart() const;
87:      private:
88:         Part *itsPart;
89:         PartNode * itsNext;
90:      };
91:       // PartNode Implementations...
92:    
93:       PartNode::PartNode(Part* pPart):
94:       itsPart(pPart),
95:       itsNext(0)
96:       {}
97:    
98:       PartNode::~PartNode()
99:       {
100:          delete itsPart;
101:          itsPart = 0;
102:          delete itsNext;
103:          itsNext = 0;
104:       }
105:    
106:       // Returns NULL if no next PartNode
107:       PartNode * PartNode::GetNext() const
108:       {
109:             return itsNext;
110:       }
111:    
112:       Part * PartNode::GetPart() const
113:       {
114:          if (itsPart)
115:             return itsPart;
116:          else
117:             return NULL; //error
118:       }
119:    
120:    
121:    
122:      // **************** Part List ************
123:      class PartsList
124:      {
125:      public:
126:         PartsList();
127:         ~PartsList();
128:         // needs copy constructor and operator equals!
129:         void     Iterate(void (Part::*f)()const) const;
130:         Part*    Find(ULONG &amp; position, ULONG PartNumber)  const;
131:         Part*    GetFirst() const;
132:         void     Insert(Part *);
133:         Part*    operator[](ULONG) const;
134:         ULONG    GetCount() const { return itsCount; }
135:         static    PartsList&amp; GetGlobalPartsList() 
136:         { 
137:             return  GlobalPartsList; 
138:         }
139:      private:
140:         PartNode * pHead;
141:         ULONG itsCount;
142:         static PartsList GlobalPartsList;
143:      };
144:    
145:      PartsList PartsList::GlobalPartsList;
146:    
147: 
148:       PartsList::PartsList():
149:          pHead(0),
150:          itsCount(0)
151:          {}
152:    
153:       PartsList::~PartsList()
154:       {
155:          delete pHead;
156:       }
157:    
158:       Part*   PartsList::GetFirst() const
159:       {
160:          if (pHead)
161:             return pHead-&gt;GetPart();
162:          else
163:             return NULL;  // error catch here
164:       }
165:    
166:       Part *  PartsList::operator[](ULONG offSet) const
167:       {
168:          PartNode* pNode = pHead;
169:    
170:          if (!pHead)
171:             return NULL; // error catch here
172:    
173:          if (offSet &gt; itsCount)
174:             return NULL; // error
175:    
176:          for (ULONG i=0;i&lt;offSet; i++)
177:             pNode = pNode-&gt;GetNext();
178:    
179:         return   pNode-&gt;GetPart();
180:       }
181:    
182:       Part*   PartsList::Find(
183:           ULONG &amp; position, 
184:           ULONG PartNumber)  const
185:       {
186:          PartNode * pNode = 0;
187:          for (pNode = pHead, position = 0;
188:                pNode!=NULL;
189:                pNode = pNode-&gt;GetNext(), position++)
190:          {
191:             if (pNode-&gt;GetPart()-&gt;GetPartNumber() == PartNumber)
192:                break;
193:          }
194:          if (pNode == NULL)
195:             return NULL;
196:          else
197:             return pNode-&gt;GetPart();
198:       }
199:    
200:       void PartsList::Iterate(void (Part::*func)()const) const
201:       {
202:          if (!pHead)
203:             return;
204:          PartNode* pNode = pHead;
205:          do
206:             (pNode-&gt;GetPart()-&gt;*func)();
207:          while (pNode = pNode-&gt;GetNext());
208:       }
209:    
210:       void PartsList::Insert(Part* pPart)
211:       {
212:          PartNode * pNode = new PartNode(pPart);
213:          PartNode * pCurrent = pHead;
214:          PartNode * pNext = 0;
215:    
216:          ULONG New =  pPart-&gt;GetPartNumber();
217:          ULONG Next = 0;
218:          itsCount++;
219:    
220:          if (!pHead)
221:          {
222:             pHead = pNode;
223:             return;
224:          }
225:    
226:          // if this one is smaller than head
227:          // this one is the new head
228:          if (pHead-&gt;GetPart()-&gt;GetPartNumber() &gt; New)
229:          {
230:             pNode-&gt;SetNext(pHead);
231:             pHead = pNode;
232:             return;
233:          }
234:    
235:          for (;;)
236:          {
237:             // if there is no next, append this new one
238:             if (!pCurrent-&gt;GetNext())
239:             {
240:                pCurrent-&gt;SetNext(pNode);
241:                return;
242:             }
243: 
244:             // if this goes after this one and before the next
245:             // then insert it here, otherwise get the next
246:             pNext = pCurrent-&gt;GetNext();
247:             Next = pNext-&gt;GetPart()-&gt;GetPartNumber();
248:             if (Next &gt; New)
249:             {
250:                pCurrent-&gt;SetNext(pNode);
251:                pNode-&gt;SetNext(pNext);
252:                return;
253:             }
254:             pCurrent = pNext;
255:          }
256:       }
257:    
258:    
259:    
260:      class PartsCatalog
261:      {
262:      public:
263:         void Insert(Part *);
264:         ULONG Exists(ULONG PartNumber);
265:         Part * Get(int PartNumber);
266:         operator+(const PartsCatalog &amp;);
267:         void ShowAll() { thePartsList.Iterate(Part::Display); }
268:      private:
269:         PartsList thePartsList;
270:      };
271:    
272:      void PartsCatalog::Insert(Part * newPart)
273:      {
274:         ULONG partNumber =  newPart-&gt;GetPartNumber();
275:         ULONG offset;
276:    
277:         if (!thePartsList.Find(offset, partNumber))
278:    
279:            thePartsList.Insert(newPart);
280:         else
281:         {
282:            cout &lt;&lt; partNumber &lt;&lt; &quot; was the &quot;;
283:            switch (offset)
284:            {
285:               case 0:  cout &lt;&lt; &quot;first &quot;; break;
286:               case 1:  cout &lt;&lt; &quot;second &quot;; break;
287:               case 2:  cout &lt;&lt; &quot;third &quot;; break;
288:               default: cout &lt;&lt; offset+1 &lt;&lt; &quot;th &quot;;
289:            }
290:            cout &lt;&lt; &quot;entry. Rejected!\n&quot;;
291:         }
292:      }
293:    
294:      ULONG PartsCatalog::Exists(ULONG PartNumber)
295:      {
296:         ULONG offset;
297:         thePartsList.Find(offset,PartNumber);
298:            return offset;
299:      }
300:    
301:      Part * PartsCatalog::Get(int PartNumber)
302:      {
303:         ULONG offset;
304:         Part * thePart = thePartsList.Find(offset, PartNumber);
305:         return thePart;
306:      }
307:    
308:    
309:      int main()
310:      {
311:         PartsCatalog pc;
312:         Part * pPart = 0;
313:         ULONG PartNumber;
314:         USHORT value;
315:         ULONG choice;
316: 
317:         while (1)
318:         {
319:            cout &lt;&lt; &quot;(0)Quit (1)Car (2)Plane: &quot;;
320:            cin &gt;&gt; choice;
321:    
322:            if (!choice)
323:               break;
324:    
325:            cout &lt;&lt; &quot;New PartNumber?: &quot;;
326:            cin &gt;&gt;  PartNumber;
327:    
328:            if (choice == 1)
329:            {
330:               cout &lt;&lt; &quot;Model Year?: &quot;;
331:               cin &gt;&gt; value;
332:               pPart = new CarPart(value,PartNumber);
333:            }
334:            else
335:            {
336:               cout &lt;&lt; &quot;Engine Number?: &quot;;
337:               cin &gt;&gt; value;
338:               pPart = new AirPlanePart(value,PartNumber);
339:            }
340:            pc.Insert(pPart);
341:         }
342:         pc.ShowAll();
343:        return 0;
<TT>344: }</TT></FONT>
<FONT COLOR="#0066FF">
Output: (0)Quit (1)Car (2)Plane:  1
New PartNumber?: 1234
Model Year?: 94
(0)Quit (1)Car (2)Plane:  1
New PartNumber?: 4434
Model Year?: 93
(0)Quit (1)Car (2)Plane:  1
New PartNumber?: 1234
Model Year?: 94
1234 was the first entry. Rejected!
(0)Quit (1)Car (2)Plane:  1
New PartNumber?: 2345
Model Year?: 93
(0)Quit (1)Car (2)Plane:  0

Part Number: 1234
Model Year: 94

Part Number: 2345
Model Year: 93

Part Number: 4434
Model Year: 93
</FONT></PRE>
<P><FONT COLOR="#000077"><B>Analysis:</B></FONT><B> </B>Listing 15.7 reproduces the
interface to the <TT>Part</TT>, <TT>PartNode</TT>, and <TT>PartList</TT> classes
from Week 2 in Review, but to save room it does not reproduce the implementation
of their methods.</P>
<P>A new class, <TT>PartsCatalog</TT>, is declared on lines 260-270. <TT>PartsCatalog</TT>
has a <TT>PartsList</TT> as its data member, to which it delegates list management.
Another way to say this is that the <TT>PartsCatalog</TT> is implemented in terms
of this <TT>PartsList</TT>.</P>
<P>Note that clients of the <TT>PartsCatalog</TT> do not have access to the <TT>PartsList</TT>
directly. The interface is through the <TT>PartsCatalog</TT>, and as such the behavior
of the <TT>PartsList</TT> is dramatically changed. For example, the <TT>PartsCatalog::Insert()</TT>
method does not allow duplicate entries into the <TT>PartsList</TT>.</P>
<P>The implementation of <TT>PartsCatalog::Insert()</TT> starts on line 272. The
<TT>Part</TT> that is passed in as a parameter is asked for the value of its <TT>itsPartNumber</TT>
member variable. This value is fed to the <TT>PartsList</TT>'s <TT>Find()</TT> method,
and if no match is found the number is inserted; otherwise an informative error message
is printed.</P>
<P>Note that <TT>PartsCatalog</TT> does the actual insert by calling <TT>Insert()</TT>
on its member variable, <TT>pl</TT>, which is a <TT>PartsList</TT>. The mechanics
of the actual insertion and the maintenance of the linked list, as well as searching
and retrieving from the linked list, are maintained in the contained <TT>PartsList</TT>
member of <TT>PartsCatalog</TT>. There is no reason for <TT>PartsCatalog</TT> to
reproduce this code; it can take full advantage of the well-defined interface.</P>
<P>This is the essence of reusability within C++: <TT>PartsCatalog</TT> can reuse
the <TT>PartsList</TT> code, and the designer of <TT>PartsCatalog</TT> is free to
ignore the implementation details of <TT>PartsList</TT>. The interface to <TT>PartsList</TT>
(that is, the class declaration) provides all the information needed by the designer
of the <TT>PartsCatalog</TT> class.
<H3 ALIGN="CENTER"><A NAME="Heading20"></A><FONT COLOR="#000077">Private Inheritance</FONT></H3>
<P>If <TT>PartsCatalog</TT> needed access to the protected members of <TT>LinkedList</TT>
(in this case there are none), or needed to override any of the <TT>LinkedList</TT>
methods, then <TT>PartsCatalog</TT> would be forced to inherit from <TT>PartsList</TT>.</P>
<P>Since a <TT>PartsCatalog</TT> is not a <TT>PartsList</TT> object, and since you
don't want to expose the entire set of functionality of <TT>PartsList</TT> to clients
of <TT>PartsCatalog</TT>, you need to use private inheritance.</P>
<P>The first thing to know about private inheritance is that all of the base member
variables and functions are treated as if they were declared to be private, regardless
of their actual access level in the base. Thus, to any function that is not a member
function of <TT>PartsCatalog</TT>, every function inherited from <TT>PartsList</TT>
is inaccessible. This is critical: private inheritance does not involve inheriting
interface, just implementation.</P>
<P>To clients of the <TT>PartsCatalog</TT> class, the <TT>PartsList</TT> class is
invisible. None of its interface is available: you can't call any of its methods.
You can call <TT>PartsCatalog</TT> methods, however, and they can access all of <TT>LinkedLists</TT>,
because they are derived from <TT>LinkedLists</TT>.</P>
<P>The important thing here is that the <TT>PartsCatalog</TT> isn't a <TT>PartsList</TT>,
as would have been implied by public inheritance. It is implemented in terms of a
<TT>PartsList</TT>, just as would have been the case with containment. The private
inheritance is just a convenience.</P>
<P>Listing 15.6 demonstrates the use of private inheritance by rewriting the <TT>PartsCatalog</TT>
class as privately derived from <TT>PartsList</TT>.


<BLOCKQUOTE>
	<P>
<HR>
<FONT COLOR="#000077"><B>NOTE:</B></FONT><B> </B>To compile this program, replace
	lines 260-344 of Listing 15.5 with Listing 15.6 and recompile. 
<HR>


</BLOCKQUOTE>

<P><A NAME="Heading21"></A><FONT SIZE="4" COLOR="#000077"><B>Listing 15.6. Private
inheritance.</B></FONT>
<PRE><FONT COLOR="#0066FF">1:  //listing 15.6 demonstrates private inheritance
2:
3:  //rewrites PartsCatalog from listing 15.5
4:
5:  //see attached notes on compiling
6:
7:     class PartsCatalog : private PartsList
8:     {
9:     public:
10:       void Insert(Part *);
11:       ULONG Exists(ULONG PartNumber);
12:       Part * Get(int PartNumber);
13:       operator+(const PartsCatalog &amp;);
14:       void ShowAll() { Iterate(Part::Display); }
15:    private:
16:    };
17:
18:    void PartsCatalog::Insert(Part * newPart)
19:    {
20:       ULONG partNumber =  newPart-&gt;GetPartNumber();
21:       ULONG offset;
22:
23:       if (!Find(offset, partNumber))
24:          PartsList::Insert(newPart);
25:       else
26:       {
27:          cout &lt;&lt; partNumber &lt;&lt; &quot; was the &quot;;
28:          switch (offset)
29:          {
30:             case 0:  cout &lt;&lt; &quot;first &quot;; break;
31:             case 1:  cout &lt;&lt; &quot;second &quot;; break;
32:             case 2:  cout &lt;&lt; &quot;third &quot;; break;
33:             default: cout &lt;&lt; offset+1 &lt;&lt; &quot;th &quot;;
34:          }
35:          cout &lt;&lt; &quot;entry. Rejected!\n&quot;;
36:       }
37:    }
38:
39:    ULONG PartsCatalog::Exists(ULONG PartNumber)
40:    {
41:       ULONG offset;
42:       Find(offset,PartNumber);
43:       return offset;
44:    }
45:
46:    Part * PartsCatalog::Get(int PartNumber)
47:    {
48:       ULONG offset;
49:       return (Find(offset, PartNumber));
50:
51:    }
52:
53:    int main()
54:    {
55:       PartsCatalog pc;
56:       Part * pPart = 0;
57:       ULONG PartNumber;
58:       USHORT value;
59:       ULONG choice;
60:
61:       while (1)
62:       {
63:          cout &lt;&lt; &quot;(0)Quit (1)Car (2)Plane: &quot;;
64:          cin &gt;&gt; choice;
65:
66:          if (!choice)
67:             break;
68:
69:          cout &lt;&lt; &quot;New PartNumber?: &quot;;
70:          cin &gt;&gt;  PartNumber;
71:
72:          if (choice == 1)
73:          {
74:             cout &lt;&lt; &quot;Model Year?: &quot;;
75:             cin &gt;&gt; value;
76:             pPart = new CarPart(value,PartNumber);
77:          }
78:          else
79:          {
80:             cout &lt;&lt; &quot;Engine Number?: &quot;;
81:             cin &gt;&gt; value;
82:             pPart = new AirPlanePart(value,PartNumber);
83:          }
84:          pc.Insert(pPart);
85:       }
86:       pc.ShowAll();
87:     return 0;
<TT>88: }</TT></FONT>
<FONT COLOR="#0066FF">
Output: (0)Quit (1)Car (2)Plane:  1
New PartNumber?: 1234
Model Year?: 94
(0)Quit (1)Car (2)Plane:  1
New PartNumber?: 4434
Model Year?: 93
(0)Quit (1)Car (2)Plane:  1
New PartNumber?: 1234
Model Year?: 94
1234 was the first entry. Rejected!
(0)Quit (1)Car (2)Plane:  1
New PartNumber?: 2345
Model Year?: 93
(0)Quit (1)Car (2)Plane:  0

Part Number: 1234
Model Year: 94

Part Number: 2345
Model Year: 93

Part Number: 4434
Model Year: 93
</FONT></PRE>
<P><FONT COLOR="#000077"><B>Analysis:</B></FONT><B> </B>Listing 15.6 shows only the
changed interface to <TT>PartsCatalog</TT> and the rewritten driver program. The
interfaces to the other classes are unchanged from Listing 15.5.</P>
<P>On line 7 of Listing 15.6, <TT>PartsCatalog</TT> is declared to derive privately
from <TT>PartsList</TT>. The interface to <TT>PartsCatalog</TT> doesn't change from
Listing 15.5, though of course it no longer needs an object of type <TT>PartsList</TT>
as member data.</P>
<P>The <TT>PartsCatalog</TT> <TT>ShowAll()</TT> function calls <TT>PartsList</TT>
<TT>Iterate()</TT> with the appropriate pointer to member function of class <TT>Part</TT>.
<TT>ShowAll()</TT> acts as a public interface to <TT>Iterate()</TT>, providing the
correct information but preventing client classes from calling <TT>Iterate()</TT>
dir-ectly. Although <TT>PartsList</TT> might allow other functions to be passed to
<TT>Iterate()</TT>, <TT>PartsCatalog</TT> does not.</P>
<P>The <TT>Insert()</TT> function has changed as well. Note, on line 23, that <TT>Find()</TT>
is now called directly, because it is inherited from the base class. The call on
line 24 to <TT>Insert()</TT> must be fully qualified, of course, or it would endlessly
recurse into itself.</P>
<P>In short, when methods of <TT>PartsCatalog</TT> want to call <TT>PartsList</TT>
methods, they may do so directly. The only exception is when <TT>PartsCatalog</TT>
has overridden the method and the <TT>PartsList</TT> version is needed, in which
case the function name must be qualified fully.</P>
<P>Private inheritance allows the <TT>PartsCatalog</TT> to inherit what it can use,
but still provide mediated access to <TT>Insert</TT> and other methods to which client
classes should not have direct access.


<BLOCKQUOTE>
	<P>
<HR>
<B>DO </B>inherit publicly when the derived object is a kind of the base class. <B>DO</B>
	use containment when you want to delegate functionality to another class, but you
	don't need access to its protected members.<B> DO</B> use private inheritance when
	you need to implement one class in terms of another, and you need access to the base
	class's protected members. <B>DON'T </B>use private inheritance when you need to
	use more than one of the base class. You must use containment. For example, if <TT>PartsCatalog</TT>
	needed two <TT>PartsLists</TT>, you could not have used private inheritance. <B>DON'T</B>
	use public inheritance when members of the base class should not be available to
	clients of the derived class. 
<HR>


</BLOCKQUOTE>

<H3 ALIGN="CENTER"><A NAME="Heading24"></A><FONT COLOR="#000077">Friend Classes</FONT></H3>
<P>Sometimes you will create classes together, as a set. For example, <TT>PartNode</TT>
and <TT>PartsList</TT> were tightly coupled, and it would have been convenient if
<TT>PartsList</TT> could have read <TT>PartNode</TT>'s <TT>Part</TT> pointer, <TT>itsPart</TT>,
directly.</P>
<P>You wouldn't want to make <TT>itsPart</TT> public, or even protected, because
this is an implementation detail of <TT>PartNode</TT> and you want to keep it private.
You do want to expose it to <TT>PartsList</TT>, however.</P>
<P>If you want to expose your private member data or functions to another class,
you must declare that class to be a friend. This extends the interface of your class
to include the friend class.</P>
<P>Once <TT>PartsNode</TT> declares <TT>PartsList</TT> to be a friend, all of <TT>PartsNode</TT>'s
member data and functions are public as far as <TT>PartsList</TT> is concerned.</P>
<P>It is important to note that friendship cannot be transferred. Just because you
are my friend and Joe is your friend doesn't mean Joe is my friend. Friendship is
not inherited either. Again, just because you are my friend and I'm willing to share
my secrets with you doesn't mean I'm willing to share my secrets with your children.</P>
<P>Finally, friendship is not commutative. Assigning <TT>Class One</TT> to be a friend
of <TT>Class Two</TT> does not make <TT>Class Two</TT> a friend of <TT>Class One</TT>.
Just because you are willing to tell me your secrets doesn't mean I am willing to
tell you mine.</P>
<P>Listing 15.7 illustrates friendship by rewriting the example from Listing 15.6,
making <TT>PartsList</TT> a friend of <TT>PartNode</TT>. Note that this does not
make <TT>PartNode</TT> a friend of <TT>PartsList</TT>.</P>

<P><A NAME="Heading25"></A><FONT SIZE="4" COLOR="#000077"><B>Listing 15.7. Friend
class illustrated.</B></FONT>
<PRE><FONT COLOR="#0066FF">0:      #include &lt;iostream.h&gt;
1:    
2:      typedef unsigned long ULONG;
3:      typedef unsigned short USHORT;
4:    
5:    
6:      // **************** Part ************
7:    
8:      // Abstract base class of parts
9:      class Part
10:       {
11:       public:
12:          Part():itsPartNumber(1) {}
13:          Part(ULONG PartNumber):
14:              itsPartNumber(PartNumber){}
15:          virtual ~Part(){}
16:          ULONG GetPartNumber() const 
17:              { return itsPartNumber; }
18:          virtual void Display() const =0; 
19:       private:
20:          ULONG itsPartNumber;
21:       };
22:     
23:       // implementation of pure virtual function so that
24:       // derived classes can chain up
25:       void Part::Display() const
26:       {
27:           cout &lt;&lt; &quot;\nPart Number: &quot;;
28:           cout &lt;&lt; itsPartNumber &lt;&lt; endl;
29:       }
30:     
31:       // **************** Car Part ************
32:     
33:       class CarPart : public Part
34:       {
35:       public:
36:          CarPart():itsModelYear(94){}
37:          CarPart(USHORT year, ULONG partNumber);
38:          virtual void Display() const 
39:          { 
40:              Part::Display(); 
41:              cout &lt;&lt; &quot;Model Year: &quot;;
42:              cout &lt;&lt; itsModelYear &lt;&lt; endl;  
43:          }
44:       private:
45:          USHORT itsModelYear;
46:       };
47:     
48:       CarPart::CarPart(USHORT year, ULONG partNumber):
49:          itsModelYear(year),
50:          Part(partNumber)
51:       {}
52:     
53: 
54:       // **************** AirPlane Part ************
55:     
56:       class AirPlanePart : public Part
57:       {
58:       public:
59:          AirPlanePart():itsEngineNumber(1){};
60:          AirPlanePart
61:              (USHORT EngineNumber, ULONG PartNumber);
62:          virtual void Display() const
63:          { 
64:              Part::Display(); 
65:              cout &lt;&lt; &quot;Engine No.: &quot;;
66:              cout &lt;&lt; itsEngineNumber &lt;&lt; endl;  
67:          }
68:       private:
69:          USHORT itsEngineNumber;
70:       };
71:     
72:       AirPlanePart::AirPlanePart
73:           (USHORT EngineNumber, ULONG PartNumber):
74:          itsEngineNumber(EngineNumber),
75:          Part(PartNumber)
76:       {}
77:     
78:     // **************** Part Node ************
79:     class PartNode
80:     {
81:     public:
82:        friend class PartsList;
83:        PartNode (Part*);
84:        ~PartNode();
85:        void SetNext(PartNode * node) 
86:            { itsNext = node; }
87:        PartNode * GetNext() const;
88:        Part * GetPart() const;
89:     private:
90:        Part *itsPart;
91:        PartNode * itsNext;
92:     };
93:    
94:       
95:          PartNode::PartNode(Part* pPart):
96:          itsPart(pPart),
97:          itsNext(0)
98:          {}
99:       
100:          PartNode::~PartNode()
101:          {
102:              delete itsPart;
103:              itsPart = 0;
104:              delete itsNext;
105:              itsNext = 0;
106:           }
107:        
108:           // Returns NULL if no next PartNode
109:           PartNode * PartNode::GetNext() const
110:           {
111:                 return itsNext;
112:           }
113:        
114:           Part * PartNode::GetPart() const
115:           {
116:              if (itsPart)
117:                 return itsPart;
118:              else
119:                 return NULL; //error
120:           }
121:        
122:    
123:     // **************** Part List ************
124:     class PartsList
125:     {
126:     public:
127:        PartsList();
128:        ~PartsList();
129:        // needs copy constructor and operator equals!
130:        void     Iterate(void (Part::*f)()const) const;
131:        Part*    Find(ULONG &amp; position, ULONG PartNumber) const;
132:        Part*    GetFirst() const;
133:        void       Insert(Part *);
134:        Part*    operator[](ULONG) const;
135:        ULONG    GetCount() const { return itsCount; }
136:        static    PartsList&amp; GetGlobalPartsList() 
137:                { 
138:                    return  GlobalPartsList;
139:                }
140:     private:
141:        PartNode * pHead;
142:        ULONG itsCount;
143:        static PartsList GlobalPartsList;
144:     };
145:    
146:     PartsList PartsList::GlobalPartsList;
147:    
148:     // Implementations for Lists...
149:    
150:     PartsList::PartsList():
151:        pHead(0),
152:        itsCount(0)
153:        {}
154:    
155:     PartsList::~PartsList()
156:     {
157:        delete pHead;
158:     }
159:    
160:     Part*   PartsList::GetFirst() const
161:     {
162:        if (pHead)
163:           return pHead-&gt;itsPart;
164:        else
165:           return NULL;  // error catch here
166:     }
167:    
168:     Part * PartsList::operator[](ULONG offSet) const
169:     {
170:        PartNode* pNode = pHead;
171:    
172:        if (!pHead)
173:           return NULL; // error catch here
174:    
175:        if (offSet &gt; itsCount)
176:           return NULL; // error
177:    
178:        for (ULONG i=0;i&lt;offSet; i++)
179:           pNode = pNode-&gt;itsNext;
180:    
181:       return   pNode-&gt;itsPart;
182:     }
183:    
184:    Part* PartsList::Find(ULONG &amp; position, ULONG PartNumber) const
185:     {
186:        PartNode * pNode = 0;
187:        for (pNode = pHead, position = 0;
188:              pNode!=NULL;
189:              pNode = pNode-&gt;itsNext, position++)
190:        {
191:           if (pNode-&gt;itsPart-&gt;GetPartNumber() == PartNumber)
192:              break;
193:        }
194:        if (pNode == NULL)
195:           return NULL;
196:        else
197:           return pNode-&gt;itsPart;
198:     }
199:    
200:     void PartsList::Iterate(void (Part::*func)()const) const
201:     {
202:        if (!pHead)
203:           return;
204:        PartNode* pNode = pHead;
205:        do
206:           (pNode-&gt;itsPart-&gt;*func)();
207:        while (pNode = pNode-&gt;itsNext);
208:     }
209:    
210:     void PartsList::Insert(Part* pPart)
211:     {
212:        PartNode * pNode = new PartNode(pPart);
213:        PartNode * pCurrent = pHead;
214:        PartNode * pNext = 0;
215:    
216:        ULONG New =  pPart-&gt;GetPartNumber();
217:        ULONG Next = 0;
218:        itsCount++;
219:    
220:        if (!pHead)
221:        {
222:           pHead = pNode;
223:           return;
224:        }
225:    
226:        // if this one is smaller than head
227:        // this one is the new head
228:        if (pHead-&gt;itsPart-&gt;GetPartNumber() &gt; New)
229:        {
230:           pNode-&gt;itsNext = pHead;
231:           pHead = pNode;
232:           return;
233:        }
234:    
235:        for (;;)
236:        {
237:           // if there is no next, append this new one
238:           if (!pCurrent-&gt;itsNext)
239:           {
240:              pCurrent-&gt;itsNext = pNode;
241:              return;
242:           }
243: 
244:           // if this goes after this one and before the next
245:           // then insert it here, otherwise get the next
246:           pNext = pCurrent-&gt;itsNext;
247:           Next = pNext-&gt;itsPart-&gt;GetPartNumber();
248:           if (Next &gt; New)
249:           {
250:              pCurrent-&gt;itsNext = pNode;
251:              pNode-&gt;itsNext = pNext;
252:              return;
253:           }
254:           pCurrent = pNext;
255:        }
256:     }
257:    
258:     class PartsCatalog : private PartsList
259:     {
260:     public:
261:        void Insert(Part *);
262:        ULONG Exists(ULONG PartNumber);
263:        Part * Get(int PartNumber);
264:        operator+(const PartsCatalog &amp;);
265:        void ShowAll() { Iterate(Part::Display); }
266:     private:
267:     };
268:    
269:     void PartsCatalog::Insert(Part * newPart)
270:     {
271:        ULONG partNumber =  newPart-&gt;GetPartNumber();
272:        ULONG offset;
273:    
274:        if (!Find(offset, partNumber))
275:           PartsList::Insert(newPart);
276:        else
277:        {
278:           cout &lt;&lt; partNumber &lt;&lt; &quot; was the &quot;;
279:           switch (offset)
280:           {
281:              case 0:  cout &lt;&lt; &quot;first &quot;; break;
282:              case 1:  cout &lt;&lt; &quot;second &quot;; break;
283:              case 2:  cout &lt;&lt; &quot;third &quot;; break;
284:              default: cout &lt;&lt; offset+1 &lt;&lt; &quot;th &quot;;
285:           }
286:           cout &lt;&lt; &quot;entry. Rejected!\n&quot;;
287:        }
288:     }
289:    
290:     ULONG PartsCatalog::Exists(ULONG PartNumber)
291:     {
292:        ULONG offset;
293:        Find(offset,PartNumber);
294:        return offset;
295:     }
296:    
297:     Part * PartsCatalog::Get(int PartNumber)
298:     {
299:        ULONG offset;
300:        return (Find(offset, PartNumber));
301:    
302:     }
303:    
304:     int main()
305:     {
306:        PartsCatalog pc;
307:        Part * pPart = 0;
308:        ULONG PartNumber;
309:        USHORT value;
310:        ULONG choice;
311:    
312:        while (1)
313:        {
314:           cout &lt;&lt; &quot;(0)Quit (1)Car (2)Plane: &quot;;
315:           cin &gt;&gt; choice;
316:    
317:           if (!choice)
318:              break;
319:    
320:           cout &lt;&lt; &quot;New PartNumber?: &quot;;
321:           cin &gt;&gt;  PartNumber;
322:    
323:           if (choice == 1)
324:           {
325:              cout &lt;&lt; &quot;Model Year?: &quot;;
326:              cin &gt;&gt; value;
327:              pPart = new CarPart(value,PartNumber);
328:           }
329:           else
330:           {
331:              cout &lt;&lt; &quot;Engine Number?: &quot;;
332:              cin &gt;&gt; value;
333:              pPart = new AirPlanePart(value,PartNumber);
334:           }
335:           pc.Insert(pPart);
336:        }
337:        pc.ShowAll();
338:       return 0;
<TT>339: }</TT></FONT>
<FONT COLOR="#0066FF">
Output: (0)Quit (1)Car (2)Plane:  1
New PartNumber?: 1234
Model Year?: 94
(0)Quit (1)Car (2)Plane:  1
New PartNumber?: 4434
Model Year?: 93
(0)Quit (1)Car (2)Plane:  1
New PartNumber?: 1234
Model Year?: 94
1234 was the first entry. Rejected!
(0)Quit (1)Car (2)Plane:  1
New PartNumber?: 2345
Model Year?: 93
(0)Quit (1)Car (2)Plane:  0

Part Number: 1234
Model Year: 94

Part Number: 2345
Model Year: 93

Part Number: 4434
Model Year: 93
</FONT></PRE>
<P><FONT COLOR="#000077"><B>Analysis:</B></FONT><B> </B>On line 82, the class <TT>PartsList</TT>
is declared to be a friend to the <TT>PartNode</TT> class. Because <TT>PartsList</TT>
has not yet been declared, the compiler would complain that this type is not known.</P>
<P>This listing places the friend declaration in the public section, but this is
not required; it can be put anywhere in the class declaration without changing the
meaning of the statement. Because of this statement, all the private member data
and functions are available to any member function of class <TT>PartsList</TT>.</P>
<P>On line 160, the implementation of the member function <TT>GetFirst()</TT> reflects
this change. Rather than returning <TT>pHead-&gt;GetPart</TT>, this function can
now return the otherwise private member data by writing <TT>pHead-&gt;itsPart</TT>.
Similarly, the <TT>Insert()</TT> function can now write <TT>pNode-&gt;itsNext = pHead</TT>,
rather than writing <TT>pNode-&gt;SetNext(pHead)</TT>.</P>
<P>Admittedly these are trivial changes, and there is not a good enough reason to
make <TT>PartsList</TT> a friend of <TT>PartNode</TT>, but they do serve to illustrate
how the keyword <TT>friend</TT> works.</P>
<P>Declarations of friend classes should be used with extreme caution. If two classes
are inextricably entwined, and one must frequently access data in the other, there
may be good reason to use this declaration. But use it sparingly; it is often just
as easy to use the public accessor methods, and doing so allows you to change one
class without having to recompile the other.


<BLOCKQUOTE>
	<P>
<HR>
<FONT COLOR="#000077"><B>NOTE:</B></FONT><B> </B>You will often hear novice C++ programmers
	complain that friend declarations &quot;undermine&quot; the encapsulation so important
	to object-oriented programming. This is, frankly, errant nonsense. The friend declaration
	makes the declared friend part of the class interface, and is no more an undermining
	of encapsulation than is public derivation. 
<HR>


</BLOCKQUOTE>

<H3 ALIGN="CENTER"><A NAME="Heading27"></A><FONT COLOR="#000077">Friend Class</FONT></H3>
<P>Declare one class to be a friend of another by putting the word <TT>friend</TT>
into the class granting the access rights. That is, I can declare you to be my friend,
but you can't declare yourself to be my friend. Example:</P>
<PRE><FONT COLOR="#0066FF">class PartNode{
public:
friend class PartList;  // declares PartList to be a friend of PartNode
};
</FONT></PRE>
<H3 ALIGN="CENTER"><A NAME="Heading28"></A><FONT COLOR="#000077">Friend Functions</FONT></H3>
<P>At times you will want to grant this level of access not to an entire class, but
only to one or two functions of that class. You can do this by declaring the member
functions of the other class to be friends, rather than declaring the entire class
to be a friend. In fact, you can declare any function, whether or not it is a member
function of another class, to be a friend function.
<H3 ALIGN="CENTER"><A NAME="Heading29"></A><FONT COLOR="#000077">Friend Functions
and Operator Overloading</FONT></H3>
<P>Listing 15.1 provided a <TT>String</TT> class that overrode the <TT>operator+</TT>.
It also provided a constructor that took a constant character pointer, so that string
objects could be created from C-style strings. This allowed you to create a string
and add to it with a C-style string.


<BLOCKQUOTE>
	<P>
<HR>
<FONT COLOR="#000077"><B>NOTE:</B></FONT><B> </B>C-style strings are null-terminated
	character arrays, such as <TT>char myString[] = &quot;Hello World.&quot;</TT> 
<HR>


</BLOCKQUOTE>

<P>What you could not do, however, was create a C-style string (a character string)
and add to it using a string object, as shown in this example:</P>
<PRE><FONT COLOR="#0066FF">char cString[] = {&quot;Hello&quot;};
String sString(&quot; World&quot;);
String sStringTwo = cString + sString;  //error!
</FONT></PRE>
<P>C-style strings don't have an overloaded <TT>operator+</TT>. As discussed on Day
10, &quot;Advanced Functions,&quot; when you say <TT>cString + sString;</TT> what
you are really calling is <TT>cString.operator+(sString)</TT>. Since you can't call
<TT>operator+()</TT> on a C-style string, this causes a compile-time error.</P>
<P>You can solve this problem by declaring a friend function in <TT>String</TT>,
which overloads <TT>operator+</TT> but takes two string objects. The C-style string
will be converted to a string object by the appropriate constructor, and then <TT>operator+</TT>
will be called using the two string objects.


<BLOCKQUOTE>
	<P>
<HR>
<FONT COLOR="#000077"><B>NOTE:</B></FONT><B> </B>To compile this listing, copy lines
	33-123 from Listing 15.1 after line 33 of Listing 15.8. 
<HR>


</BLOCKQUOTE>

<P><A NAME="Heading30"></A><FONT SIZE="4" COLOR="#000077"><B>Listing 15.8. Friendly
operator+.</B></FONT>
<PRE><FONT COLOR="#0066FF">1:     //Listing 15.8 - friendly operators
2:
3:     #include &lt;iostream.h&gt;
4:     #include &lt;string.h&gt;
5:
6:     // Rudimentary string class
7:     class String
8:     {
9:        public:
10:          // constructors
11:          String();
12:          String(const char *const);
13:          String(const String &amp;);
14:          ~String();
15:
16:          // overloaded operators
17:          char &amp; operator[](int offset);
18:          char operator[](int offset) const;
19:          String operator+(const String&amp;);
20:          friend String operator+(const String&amp;, const String&amp;);
21:          void operator+=(const String&amp;);
22:          String &amp; operator= (const String &amp;);
23:
24:          // General accessors
25:          int GetLen()const { return itsLen; }
26:          const char * GetString() const { return itsString; }
27:
28:       private:
29:          String (int);         // private constructor
30:          char * itsString;
31:          unsigned short itsLen;
32:    };
33:
34:    // creates a new string by adding current
35:    // string to rhs
36:    String String::operator+(const String&amp; rhs)
37:    {
38:       int  totalLen = itsLen + rhs.GetLen();
39:       String temp(totalLen);
40:       for (int i = 0; i&lt;itsLen; i++)
41:          temp[i] = itsString[i];
42:       for (int j = 0; j&lt;rhs.GetLen(); j++, i++)
43:          temp[i] = rhs[j];
44:       temp[totalLen]='\0';
45:       return temp;
46:    }
47:
48:    // creates a new string by adding
49:    // one string to another
50:    String operator+(const String&amp; lhs, const String&amp; rhs)
51:    {
52:       int  totalLen = lhs.GetLen() + rhs.GetLen();
53:       String temp(totalLen);
54:       for (int i = 0; i&lt;lhs.GetLen(); i++)
55:          temp[i] = lhs[i];
56:       for (int j = 0; j&lt;rhs.GetLen(); j++, i++)
57:          temp[i] = rhs[j];
58:       temp[totalLen]='\0';
59:       return temp;
60:    }
61:
62:    int main()
63:    {
64:       String s1(&quot;String One &quot;);
65:       String s2(&quot;String Two &quot;);
66:       char *c1 = { &quot;C-String One &quot; } ;
67:       String s3;
68:       String s4;
69:       String s5;
70:
71:       cout &lt;&lt; &quot;s1: &quot; &lt;&lt; s1.GetString() &lt;&lt; endl;
72:       cout &lt;&lt; &quot;s2: &quot; &lt;&lt; s2.GetString() &lt;&lt; endl;
73:       cout &lt;&lt; &quot;c1: &quot; &lt;&lt; c1 &lt;&lt; endl;
74:       s3 = s1 + s2;
75:       cout &lt;&lt; &quot;s3: &quot; &lt;&lt; s3.GetString() &lt;&lt; endl;
76:       s4 = s1 + c1;
77:       cout &lt;&lt; &quot;s4: &quot; &lt;&lt; s4.GetString() &lt;&lt; endl;
78:       s5 = c1 + s1;
79:       cout &lt;&lt; &quot;s5: &quot; &lt;&lt; s5.GetString() &lt;&lt; endl;
80:     return 0;
<TT>81: }</TT></FONT>
<FONT COLOR="#0066FF">
Output: s1: String One
s2: String Two
c1: C-String One
s3: String One String Two
s4: String One C-String One
s5: C-String One String Two
</FONT></PRE>
<P><FONT COLOR="#000077"><B>Analysis:</B></FONT><B> </B>The implementation of all
of the string methods except <TT>operator+</TT> are unchanged from Listing 15.1,
and so are left out of this listing. On line 20, a new <TT>operator+</TT> is overloaded
to take two constant string references and to return a string, and this function
is declared to be a friend.</P>
<P>Note that this <TT>operator+</TT> is not a member function of this or any other
class. It is declared within the declaration of the <TT>String</TT> class only so
that it can be made a friend, but because it is declared no other function prototype
is needed.</P>
<P>The implementation of this <TT>operator+</TT> is on lines 50-60. Note that it
is similar to the earlier <TT>operator+</TT>, except that it takes two strings and
accesses them both through their public accessor methods.</P>
<P>The driver program demonstrates the use of this function on line 78, where <TT>operator+</TT>
is now called on a C-style string!
<H3 ALIGN="CENTER"><A NAME="Heading31"></A><FONT COLOR="#000077">Friend Functions</FONT></H3>
<P>Declare a function to be a friend by using the keyword <TT>friend</TT> and then
the full specification of the function. Declaring a function to be a friend does
not give the friend function access to your <TT>this</TT> pointer, but it does provide
full access to all private and protected member data and functions. Example</P>
<PRE><FONT COLOR="#0066FF">class PartNode
{
// make another class's member function a          _friend
friend void PartsList::Insert(Part *);  
// make a global function a friend };
friend int SomeFunction();              
</FONT></PRE>
<H3 ALIGN="CENTER"><A NAME="Heading32"></A><FONT COLOR="#000077">Overloading the
Insertion Operator</FONT></H3>
<P>You are finally ready to give your <TT>String</TT> class the ability to use <TT>cout</TT>
like any other type. Until now, when you've wanted to print a string, you've been
forced to write the following:</P>
<PRE><FONT COLOR="#0066FF">cout &lt;&lt; theString.GetString();
</FONT></PRE>
<P>What you would like to do is write this:</P>
<PRE><FONT COLOR="#0066FF">cout &lt;&lt; theString;
</FONT></PRE>
<P>To accomplish this, you must override <TT>operator&lt;&lt;()</TT>. Day 16, &quot;Streams,&quot;
presents the ins and outs (<TT>cins</TT> and <TT>couts</TT>?) of working with <TT>iostreams</TT>;
for now Listing 15.9 illustrates how <TT>operator&lt;&lt;</TT> can be overloaded
using a friend function.


<BLOCKQUOTE>
	<P>
<HR>
<FONT COLOR="#000077"><B>NOTE:</B></FONT><B> </B>To compile this listing, copy lines
	33-153 from Listing 15.1 after line 31 of Listing 15.9. 
<HR>


</BLOCKQUOTE>

<P><A NAME="Heading33"></A><FONT SIZE="4" COLOR="#000077"><B>Listing 15.9. Overloading
operator&lt;&lt;().</B></FONT>
<PRE><FONT COLOR="#0066FF">1:     #include &lt;iostream.h&gt;
2:     #include &lt;string.h&gt;
3:
4:     class String
5:     {
6:        public:
7:           // constructors
8:           String();
9:            String(const char *const);
10:           String(const String &amp;);
11:          ~String();
12:
13:          // overloaded operators
14:          char &amp; operator[](int offset);
15:          char operator[](int offset) const;
16:          String operator+(const String&amp;);
17:          void operator+=(const String&amp;);
18:          String &amp; operator= (const String &amp;);
19:          friend ostream&amp; operator&lt;&lt;
20:             ( ostream&amp; theStream,String&amp; theString);
21:          // General accessors
22:          int GetLen()const { return itsLen; }
23:          const char * GetString() const { return itsString; }
24:          // static int ConstructorCount;
25:       private:
26:          String (int);         // private constructor
27:          char * itsString;
28:          unsigned short itsLen;
29:    };
30:
31:    ostream&amp; operator&lt;&lt;
32:        ( ostream&amp; theStream,String&amp; theString)
33:    {
34:        theStream &lt;&lt; theString.GetString();
35:        return theStream;
36:    }
37:    int main()
38:    {
39:       String theString(&quot;Hello world.&quot;);
40:       cout &lt;&lt; theString;
41:     return 0;
<TT>42: }</TT>
Output: Hello world.
</FONT></PRE>
<P><FONT COLOR="#000077"><B>Analysis:</B></FONT><B> </B>To save space, the implementation
of all of <TT>String</TT>'s methods is left out, as they are unchanged from the previous
examples.</P>
<P>On line 19, <TT>operator&lt;&lt;</TT> is declared to be a friend function that
takes an <TT>ostream</TT> reference and a <TT>String</TT> reference and then returns
an <TT>ostream</TT> reference. Note that this is not a member function of <TT>String</TT>.
It returns a reference to an <TT>ostream</TT> so that you can concatenate calls to
<TT>operator&lt;&lt;</TT>, such as this:</P>
<PRE><FONT COLOR="#0066FF">cout &lt;&lt; &quot;myAge: &quot; &lt;&lt; itsAge &lt;&lt; &quot; years.&quot;;
</FONT></PRE>
<P>The implementation of this friend function is on lines 32-35. All this really
does is hide the implementation details of feeding the string to the <TT>ostream</TT>,
and that is just as it should be. You'll see more about overloading this operator
and <TT>operator&gt;&gt;</TT> on Day 16.
<H3 ALIGN="CENTER"><A NAME="Heading34"></A><FONT COLOR="#000077">Summary</FONT></H3>
<P>Today you saw how to delegate functionality to a contained object. You also saw
how to implement one class in terms of another by using either containment or private
inheritance. Containment is restricted in that the new class does not have access
to the protected members of the contained class, and it cannot override the member
functions of the contained object. Containment is simpler to use than private inheritance,
and should be used when possible.</P>
<P>You also saw how to declare both friend functions and friend classes. Using a
friend function, you saw how to overload the extraction operator, to allow your new
classes to use <TT>cout</TT> just as the built-in classes do.</P>
<P>Remember that public inheritance expresses is-a, containment expresses has-a,
and private inheritance expresses implemented in terms of. The relationship delegates
to can be expressed using either containment or private inheritance, though containment
is more common.
<H3 ALIGN="CENTER"><A NAME="Heading35"></A><FONT COLOR="#000077">Q&amp;A</FONT></H3>

<DL>
	<DD><B>Q. Why is it so important to distinguish between is-a, has-a, and implemented
	in terms of?<BR>
	</B><BR>
	<B>A.</B> The point of C++ is to implement well-designed, object-oriented programs.
	Keeping these relationships straight helps to ensure that your design corresponds
	to the reality of what you are modeling. Furthermore, a well-understood design will
	more likely be reflected in well-designed code.<BR>
	<BR>
	<B>Q. Why is containment preferred over private inheritance?<BR>
	</B><BR>
	<B>A.</B> The challenge in modern programming is to cope with complexity. The more
	you can use objects as black boxes, the fewer details you have to worry about and
	the more complexity you can manage. Contained classes hide their details; private
	inheritance exposes the implementation details.<BR>
	<BR>
	<B>Q. Why not make all classes friends of all the classes they use?<BR>
	</B><BR>
	<B>A.</B> Making one class a friend of another exposes the implementation details
	and reduces encapsulation. The ideal is to keep as many of the details of each class
	hidden from all other classes as possible.<BR>
	<B><BR>
	Q. If a function is overloaded, do you need to declare each form of the function
	to be a friend?<BR>
	</B><BR>
	<B>A.</B> Yes, if you overload a function and declare it to be a friend of another
	class, you must declare <TT>friend</TT> for each form that you wish to grant this
	access to.
</DL>

<H3 ALIGN="CENTER"><A NAME="Heading36"></A><FONT COLOR="#000077">Workshop</FONT></H3>
<P>The Workshop contains quiz questions to help solidify your understanding of the
material covered and exercises to provide you with experience in using what you've
learned. Try to answer the quiz and exercise questions before checking the answers
in Appendix D, and make sure you understand the answers before going to the next
chapter.
<H4 ALIGN="CENTER"><A NAME="Heading37"></A><FONT COLOR="#000077">Quiz</FONT></H4>

<DL>
	<DD><B>1.</B> How do you establish an is-a relationship?<BR>
	<B><BR>
	2.</B> How do you establish a has-a relationship?<BR>
	<B><BR>
	3.</B> What is the difference between containment and delegation?<BR>
	<B><BR>
	4.</B> What is the difference between delegation and implemented in terms of?<BR>
	<B><BR>
	5.</B> What is a friend function?<BR>
	<B><BR>
	6.</B> What is a friend class?<BR>
	<B><BR>
	7.</B> If <TT>Dog</TT> is a friend of <TT>Boy</TT>, is <TT>Boy</TT> a friend of <TT>Dog</TT>?<BR>
	<B><BR>
	8.</B> If <TT>Dog</TT> is a friend of <TT>Boy</TT>, and <TT>Terrier</TT> derives
	from <TT>Dog</TT>, is <TT>Terrier</TT> a friend of <TT>Boy</TT>?<BR>
	<B><BR>
	9.</B> If <TT>Dog</TT> is a friend of <TT>Boy</TT> and <TT>Boy</TT> is a friend of
	<TT>House</TT>, is <TT>Dog</TT> a friend of <TT>House</TT>?<BR>
	<B><BR>
	10</B>. Where must the declaration of a friend function appear?
</DL>

<H4 ALIGN="CENTER"><A NAME="Heading38"></A><FONT COLOR="#000077">Exercises</FONT></H4>

<DL>
	<DD><B>1.</B> Show the declaration of a class, <TT>Animal</TT>, that contains a datamember
	that is a string object.<BR>
	<B><BR>
	2.</B> Show the declaration of a class, <TT>BoundedArray</TT>, that is an array.<BR>
	<B><BR>
	3.</B> Show the declaration of a class, <TT>Set</TT>, that is declared in terms of
	an array.<BR>
	<B><BR>
	4.</B> Modify Listing 15.1 to provide the <TT>String</TT> class with an <TT>extraction
	operator (&gt;&gt;)</TT>.<BR>
	<B><BR>
	5.</B> BUG BUSTERS: What is wrong with this program?
</DL>

<PRE><FONT COLOR="#0066FF">
1:     #include &lt;iostream.h&gt;
2:
3:     class Animal;
4:
5:     void setValue(Animal&amp; , int);
6:
7:
8:     class Animal
9:     {
10:    public:
11:       int GetWeight()const { return itsWeight; }
12:       int GetAge() const { return itsAge; }
13:    private:
14:       int itsWeight;
15:       int itsAge;
16:    };
17:
18:    void setValue(Animal&amp; theAnimal, int theWeight)
19:    {
20:       friend class Animal;
21:       theAnimal.itsWeight = theWeight;
22:    }
23:
24:    int main()
25:    {
26:       Animal peppy;
27:       setValue(peppy,5);28:    }
</FONT></PRE>

<DL>
	<DD><B>6.</B> Fix the listing in Exercise 5 so it compiles.<BR>
	<B><BR>
	7.</B> BUG BUSTERS: What is wrong with this code?
</DL>

<PRE><FONT COLOR="#0066FF">1:     #include &lt;iostream.h&gt;
2:
3:     class Animal;
4:
5:     void setValue(Animal&amp; , int);
6:     void setValue(Animal&amp; ,int,int);
7:
8:     class Animal
9:     {
10:    friend void setValue(Animal&amp; ,int);11:    private:
12:       int itsWeight;
13:       int itsAge;
14:    };
15:
16:    void setValue(Animal&amp; theAnimal, int theWeight)
17:    {
18:        theAnimal.itsWeight = theWeight;
19:    }
20:
21:
22:    void setValue(Animal&amp; theAnimal, int theWeight, int theAge)
23:    {
24:       theAnimal.itsWeight = theWeight;
25:       theAnimal.itsAge = theAge;
26:    }
27:
28:    int main()
29:    {
30:       Animal peppy;
31:       setValue(peppy,5);
32:       setValue(peppy,7,9);
33:    }
</FONT></PRE>

<DL>
	<DD><B>8. </B>Fix Exercise 7 so it compiles.<BR>
	
	<P ALIGN="CENTER"><A HREF="ch14rv2.htm"><IMG SRC="../buttons/BLANPREV.GIF"
	WIDTH="37" HEIGHT="37" ALIGN="BOTTOM" BORDER="0"></A><A HREF="http://www.mcp.com/sams"><IMG
	SRC="../buttons/BLANHOME.GIF" WIDTH="37" HEIGHT="37" ALIGN="BOTTOM"
	BORDER="0"></A><A HREF="../index.htm"><IMG SRC="../buttons/BLANTOC.GIF"
	WIDTH="37" HEIGHT="37" ALIGN="BOTTOM" BORDER="0"></A><A HREF="ch16.htm"><IMG SRC="../buttons/BLANNEXT.GIF"
	WIDTH="37" HEIGHT="37" ALIGN="BOTTOM" BORDER="0"></A><A HREF="#heading1"><IMG SRC="../buttons/BLANTOP.GIF"
	WIDTH="37" HEIGHT="37" ALIGN="BOTTOM" BORDER="0"></A>
</DL>



</BODY>

</HTML>