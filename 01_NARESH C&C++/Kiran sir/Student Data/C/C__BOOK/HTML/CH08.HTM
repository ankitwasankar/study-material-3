<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>

<HEAD>
<!-- This document was created from RTF source by rtftohtml version 3.0.1 -->

	<META NAME="GENERATOR" Content="Symantec Visual Page 1.0">
	<META HTTP-EQUIV="Content-Type" CONTENT="text/html;CHARSET=iso-8859-1">
	<TITLE>Teach Yourself C++ in 21 Days</TITLE>
</HEAD>

<BODY TEXT="#000000" BGCOLOR="#FFFFFF">

<H1 ALIGN="CENTER"><A HREF="ch07rv1.htm"><IMG SRC="../buttons/BLANPREV.GIF"
WIDTH="37" HEIGHT="37" ALIGN="BOTTOM" BORDER="0"></A><A HREF="http://www.mcp.com/sams"><IMG
SRC="../buttons/BLANHOME.GIF" WIDTH="37" HEIGHT="37" ALIGN="BOTTOM"
BORDER="0"></A><A HREF="../index.htm"><IMG SRC="../buttons/BLANTOC.GIF"
WIDTH="37" HEIGHT="37" ALIGN="BOTTOM" BORDER="0"></A><A HREF="ch09.htm"><IMG SRC="../buttons/BLANNEXT.GIF"
WIDTH="37" HEIGHT="37" ALIGN="BOTTOM" BORDER="0"></A></H1>
<H1></H1>

<UL>
	<LI><A HREF="#Heading1">Day 8</A>
	<UL>
		<LI><A HREF="#Heading2">Pointers</A>
		<UL>
			<LI><A HREF="#Heading3">What Is a Pointer?</A>
			<UL>
				<LI><A HREF="#Heading4">Figure 8.1.</A>
			</UL>
			<LI><A HREF="#Heading5">Listing 8.1. Demonstrating address of variables</A>
			<UL>
				<LI><A HREF="#Heading7">Figure 8.2.</A>
			</UL>
			<LI><A HREF="#Heading8">Storing the Address in a Pointer</A>
			<UL>
				<LI><A HREF="#Heading9">Pointer Names</A>
				<LI><A HREF="#Heading10">The Indirection Operator</A>
				<LI><A HREF="#Heading11">Pointers, Addresses, and Variables</A>
				<UL>
					<LI><A HREF="#Heading12">Figure 8.3.</A>
				</UL>
				<LI><A HREF="#Heading13">Manipulating Data by Using Pointers</A>
			</UL>
			<LI><A HREF="#Heading14">Listing 8.2. Manipulating data by using pointers</A>
			<UL>
				<LI><A HREF="#Heading16">Examining the Address</A>
			</UL>
			<LI><A HREF="#Heading17">Listing 8.3. Finding out what is stored in pointers</A>
			<LI><A HREF="#Heading19">Pointers</A>
			<LI><A HREF="#Heading20">Why Would You Use Pointers?</A>
			<LI><A HREF="#Heading21">The Stack and the Free Store</A>
			<UL>
				<LI><A HREF="#Heading22">new</A>
				<LI><A HREF="#Heading23">delete</A>
			</UL>
			<LI><A HREF="#Heading24">Listing 8.4. Allocating, using, and deleting pointers.</A>
			<LI><A HREF="#Heading25">Memory Leaks</A>
			<LI><A HREF="#Heading26">Creating Objects on the Free Store</A>
			<LI><A HREF="#Heading27">Deleting Objects</A>
			<LI><A HREF="#Heading28">Listing 8.5. Creating and deleting objects on the free store</A>
			<LI><A HREF="#Heading30">Accessing Data Members</A>
			<LI><A HREF="#Heading31">Listing 8.6. Accessing member data of objects</A>
			<LI><A HREF="#Heading32">on the free store.</A>
			<LI><A HREF="#Heading33">Member Data on the Free Store</A>
			<LI><A HREF="#Heading34">Listing 8.7. Pointers as member data</A>
			<LI><A HREF="#Heading36">The this Pointer</A>
			<LI><A HREF="#Heading37">Listing 8.8. Using the this pointer</A>
			<LI><A HREF="#Heading39">Stray or Dangling Pointers</A>
			<LI><A HREF="#Heading40">Listing 8.9. Creating a stray pointer</A>
			<LI><A HREF="#Heading42">const Pointers</A>
			<UL>
				<LI><A HREF="#Heading43">const Pointers and const Member Functions</A>
			</UL>
			<LI><A HREF="#Heading44">Listing 8.10. Using pointers to const objects</A>
			<UL>
				<LI><A HREF="#Heading46">const this Pointers</A>
			</UL>
			<LI><A HREF="#Heading47">Summary</A>
			<LI><A HREF="#Heading48">Q&amp;A</A>
			<LI><A HREF="#Heading49">Workshop</A>
			<UL>
				<LI><A HREF="#Heading50">Quiz</A>
				<LI><A HREF="#Heading51">Exercises</A>
			</UL>
		</UL>
	</UL>
</UL>

<P>
<HR SIZE="4">

<H2 ALIGN="CENTER"><A NAME="Heading1"></A><FONT COLOR="#000077">Day 8</FONT></H2>
<H2 ALIGN="CENTER"><A NAME="Heading2"></A><FONT COLOR="#000077">Pointers</FONT></H2>
<P>One of the most powerful tools available to a C++ programmer is the ability to
manipulate computer memory directly by using pointers. Today you will learn

<UL>
	<LI>What pointers are.
	<P>
	<LI>How to declare and use pointers.
	<P>
	<LI>What the free store is and how to manipulate memory.
</UL>

<P>Pointers present two special challenges when learning C++: They can be somewhat
confusing, and it isn't immediately obvious why they are needed. This chapter explains
how pointers work, step by step. You will fully understand the need for pointers,
however, only as the book progresses.
<H3 ALIGN="CENTER"><A NAME="Heading3"></A><FONT COLOR="#000077">What Is a Pointer?</FONT></H3>

<DL>
	<DD>
<HR>
<FONT COLOR="#000077"><B>New Term:</B></FONT><B> </B>A <I>pointer</I> is a variable
	that holds a memory address. 
<HR>

</DL>

<P>To understand pointers, you must know a little about computer memory. Computer
memory is divided into sequentially numbered memory locations. Each variable is located
at a unique location in memory, known as its address. (This is discussed in the &quot;Extra
Credit&quot; section following Day 5, &quot;Functions.&quot;) Figure 8.1 shows a
schematic representation of the storage of an <TT>unsigned long</TT> integer variable
<TT>theAge</TT>.<BR>
<BR>
<A NAME="Heading4"></A><A HREF="../art/ch08/figure1.jpg"><FONT COLOR="#000077">Figure
8.1.</FONT></A><I> A schematic representation of <TT>theAge</TT></I>.<BR>
<BR>
Different computers number this memory using different, complex schemes. Usually
programmers don't need to know the particular address of any given variable, because
the compiler handles the details. If you want this information, though, you can use
the <TT>address of</TT> operator (<TT>&amp;</TT>), which is illustrated in Listing
8.1.</P>
<P><A NAME="Heading5"></A><FONT SIZE="4" COLOR="#000077"><B>Listing 8.1. Demonstrating
address of variables.</B></FONT></P>
<PRE><FONT COLOR="#0066FF">1:   // Listing 8.1 Demonstrates address of operator
2:   // and addresses of local variables
3:
4:   #include &lt;iostream.h&gt;
5:
6:   int main()
7:   {
8:      unsigned short shortVar=5;
9:      unsigned long  longVar=65535;
10:     long sVar = -65535;
11:
12:     cout &lt;&lt; &quot;shortVar:\t&quot; &lt;&lt; shortVar;
13:     cout &lt;&lt; &quot; Address of shortVar:\t&quot;;
14:     cout &lt;&lt;  &amp;shortVar  _&lt;&lt; &quot;\n&quot;;
15:
16:     cout &lt;&lt; &quot;longVar:\t&quot;  &lt;&lt; longVar;
17:      cout  &lt;&lt; &quot; Address of longVar:\t&quot; ;
18:      cout &lt;&lt;  &amp;longVar  _&lt;&lt; &quot;\n&quot;;
19:
20:     cout &lt;&lt; &quot;sVar:\t&quot;     &lt;&lt; sVar;
21:       cout     &lt;&lt; &quot; Address of sVar:\t&quot; ;
22:       cout     &lt;&lt;  &amp;sVar     _&lt;&lt; &quot;\n&quot;;
23:
24:  return 0;
<TT>25: }</TT></FONT>
<FONT COLOR="#0066FF">
Output: shortVar: 5       Address of shortVar: 0x8fc9:fff4
longVar:  65535   Address of longVar:  0x8fc9:fff2
sVar:    -65535   Address of sVar:     0x8fc9:ffee
</FONT></PRE>
<P>(Your printout may look different.)</P>
<P><BR>
<FONT COLOR="#000077"><B>Analysis:</B></FONT><B> </B>Three variables are declared
and initialized: a <TT>short</TT> in line 8, an <TT>unsigned long</TT> in line 9,
and a <TT>long</TT> in line 10. Their values and addresses are printed in lines 12-16,
by using the <TT>address of</TT> operator (<TT>&amp;</TT>).<BR>
The value of <TT>shortVar</TT> is <TT>5</TT>, as expected, and its address is <TT>0x8fc9:fff4</TT>
when run on my 80386-based computer. This complicated address is computer-specific
and may change slightly each time the program is run. Your results will be different.
What doesn't change, however, is that the difference in the first two addresses is
two bytes if your computer uses two-byte <TT>short</TT> integers. The difference
between the second and third is four bytes if your computer uses four-byte <TT>long</TT>
integers. Figure 8.2 illustrates how the variables in this program would be stored
in memory.<BR>
<BR>
<A NAME="Heading7"></A><A HREF="../art/ch08/figure2.jpg"><FONT COLOR="#000077">Figure
8.2.</FONT></A><FONT COLOR="#000077"><I> </I></FONT><I>Illustration of variable storage.</I><BR>
<BR>
There is no reason why you need to know the actual numeric value of the address of
each variable. What you care about is that each one has an address and that the right
amount of memory is set aside. You tell the compiler how much memory to allow for
your variables by declaring the variable type; the compiler automatically assigns
an address for it. For example, a <TT>long</TT> integer is typically four bytes,
meaning that the variable has an address to four bytes of memory.
<H4 ALIGN="CENTER"><A NAME="Heading8"></A><FONT COLOR="#000077">Storing the Address
in a Pointer</FONT></H4>
<P>Every variable has an address. Even without knowing the specific address of a
given variable, you can store that address in a pointer.</P>
<P>For example, suppose that <TT>howOld</TT> is an integer. To declare a pointer
called <TT>pAge</TT> to hold its address, you would write</P>
<PRE><FONT COLOR="#0066FF">int *pAge = 0;
</FONT></PRE>
<P>This declares <TT>pAge</TT> to be a pointer to <TT>int</TT>. That is, <TT>pAge</TT>
is declared to hold the address of an <TT>int</TT>.</P>
<P>Note that <TT>pAge</TT> is a variable like any of the variables. When you declare
an integer variable (type <TT>int</TT>), it is set up to hold an integer. When you
declare a pointer variable like <TT>pAge</TT>, it is set up to hold an address. <TT>pAge</TT>
is just a different type of variable.</P>
<P>In this example, <TT>pAge</TT> is initialized to zero. A pointer whose value is
zero is called a null pointer. All pointers, when they are created, should be initialized
to something. If you don't know what you want to assign to the pointer, assign <TT>0</TT>.
A pointer that is not initialized is called a wild pointer. Wild pointers are very
dangerous.


<BLOCKQUOTE>
	<P>
<HR>
<FONT COLOR="#000077"><B>NOTE:</B></FONT><B> </B>Practice safe computing: Initialize
	your pointers! 
<HR>


</BLOCKQUOTE>

<P>If you do initialize the pointer to <TT>0</TT>, you must specifically assign the
address of <TT>howOld</TT> to <TT>pAge</TT>. Here's an example that shows how to
do that:</P>
<PRE><FONT COLOR="#0066FF">unsigned short int howOld = 50;     // make a variable
unsigned short int * pAge = 0;      // make a pointer
pAge = &amp;howOld;                     // put howOld's address in pAge
</FONT></PRE>
<P>The first line creates a variable--<TT>howOld</TT>, whose type is <TT>unsigned
short int</TT>--and initializes it with the value <TT>50</TT>. The second line declares
<TT>pAge</TT> to be a pointer to type <TT>unsigned short int</TT> and initializes
it to zero. You know that <TT>pAge</TT> is a pointer because of the asterisk (<TT>*</TT>)
after the variable type and before the variable name.</P>
<P>The third and final line assigns the address of <TT>howOld</TT> to the pointer
<TT>pAge</TT>. You can tell that the address of <TT>howOld</TT> is being assigned
because of the <TT>address of</TT> operator (<TT>&amp;</TT>). If the <TT>address
of</TT> operator had not been used, the value of <TT>howOld</TT> would have been
assigned. That might, or might not, have been a valid address.</P>
<P>At this point, <TT>pAge</TT> has as its value the address of <TT>howOld</TT>.
<TT>howOld</TT>, in turn, has the value <TT>50</TT>. You could have accomplished
this with one less step, as in</P>
<PRE><FONT COLOR="#0066FF">unsigned short int howOld = 50;       // make a variable
unsigned short int * pAge = &amp;howOld;  // make pointer to howOld
</FONT></PRE>
<P><TT>pAge</TT> is a pointer that now contains the address of the <TT>howOld</TT>
variable. Using <TT>pAge</TT>, you can actually determine the value of <TT>howOld</TT>,
which in this case is <TT>50</TT>. Accessing <TT>howOld</TT> by using the pointer
<TT>pAge</TT> is called indirection because you are indirectly accessing <TT>howOld</TT>
by means of<TT> pAge</TT>. Later today you will see how to use indirection to access
a variable's value.</P>

<DL>
	<DD>
<HR>
<FONT COLOR="#000077"><B>New Term:</B></FONT><B> </B>Indirection means accessing
	the value at the address held by a pointer. The pointer provides an indirect way
	to get the value held at that address. 
<HR>

</DL>

<H4 ALIGN="CENTER"><A NAME="Heading9"></A><FONT COLOR="#000077">Pointer Names</FONT></H4>
<P>Pointers can have any name that is legal for other variables. This book follows
the convention of naming all pointers with an initial <TT>p</TT>, as in <TT>pAge</TT>
or <TT>pNumber</TT>.
<H4 ALIGN="CENTER"><A NAME="Heading10"></A><FONT COLOR="#000077">The Indirection
Operator</FONT></H4>
<P>The indirection operator (<TT>*</TT>) is also called the dereference operator.
When a pointer is dereferenced, the value at the address stored by the pointer is
retrieved.</P>
<P>Normal variables provide direct access to their own values. If you create a new
variable of type <TT>unsigned short int</TT> called <TT>yourAge</TT>, and you want
to assign the value in <TT>howOld</TT> to that new variable, you would write</P>
<PRE><FONT COLOR="#0066FF">unsigned short int yourAge;
yourAge = howOld;
</FONT></PRE>
<P>A pointer provides indirect access to the value of the variable whose address
it stores. To assign the value in <TT>howOld</TT> to the new variable <TT>yourAge</TT>
by way of the pointer <TT>pAge</TT>, you would write</P>
<PRE><FONT COLOR="#0066FF">unsigned short int yourAge;
yourAge = *pAge;
</FONT></PRE>
<P>The indirection operator (<TT>*</TT>) in front of the variable <TT>pAge</TT> means
&quot;the value stored at.&quot; This assignment says, &quot;Take the value stored
at the address in <TT>pAge</TT> and assign it to <TT>yourAge</TT>.&quot;


<BLOCKQUOTE>
	<P>
<HR>
<FONT COLOR="#000077"><B>NOTE:</B></FONT><B> </B>The indirection operator (<TT>*</TT>)
	is used in two distinct ways with pointers: declaration and dereference. When a pointer
	is declared, the star indicates that it is a pointer, not a normal variable. For
	example,</P>
	<PRE><FONT COLOR="#0066FF">
unsigned short * pAge = 0; // make a pointer to an unsigned short</FONT></PRE>

</BLOCKQUOTE>

<PRE><FONT COLOR="#0066FF"></FONT></PRE>


<BLOCKQUOTE>
	<P>When the pointer is dereferenced, the indirection operator indicates that the
	value at the memory location stored in the pointer is to be accessed, rather than
	the address itself.</P>
	<PRE><FONT COLOR="#0066FF">*pAge = 5; // assign 5 to the value at pAge</FONT></PRE>

</BLOCKQUOTE>

<PRE><FONT COLOR="#0066FF"></FONT></PRE>


<BLOCKQUOTE>
	<P>Also note that this same character (<TT>*</TT>) is used as the multiplication
	operator. The compiler knows which operator to call, based on context. 
<HR>


</BLOCKQUOTE>

<H4 ALIGN="CENTER"><A NAME="Heading11"></A><FONT COLOR="#000077">Pointers, Addresses,
and Variables</FONT></H4>
<P>It is important to distinguish between a pointer, the address that the pointer
holds, and the value at the address held by the pointer. This is the source of much
of the confusion about pointers.</P>
<P>Consider the following code fragment:</P>
<PRE><FONT COLOR="#0066FF">int theVariable = 5;
int * pPointer = &amp;theVariable ;
</FONT></PRE>
<P><TT>theVariable</TT> is declared to be an integer variable initialized with the
value <TT>5</TT>. <TT>pPointer</TT> is declared to be a pointer to an integer; it
is initialized with the address of <TT>theVariable</TT>.<TT> pPointer</TT> is the
pointer. The address that <TT>pPointer</TT> holds is the address of <TT>theVariable</TT>.
The value at the address that <TT>pPointer</TT> holds is <TT>5</TT>. Figure 8.3 shows
a schematic representation of <TT>theVariable</TT> and <TT>pPointer</TT>.<BR>
<BR>
<A NAME="Heading12"></A><A HREF="../art/ch08/figure3.jpg"><FONT COLOR="#000077">Figure
8.3.</FONT></A><FONT COLOR="#000077"> </FONT><I>A schematic representation of memory.</I>
<H4 ALIGN="CENTER"><A NAME="Heading13"></A><FONT COLOR="#000077">Manipulating Data
by Using Pointers</FONT></H4>
<P>Once a pointer is assigned the address of a variable, you can use that pointer
to access the data in that variable. Listing 8.2 demonstrates how the address of
a local variable is assigned to a pointer and how the pointer manipulates the values
in that variable.</P>
<P><A NAME="Heading14"></A><FONT SIZE="4" COLOR="#000077"><B>Listing 8.2. Manipulating
data by using pointers.</B></FONT></P>
<PRE><FONT COLOR="#0066FF">1:     // Listing 8.2 Using pointers
2:
3:     #include &lt;iostream.h&gt;
4:
5:     typedef unsigned short int USHORT;
6:     int main()
7:     {
8:        USHORT myAge;         // a variable
9:        USHORT * pAge = 0;    // a pointer
10:       myAge = 5;
11:       cout &lt;&lt; &quot;myAge: &quot; &lt;&lt; myAge &lt;&lt; &quot;\n&quot;;
12:
13:       pAge = &amp;myAge;     // assign address of myAge to pAge
14:
15:       cout &lt;&lt; &quot;*pAge: &quot; &lt;&lt; *pAge &lt;&lt; &quot;\n\n&quot;;
16:
17:       cout &lt;&lt; &quot;*pAge = 7\n&quot;;
18:
19:       *pAge = 7;         // sets myAge to 7
20:
21:       cout &lt;&lt; &quot;*pAge: &quot; &lt;&lt; *pAge &lt;&lt; &quot;\n&quot;;
22:       cout &lt;&lt; &quot;myAge: &quot; &lt;&lt; myAge &lt;&lt; &quot;\n\n&quot;;
23:
24:
25:       cout &lt;&lt; &quot;myAge = 9\n&quot;;
26:
27:       myAge = 9;
28:
29:       cout &lt;&lt; &quot;myAge: &quot; &lt;&lt; myAge &lt;&lt; &quot;\n&quot;;
30:       cout &lt;&lt; &quot;*pAge: &quot; &lt;&lt; *pAge &lt;&lt; &quot;\n&quot;;
31:
32:    return 0;
<TT>33: }</TT></FONT>
<FONT COLOR="#0066FF">
Output: myAge: 5
*pAge: 5

*pAge = 7
*pAge: 7
myAge: 7

myAge = 9
myAge: 9
*pAge: 9
</FONT></PRE>
<P><FONT COLOR="#000077"><B>Analysis:</B></FONT><B> </B>This program declares two
variables: an <TT>unsigned short</TT>, <TT>myAge</TT>, and a pointer to an <TT>unsigned
short, pAge</TT>. <TT>myAge</TT> is assigned the value <TT>5</TT> on line 10; this
is verified by the printout in line 11.<BR>
On line 13, <TT>pAge</TT> is assigned the address of <TT>myAge</TT>. On line 15,
<TT>pAge</TT> is dereferenced and printed, showing that the value at the address
that <TT>pAge</TT> stores is the <TT>5</TT> stored in <TT>myAge</TT>. In line 17,
the value <TT>7</TT> is assigned to the variable at the address stored in <TT>pAge</TT>.
This sets <TT>myAge</TT> to <TT>7</TT>, and the printouts in lines 21-22 confirm
this.</P>
<P>In line 27, the value <TT>9</TT> is assigned to the variable <TT>myAge</TT>. This
value is obtained directly in line 29 and indirectly (by dereferencing <TT>pAge</TT>)
in line 30.
<H4 ALIGN="CENTER"><A NAME="Heading16"></A><FONT COLOR="#000077">Examining the Address</FONT></H4>
<P>Pointers enable you to manipulate addresses without ever knowing their real value.
After today, you'll take it on faith that when you assign the address of a variable
to a pointer, it really has the address of that variable as its value. But just this
once, why not check to make sure? Listing 8.3 illustrates this idea.</P>
<P><A NAME="Heading17"></A><FONT SIZE="4" COLOR="#000077"><B>Listing 8.3. Finding
out what is stored in pointers.</B></FONT></P>
<PRE><FONT COLOR="#0066FF">
1:      // Listing 8.3 What is stored in a pointer.
2:
3:     #include &lt;iostream.h&gt;
4:
5:     typedef unsigned short int USHORT;
6:     int main()
7:     {
8:        unsigned short int myAge = 5, yourAge = 10;
9:        unsigned short int * pAge = &amp;myAge;  // a pointer
10:
11:       cout &lt;&lt; &quot;myAge:\t&quot; &lt;&lt; myAge &lt;&lt;  &quot;\tyourAge:\t&quot; &lt;&lt; yourAge &lt;&lt; &quot;\n&quot;;
12:       cout &lt;&lt; &quot;&amp;myAge:\t&quot; &lt;&lt; &amp;myAge &lt;&lt;  &quot;\t&amp;yourAge:\t&quot; &lt;&lt; &amp;yourAge &lt;&lt;&quot;\n&quot;;
13:
14:       cout &lt;&lt; &quot;pAge:\t&quot; &lt;&lt; pAge &lt;&lt; &quot;\n&quot;;
15:       cout &lt;&lt; &quot;*pAge:\t&quot; &lt;&lt; *pAge &lt;&lt; &quot;\n&quot;;
16:
17:       pAge = &amp;yourAge;       // reassign the pointer
18:
19:       cout &lt;&lt; &quot;myAge:\t&quot; &lt;&lt; myAge &lt;&lt;  &quot;\tyourAge:\t&quot; &lt;&lt; yourAge &lt;&lt; &quot;\n&quot;;
20:       cout &lt;&lt; &quot;&amp;myAge:\t&quot; &lt;&lt; &amp;myAge &lt;&lt;  &quot;\t&amp;yourAge:\t&quot; &lt;&lt; &amp;yourAge &lt;&lt;&quot;\n&quot;;
21:
22:       cout &lt;&lt; &quot;pAge:\t&quot; &lt;&lt; pAge &lt;&lt; &quot;\n&quot;;
23:       cout &lt;&lt; &quot;*pAge:\t&quot; &lt;&lt; *pAge &lt;&lt; &quot;\n&quot;;
24:
25:       cout &lt;&lt; &quot;&amp;pAge:\t&quot; &lt;&lt; &amp;pAge &lt;&lt; &quot;\n&quot;;
26:    return 0;
<TT>27: }</TT>
Output: myAge:     5             yourAge:  10
&amp;myAge:    0x355C        &amp;yourAge: 0x355E
pAge:      0x355C
*pAge:     5
myAge:     5             yourAge:  10
&amp;myAge:    0x355C        &amp;yourAge: 0x355E
pAge:      0x355E
*pAge:     10
&amp;pAge:     0x355A
</FONT></PRE>
<P>(Your output may look different.)</P>
<P><FONT COLOR="#000077"><B>Analysis:</B></FONT><B> </B>In line 8, <TT>myAge</TT>
and <TT>yourAge</TT> are declared to be variables of type <TT>unsigned short</TT>
integer. In line 9, <TT>pAge</TT> is declared to be a pointer to an <TT>unsigned
short</TT> integer, and it is initialized with the address of the variable <TT>myAge</TT>.<BR>
Lines 11 and 12 print the values and the addresses of <TT>myAge</TT> and <TT>yourAge</TT>.
Line 14 prints the contents of <TT>pAge</TT>, which is the address of <TT>myAge</TT>.
Line 15 prints the result of dereferencing <TT>pAge</TT>, which prints the value
at <TT>pAge</TT>--the value in <TT>myAge</TT>, or <TT>5</TT>.</P>
<P>This is the essence of pointers. Line 14 shows that <TT>pAge</TT> stores the address
of <TT>myAge</TT>, and line 15 shows how to get the value stored in <TT>myAge</TT>
by dereferencing the pointer <TT>pAge</TT>. Make sure that you understand this fully
before you go on. Study the code and look at the output.</P>
<P>In line 17, <TT>pAge</TT> is reassigned to point to the address of <TT>yourAge</TT>.
The values and addresses are printed again. The output shows that <TT>pAge</TT> now
has the address of the variable <TT>yourAge</TT> and that dereferencing obtains the
value in <TT>yourAge</TT>.</P>
<P>Line 25 prints the address of <TT>pAge</TT> itself. Like any variable, it has
an address, and that address can be stored in a pointer. (Assigning the address of
a pointer to another pointer will be discussed shortly.)


<BLOCKQUOTE>
	<P>
<HR>
<B>DO</B> use the indirection operator (<TT>*</TT>) to access the data stored at
	the address in a pointer. <B>DO</B> initialize all pointers either to a valid address
	or to <TT>null</TT> (<TT>0</TT>)<B>. DO </B>remember the difference between the address
	in a pointer and the value at that address. 
<HR>


</BLOCKQUOTE>

<H3 ALIGN="CENTER"><A NAME="Heading19"></A><FONT COLOR="#000077">Pointers</FONT></H3>
<P>To declare a pointer, write the type of the variable or object whose address will
be stored in the pointer, followed by the pointer operator (<TT>*</TT>) and the name
of the pointer. For example,</P>
<PRE><FONT COLOR="#0066FF">unsigned short int * pPointer = 0;
</FONT></PRE>
<P>To assign or initialize a pointer, prepend the name of the variable whose address
is being assigned with the <TT>address of</TT> operator (<TT>&amp;</TT>). For example,</P>
<PRE><FONT COLOR="#0066FF">unsigned short int theVariable = 5;

unsigned short int * pPointer = &amp; theVariable;
</FONT></PRE>
<P>To dereference a pointer, prepend the pointer name with the dereference operator
(<TT>*</TT>). For example,</P>
<PRE><FONT COLOR="#0066FF">unsigned short int theValue = *pPointer
</FONT></PRE>
<H3 ALIGN="CENTER"><A NAME="Heading20"></A><FONT COLOR="#000077">Why Would You Use
Pointers?</FONT></H3>
<P>So far you've seen step-by-step details of assigning a variable's address to a
pointer. In practice, though, you would never do this. After all, why bother with
a pointer when you already have a variable with access to that value? The only reason
for this kind of pointer manipulation of an automatic variable is to demonstrate
how pointers work. Now that you are comfortable with the syntax of pointers, you
can put them to good use. Pointers are used, most often, for three tasks:

<UL>
	<LI>Managing data on the free store.
	<P>
	<LI>Accessing class member data and functions.
	<P>
	<LI>Passing variables by reference to functions.
</UL>

<P>This rest of this chapter focuses on managing data on the free store and accessing
class member data and functions. Tomorrow you will learn about passing variables
by reference.
<H3 ALIGN="CENTER"><A NAME="Heading21"></A><FONT COLOR="#000077">The Stack and the
Free Store</FONT></H3>
<P>In the &quot;Extra Credit&quot; section following the discussion of functions
in Day 5, five areas of memory are mentioned:

<UL>
	<LI>Global name space
	<P>
	<LI>The free store
	<P>
	<LI>Registers
	<P>
	<LI>Code space
	<P>
	<LI>The stack
</UL>

<P>Local variables are on the stack, along with function parameters. Code is in code
space, of course, and global variables are in global name space. The registers are
used for internal housekeeping functions, such as keeping track of the top of the
stack and the instruction pointer. Just about all remaining memory is given over
to the free store, which is sometimes referred to as the heap.</P>
<P>The problem with local variables is that they don't persist: When the function
returns, the local variables are thrown away. Global variables solve that problem
at the cost of unrestricted access throughout the program, which leads to the creation
of code that is difficult to understand and maintain. Putting data in the free store
solves both of these problems.</P>
<P>You can think of the free store as a massive section of memory in which thousands
of sequentially numbered cubbyholes lie waiting for your data. You can't label these
cubbyholes, though, as you can with the stack. You must ask for the address of the
cubbyhole that you reserve and then stash that address away in a pointer.</P>
<P>One way to think about this is with an analogy: A friend gives you the 800 number
for Acme Mail Order. You go home and program your telephone with that number, and
then you throw away the piece of paper with the number on it. If you push the button,
a telephone rings somewhere, and Acme Mail Order answers. You don't remember the
number, and you don't know where the other telephone is located, but the button gives
you access to Acme Mail Order. Acme Mail Order is your data on the free store. You
don't know where it is, but you know how to get to it. You access it by using its
address--in this case, the telephone number. You don't have to know that number;
you just have to put it into a pointer (the button). The pointer gives you access
to your data without bothering you with the details.</P>
<P>The stack is cleaned automatically when a function returns. All the local variables
go out of scope, and they are removed from the stack. The free store is not cleaned
until your program ends, and it is your responsibility to free any memory that you've
reserved when you are done with it.</P>
<P>The advantage to the free store is that the memory you reserve remains available
until you explicitly free it. If you reserve memory on the free store while in a
function, the memory is still available when the function returns.</P>
<P>The advantage of accessing memory in this way, rather than using global variables,
is that only functions with access to the pointer have access to the data. This provides
a tightly controlled interface to that data, and it eliminates the problem of one
function changing that data in unexpected and unanticipated ways.</P>
<P>For this to work, you must be able to create a pointer to an area on the free
store and to pass that pointer among functions. The following sections describe how
to do this.
<H4 ALIGN="CENTER"><A NAME="Heading22"></A><FONT COLOR="#000077">new</FONT></H4>
<P>You allocate memory on the free store in C++ by using the <TT>new</TT> keyword.
<TT>new</TT> is followed by the type of the object that you want to allocate so that
the compiler knows how much memory is required. Therefore, <TT>new unsigned short
int</TT> allocates two bytes in the free store, and <TT>new long</TT> allocates four.</P>
<P>The return value from <TT>new</TT> is a memory address. It must be assigned to
a pointer. To create an <TT>unsigned</TT> <TT>short</TT> on the free store, you might
write</P>
<PRE><FONT COLOR="#0066FF">unsigned short int * pPointer;
pPointer = new unsigned short int;
</FONT></PRE>
<P>You can, of course, initialize the pointer at its creation with</P>
<PRE><FONT COLOR="#0066FF">unsigned short int * pPointer = new unsigned short int;
</FONT></PRE>
<P>In either case, <TT>pPointer</TT> now points to an <TT>unsigned short int</TT>
on the free store. You can use this like any other pointer to a variable and assign
a value into that area of memory by writing</P>
<PRE><FONT COLOR="#0066FF">*pPointer = 72;
</FONT></PRE>
<P>This means, &quot;Put 72 at the value in <TT>pPointer</TT>,&quot; or &quot;Assign
the value <TT>72</TT> to the area on the free store to which <TT>pPointer</TT> points.&quot;</P>
<P>If <TT>new</TT> cannot create memory on the free store (memory is, after all,
a limited resource) it returns the null pointer. You must check your pointer for
null each time you request new memory.


<BLOCKQUOTE>
	<P>
<HR>
<FONT COLOR="#000077"><B>WARNING:</B></FONT><B> </B>Each time you allocate memory
	using the <TT>new</TT> keyword, you must check to make sure the pointer is not null.
	
<HR>


</BLOCKQUOTE>

<H4 ALIGN="CENTER"><A NAME="Heading23"></A><FONT COLOR="#000077">delete</FONT></H4>
<P>When you are finished with your area of memory, you must call <TT>delete</TT>
on the pointer. <TT>delete</TT> returns the memory to the free store. Remember that
the pointer itself--as opposed to the memory to which it points--is a local variable.
When the function in which it is declared returns, that pointer goes out of scope
and is lost. The memory allocated with <TT>new</TT> is not freed automatically, however.
That memory becomes unavailable--a situation called a memory leak. It's called a
memory leak because that memory can't be recovered until the program ends. It is
as though the memory has leaked out of your computer.</P>
<P>To restore the memory to the free store, you use the keyword <TT>delete</TT>.
For example,</P>
<PRE><FONT COLOR="#0066FF">delete pPointer;
</FONT></PRE>
<P>When you delete the pointer, what you are really doing is freeing up the memory
whose address is stored in the pointer. You are saying, &quot;Return to the free
store the memory that this pointer points to.&quot; The pointer is still a pointer,
and it can be reassigned. Listing 8.4 demonstrates allocating a variable on the heap,
using that variable, and deleting it.


<BLOCKQUOTE>
	<P>
<HR>
<FONT COLOR="#000077"><B>WARNING:</B></FONT><B> </B>When you call <TT>delete</TT>
	on a pointer, the memory it points to is freed. Calling <TT>delete</TT> on that pointer
	again will crash your program! When you delete a pointer, set it to zero (null).
	Calling <TT>delete</TT> on a null pointer is guaranteed to be safe. For example:</P>
	<PRE><FONT COLOR="#0066FF">Animal *pDog = new Animal; delete pDog; //frees the memory    </FONT></PRE>

	<BLOCKQUOTE>
		<PRE><FONT COLOR="#0066FF">pDog = 0; //sets pointer to null    //... delete pDog; //harmless</FONT></PRE>

	</BLOCKQUOTE>
	<P>
<HR>


</BLOCKQUOTE>

<PRE></PRE>
<P><A NAME="Heading24"></A><FONT SIZE="4" COLOR="#000077"><B>Listing 8.4. Allocating,
using, and deleting pointers.</B></FONT></P>
<PRE><FONT COLOR="#0066FF">
1:     // Listing 8.4
2:     // Allocating and deleting a pointer
3:
4:     #include &lt;iostream.h&gt;
5:     int main()
6:     {
7:        int localVariable = 5;
8:        int * pLocal= &amp;localVariable;
9:        int * pHeap = new int;
10:       if (pHeap == NULL)
11:        {
12:            cout &lt;&lt; &quot;Error! No memory for pHeap!!&quot;;
13:            return 0;
14:        }
15:       *pHeap = 7;
16:       cout &lt;&lt; &quot;localVariable: &quot; &lt;&lt; localVariable &lt;&lt; &quot;\n&quot;;
17:       cout &lt;&lt; &quot;*pLocal: &quot; &lt;&lt; *pLocal &lt;&lt; &quot;\n&quot;;
18:       cout &lt;&lt; &quot;*pHeap: &quot; &lt;&lt; *pHeap &lt;&lt; &quot;\n&quot;;
19:       delete pHeap;
20:       pHeap = new int;
21:       if (pHeap == NULL)
22:       {
23:            cout &lt;&lt; &quot;Error! No memory for pHeap!!&quot;;
24:            return 0;
25:       }
26:       *pHeap = 9;
27:       cout &lt;&lt; &quot;*pHeap: &quot; &lt;&lt; *pHeap &lt;&lt; &quot;\n&quot;;
28:       delete pHeap;
29:       return 0;
<TT>30: }</TT></FONT>
<FONT COLOR="#0066FF">
Output: localVariable: 5
*pLocal: 5
*pHeap: 7
*pHeap: 9
</FONT></PRE>
<P><FONT COLOR="#000077"><B>Analysis: </B></FONT>Line 7 declares and initializes
a local variable. Line 8 declares and initializes a pointer with the address of the
local variable. Line 9 declares another pointer but initializes it with the result
obtained from calling <TT>new int</TT>. This allocates space on the free store for
an <TT>int</TT>. Line 10 verifies that memory was allocated and the pointer is valid
(not null). If no memory can be allocated, the pointer is null and an error message
is printed.<BR>
To keep things simple, this error checking often won't be reproduced in future programs,
but you must include some sort of error checking in your own programs.</P>
<P>Line 15 assigns the value <TT>7</TT> to the newly allocated memory. Line 16 prints
the value of the local variable, and line 17 prints the value pointed to by <TT>pLocal</TT>.
As expected, these are the same. Line 19 prints the value pointed to by <TT>pHeap</TT>.
It shows that the value assigned in line 15 is, in fact, accessible.</P>
<P>In line 19, the memory allocated in line 9 is returned to the free store by a
call to <TT>delete</TT>. This frees the memory and disassociates the pointer from
that memory. <TT>pHeap</TT> is now free to point to other memory. It is reassigned
in lines 20 and 26, and line 27 prints the result. Line 28 restores that memory to
the free store.</P>
<P>Although line 28 is redundant (the end of the program would have returned that
memory) it is a good idea to free this memory explicitly. If the program changes
or is extended, it will be beneficial that this step was already taken care of.
<H3 ALIGN="CENTER"><A NAME="Heading25"></A><FONT COLOR="#000077">Memory Leaks</FONT></H3>
<P>Another way you might inadvertently create a memory leak is by reassigning your
pointer before deleting the memory to which it points. Consider this code fragment:</P>
<PRE><FONT COLOR="#0066FF">1:   unsigned short int * pPointer = new unsigned short int;
2:   *pPointer = 72;
3:   pPointer = new unsigned short int;
4:   *pPointer = 84;
</FONT></PRE>
<P>Line 1 creates <TT>pPointer</TT> and assigns it the address of an area on the
free store. Line 2 stores the value <TT>72</TT> in that area of memory. Line 3 reassigns
<TT>pPointer</TT> to another area of memory. Line 4 places the value <TT>84</TT>
in that area. The original area--in which the value <TT>72</TT> is now held--is unavailable
because the pointer to that area of memory has been reassigned. There is no way to
access that original area of memory, nor is there any way to free it before the program
ends.</P>
<P>The code should have been written like this:</P>
<PRE><FONT COLOR="#0066FF">1: unsigned short int * pPointer = new unsigned short int;
2: *pPointer = 72;
3: delete pPointer;
4: pPointer = new unsigned short int;
5: *pPointer = 84;
</FONT></PRE>
<P>Now the memory originally pointed to by <TT>pPointer</TT> is deleted, and thus
freed, in line 3.


<BLOCKQUOTE>
	<P>
<HR>
<FONT COLOR="#000077"><B>NOTE:</B></FONT><B> </B>For every time in your program that
	you call <TT>new</TT>, there should be a call to <TT>delete</TT>. It is important
	to keep track of which pointer owns an area of memory and to ensure that the memory
	is returned to the free store when you are done with it. 
<HR>


</BLOCKQUOTE>

<H3 ALIGN="CENTER"><A NAME="Heading26"></A><FONT COLOR="#000077">Creating Objects
on the Free Store</FONT></H3>
<P>Just as you can create a pointer to an integer, you can create a pointer to any
object. If you have declared an object of type <TT>Cat</TT>, you can declare a pointer
to that class and instantiate a <TT>Cat</TT> object on the free store, just as you
can make one on the stack. The syntax is the same as for integers:</P>
<PRE><FONT COLOR="#0066FF">Cat *pCat = new Cat;
</FONT></PRE>
<P>This calls the default constructor--the constructor that takes no parameters.
The constructor is called whenever an object is created (on the stack or on the free
store).
<H3 ALIGN="CENTER"><A NAME="Heading27"></A><FONT COLOR="#000077">Deleting Objects</FONT></H3>
<P>When you call <TT>delete</TT> on a pointer to an object on the free store, that
object's destructor is called before the memory is released. This gives your class
a chance to clean up, just as it does for objects destroyed on the stack. Listing
8.5 illustrates creating and deleting objects on the free store.</P>
<P><A NAME="Heading28"></A><FONT SIZE="4" COLOR="#000077"><B>Listing 8.5. Creating
and deleting objects on the free store.</B></FONT></P>
<PRE><FONT COLOR="#0066FF">
1:    // Listing 8.5
2:    // Creating objects on the free store
3:
4:     #include &lt;iostream.h&gt;
5:
6:     class SimpleCat
7:     {
8:     public:
9:            SimpleCat();
10:             ~SimpleCat();
11     private:
12             int itsAge;
13        };
14
15        SimpleCat::SimpleCat()
16        {
17               cout &lt;&lt; &quot;Constructor called.\n&quot;;
18               itsAge = 1;
19        }
20
21        SimpleCat::~SimpleCat()
22        {
23               cout &lt;&lt; &quot;Destructor called.\n&quot;;
24        }
25
26        int main()
27        {
28               cout &lt;&lt; &quot;SimpleCat Frisky...\n&quot;;
29               SimpleCat Frisky;
30               cout &lt;&lt; &quot;SimpleCat *pRags = new SimpleCat...\n&quot;;
31               SimpleCat * pRags = new SimpleCat;
32               cout &lt;&lt; &quot;delete pRags...\n&quot;;
33               delete pRags;
34               cout &lt;&lt; &quot;Exiting, watch Frisky go...\n&quot;;
35        return 0;
<TT>36 }</TT></FONT>
<FONT COLOR="#0066FF">
Output: SimpleCat Frisky...
Constructor called.
SimpleCat *pRags = new SimpleCat..
Constructor called.
delete pRags...
Destructor called.
Exiting, watch Frisky go...
Destructor called.
</FONT></PRE>
<P><FONT COLOR="#000077"><B>Analysis:</B></FONT><B> </B>Lines 6-13 declare the stripped-down
class <TT>SimpleCat</TT>. Line 9 declares <TT>SimpleCat</TT>'s constructor, and lines
15-19 contain its definition. Line 10 declares <TT>SimpleCat</TT>'s destructor, and
lines 21-24 contain its definition.<BR>
In line 29, <TT>Frisky</TT> is created on the stack, which causes the constructor
to be called. In line 31, the <TT>SimpleCat</TT> pointed to by <TT>pRags</TT> is
created on the heap; the constructor is called again. In line 33, delete is called
on <TT>pRags</TT>, and the destructor is called. When the function ends, <TT>Frisky</TT>
goes out of scope, and the destructor is called.
<H3 ALIGN="CENTER"><A NAME="Heading30"></A><FONT COLOR="#000077">Accessing Data Members</FONT></H3>
<P>You accessed data members and functions by using the dot (<TT>.</TT>) operator
for <TT>Cat</TT> objects created locally. To access the <TT>Cat</TT> object on the
free store, you must dereference the pointer and call the dot operator on the object
pointed to by the pointer. Therefore, to access the <TT>GetAge</TT> member function,
you would write</P>
<PRE><FONT COLOR="#0066FF"> (*pRags).GetAge();
</FONT></PRE>
<P>Parentheses are used to assure that <TT>pRags</TT> is dereferenced before <TT>GetAge()</TT>
is accessed.</P>
<P>Because this is cumbersome, C++ provides a shorthand operator for indirect access:
the <TT>points-to</TT> operator (<TT>-&gt;</TT>), which is created by typing the
dash (<TT>-</TT>) immediately followed by the greater-than symbol (<TT>&gt;</TT>).
C++ treats this as a single symbol. Listing 8.6 demonstrates accessing member variables
and functions of objects created on the free store.</P>
<P><A NAME="Heading31"></A><FONT SIZE="4" COLOR="#000077"><B>Listing 8.6. Accessing
member data of objects on the free store.</B></FONT></P>
<PRE><FONT COLOR="#0066FF">
1:     // Listing 8.6
2:     // Accessing data members of objects on the heap
3:
4:      #include &lt;iostream.h&gt;
5:
6:      class SimpleCat
7:      {
8:      public:
9:             SimpleCat() {itsAge = 2; }
10:             ~SimpleCat() {}
11:             int GetAge() const { return itsAge; }
12:             void SetAge(int age) { itsAge = age; }
13:     private:
14:             int itsAge;
15:        };
16:
17:        int main()
18:        {
19:               SimpleCat * Frisky = new SimpleCat;
20:               cout &lt;&lt; &quot;Frisky is &quot; &lt;&lt; Frisky-&gt;GetAge() &lt;&lt; &quot; years old\n&quot;;
21:               Frisky-&gt;SetAge(5);
22:               cout &lt;&lt; &quot;Frisky is &quot; &lt;&lt; Frisky-&gt;GetAge() &lt;&lt; &quot; years old\n&quot;;
23:               delete Frisky;
24:        return 0;
<TT>25: }</TT></FONT>
<FONT COLOR="#0066FF">
Output: Frisky is 2 years old
Frisky is 5 years old
</FONT></PRE>
<P><FONT COLOR="#000077"><B>Analysis:</B></FONT><B> </B>In line 19, a <TT>SimpleCat</TT>
object is instantiated on the free store. The default constructor sets its age to
<TT>2</TT>, and the <TT>GetAge()</TT> method is called in line 20. Because this is
a pointer, the indirection operator (<TT>-&gt;</TT>) is used to access the member
data and functions. In line 21, the <TT>SetAge()</TT> method is called, and <TT>GetAge()</TT>
is accessed again in line 22.
<H3 ALIGN="CENTER"><A NAME="Heading33"></A><FONT COLOR="#000077">Member Data on the
Free Store</FONT></H3>
<P>One or more of the data members of a class can be a pointer to an object on the
free store. The memory can be allocated in the class constructor or in one of its
methods, and it can be deleted in its destructor, as Listing 8.7 illustrates.</P>
<P><A NAME="Heading34"></A><FONT SIZE="4" COLOR="#000077"><B>Listing 8.7. Pointers
as member data.</B></FONT></P>
<PRE><FONT COLOR="#0066FF">1:  // Listing 8.7
2:  // Pointers as data members
3:
4:    #include &lt;iostream.h&gt;
5:
6:    class SimpleCat
7:    {
8:    public:
9:            SimpleCat();
10:            ~SimpleCat();
11:            int GetAge() const { return *itsAge; }
12:            void SetAge(int age) { *itsAge = age; }
13:
14:            int GetWeight() const { return *itsWeight; }
15:            void setWeight (int weight) { *itsWeight = weight; }
16:
17:    private:
18:            int * itsAge;
19:            int * itsWeight;
20:       };
21:
22:       SimpleCat::SimpleCat()
23:       {
24:            itsAge = new int(2);
25:            itsWeight = new int(5);
26:       }
27:
28:       SimpleCat::~SimpleCat()
29:       {
30:            delete itsAge;
31:            delete itsWeight;
32:       }
33:
34:       int main()
35:       {
36:              SimpleCat *Frisky = new SimpleCat;
37:              cout &lt;&lt; &quot;Frisky is &quot; &lt;&lt; Frisky-&gt;GetAge() &lt;&lt; &quot; years old\n&quot;;
38:              Frisky-&gt;SetAge(5);
39:              cout &lt;&lt; &quot;Frisky is &quot; &lt;&lt; Frisky-&gt;GetAge() &lt;&lt; &quot; years old\n&quot;;
40:              delete Frisky;
41:       return 0;
<TT>42: }</TT></FONT>
<FONT COLOR="#0066FF">
Output: Frisky is 2 years old
Frisky is 5 years old
</FONT></PRE>
<P><FONT COLOR="#000077"><B>Analysis:</B></FONT><B> </B>The class <TT>SimpleCat</TT>
is declared to have two member variables--both of which are pointers to integers--on
lines 14 and 15. The constructor (lines 22-26) initializes the pointers to memory
on the free store and to the default values.<BR>
The destructor (lines 28-32) cleans up the allocated memory. Because this is the
destructor, there is no point in assigning these pointers to <TT>null</TT>, as they
will no longer be accessible. This is one of the safe places to break the rule that
deleted pointers should be assigned to <TT>null</TT>, although following the rule
doesn't hurt.</P>
<P>The calling function (in this case, <TT>main()</TT>) is unaware that <TT>itsAge</TT>
and <TT>itsWeight</TT> are point-ers to memory on the free store. <TT>main()</TT>
continues to call <TT>GetAge()</TT> and <TT>SetAge()</TT>, and the details of the
memory management are hidden in the implementation of the class--as they should be.</P>
<P>When <TT>Frisky</TT> is deleted in line 40, its destructor is called. The destructor
deletes each of its member pointers. If these, in turn, point to objects of other
user-defined classes, their destructors are called as well.
<H3 ALIGN="CENTER"><A NAME="Heading36"></A><FONT COLOR="#000077">The this Pointer</FONT></H3>
<P>Every class member function has a hidden parameter: the <TT>this</TT> pointer.
<TT>this</TT> points to the individual object. Therefore, in each call to <TT>GetAge()</TT>
or <TT>SetAge()</TT>, the <TT>this</TT> pointer for the object is included as a hidden
parameter.</P>
<P>It is possible to use the <TT>this</TT> pointer explicitly, as Listing 8.8 illustrates.</P>
<P><A NAME="Heading37"></A><FONT SIZE="4" COLOR="#000077"><B>Listing 8.8. Using the
this pointer.</B></FONT></P>
<PRE><FONT COLOR="#0066FF">
1:      // Listing 8.8
2:      // Using the this pointer
3:
4:      #include &lt;iostream.h&gt;
5:
6:      class Rectangle
7:      {
8:      public:
9:           Rectangle();
10:           ~Rectangle();
11:           void SetLength(int length) { this-&gt;itsLength = length; }
12:           int GetLength() const { return this-&gt;itsLength; }
13:
14:           void SetWidth(int width) { itsWidth = width; }
15:           int GetWidth() const { return itsWidth; }
16:
17:      private:
18:           int itsLength;
19:           int itsWidth;
20:      };
21:
22:      Rectangle::Rectangle()
23:      {
24:          itsWidth = 5;
25:          itsLength = 10;
26:      }
27:      Rectangle::~Rectangle()
28:      {}
29:
30:      int main()
31:      {
32:           Rectangle theRect;
33:           cout &lt;&lt; &quot;theRect is &quot; &lt;&lt; theRect.GetLength() &lt;&lt; &quot; feet long.\n&quot;;
34:           cout &lt;&lt; &quot;theRect is &quot; &lt;&lt; theRect.GetWidth() &lt;&lt; &quot; feet wide.\n&quot;;
35:           theRect.SetLength(20);
36:           theRect.SetWidth(10);
37:           cout &lt;&lt; &quot;theRect is &quot; &lt;&lt; theRect.GetLength()&lt;&lt; &quot; feet long.\n&quot;;
38:           cout &lt;&lt; &quot;theRect is &quot; &lt;&lt; theRect.GetWidth()&lt;&lt; &quot; feet wide.\n&quot;;
39:      return 0;
<TT>40: }</TT></FONT>
<FONT COLOR="#0066FF">
Output: theRect is 10 feet long.
theRect is 5 feet long.
theRect is 20 feet long.
theRect is 10 feet long.
</FONT></PRE>
<P><FONT COLOR="#000077"><B>Analysis: </B></FONT>The <TT>SetLength()</TT> and <TT>GetLength()</TT>
accessor functions explicitly use the <TT>this</TT> pointer to access the member
variables of the <TT>Rectangle</TT> object. The <TT>SetWidth</TT> and <TT>GetWidth</TT>
accessors do not. There is no difference in their behavior, although the syntax is
easier to understand.<BR>
If that were all there was to the <TT>this</TT> pointer, there would be little point
in bothering you with it. The <TT>this</TT> pointer, however, is a pointer; it stores
the memory address of an object. As such, it can be a powerful tool.</P>
<P>You'll see a practical use for the <TT>this</TT> pointer on Day 10, &quot;Advanced
Functions,&quot; when operator overloading is discussed. For now, your goal is to
know about the <TT>this</TT> pointer and to understand what it is: a pointer to the
object itself.</P>
<P>You don't have to worry about creating or deleting the <TT>this</TT> pointer.
The compiler takes care of that.
<H3 ALIGN="CENTER"><A NAME="Heading39"></A><FONT COLOR="#000077">Stray or Dangling
Pointers</FONT></H3>
<P>One source of bugs that are nasty and difficult to find is stray pointers. A stray
pointer is created when you call <TT>delete</TT> on a pointer--thereby freeing the
memory that it points to--and later try to use that pointer again without reassigning
it.</P>
<P>It is as though the Acme Mail Order company moved away, and you still pressed
the programmed button on your phone. It is possible that nothing terrible happens--a
telephone rings in a deserted warehouse. Perhaps the telephone number has been reassigned
to a munitions factory, and your call detonates an explosive and blows up your whole
city!</P>
<P>In short, be careful not to use a pointer after you have called <TT>delete</TT>
on it. The pointer still points to the old area of memory, but the compiler is free
to put other data there; using the pointer can cause your program to crash. Worse,
your program might proceed merrily on its way and crash several minutes later. This
is called a time bomb, and it is no fun. To be safe, after you delete a pointer,
set it to <TT>null</TT> (<TT>0</TT>). This disarms the pointer.


<BLOCKQUOTE>
	<P>
<HR>
<FONT COLOR="#000077"><B>NOTE:</B></FONT><B> </B>Stray pointers are often called
	wild pointers or dangling pointers. 
<HR>


</BLOCKQUOTE>

<P>Listing 8.9 illustrates creating a stray pointer.


<BLOCKQUOTE>
	<P>
<HR>
<FONT COLOR="#000077"><B>WARNING:</B></FONT><B> </B>This program intentionally creates
	a stray pointer. Do NOT run this program--it will crash, if you are lucky. 
<HR>


</BLOCKQUOTE>

<P><A NAME="Heading40"></A><FONT SIZE="4" COLOR="#000077"><B>Listing 8.9. Creating
a stray pointer.</B></FONT></P>
<PRE><FONT COLOR="#0066FF">
1:     // Listing 8.9
2:     // Demonstrates a stray pointer
3:     typedef unsigned short int USHORT;
4:     #include &lt;iostream.h&gt;
5:
6:     int main()
7:     {
8:        USHORT * pInt = new USHORT;
9:        *pInt = 10;
10:       cout &lt;&lt; &quot;*pInt: &quot; &lt;&lt; *pInt &lt;&lt; endl;
11:       delete pInt;
12:       pInt = 0;
13:       long * pLong = new long;
14:       *pLong = 90000;
15:       cout &lt;&lt; &quot;*pLong: &quot; &lt;&lt; *pLong &lt;&lt; endl;
16:
17:       *pInt = 20;      // uh oh, this was deleted!
18:
19:       cout &lt;&lt; &quot;*pInt: &quot; &lt;&lt; *pInt  &lt;&lt; endl;
20:       cout &lt;&lt; &quot;*pLong: &quot; &lt;&lt; *pLong  &lt;&lt; endl;
21:       delete pLong;
22:    return 0;
<TT>23: }</TT></FONT>
<FONT COLOR="#0066FF">
Output: *pInt:   10
*pLong:  90000
*pInt:   20
*pLong:  65556
Null pointer assignment
</FONT></PRE>
<P>(Your output may look different.)</P>
<P><FONT COLOR="#000077"><B>Analysis: </B></FONT>Line 8 declares <TT>pInt</TT> to
be a pointer to <TT>USHORT</TT>, and <TT>pInt</TT> is pointed to newly allocated
memory. Line 9 puts the value <TT>10</TT> in that memory, and line 10 prints its
value. After the value is printed, <TT>delete</TT> is called on the pointer. <TT>pInt</TT>
is now a stray, or dangling, pointer.<BR>
Line 13 declares a new pointer, <TT>pLong</TT>, which is pointed at the memory allocated
by <TT>new</TT>. <BR>
<BR>
Line 14 assigns the value <TT>90000</TT> to <TT>pLong</TT>, and line 15 prints its
value.</P>
<P>Line 17 assigns the value <TT>20</TT> to the memory that <TT>pInt</TT> points
to, but <TT>pInt</TT> no longer points anywhere that is valid. The memory that <TT>pInt</TT>
points to was freed by the call to <TT>delete</TT>, so assigning a value to that
memory is certain disaster.</P>
<P>Line 19 prints the value at <TT>pInt</TT>. Sure enough, it is <TT>20</TT>. Line
20 prints <TT>20</TT>, the value at <TT>pLong</TT>; it has suddenly been changed
to <TT>65556</TT>. Two questions arise:<BR>
<BR>
<B>1.</B> How could <TT>pLong</TT>'s value change, given that <TT>pLong</TT> wasn't
touched?<BR>
<BR>
<B>2</B>. Where did the 20 go when <TT>pInt</TT> was used in line 17?<BR>
<BR>
As you might guess, these are related questions. When a value was placed at <TT>pInt</TT>
in line 17, the compiler happily placed the value <TT>20</TT> at the memory location
that <TT>pInt</TT> previously pointed to. However, because that memory was freed
in line 11, the compiler was free to reassign it. When <TT>pLong</TT> was created
in line 13, it was given <TT>pInt</TT>'s old memory location. (On some computers
this may not happen, depending on where in memory these values are stored.) When
the value <TT>20</TT> was assigned to the location that <TT>pInt</TT> previously
pointed to, it wrote over the value pointed to by <TT>pLong</TT>. This is called
&quot;stomping on a pointer.&quot; It is often the unfortunate outcome of using a
stray pointer.<BR>
This is a particularly nasty bug, because the value that changed wasn't associated
with the stray pointer. The change to the value at <TT>pLong</TT> was a side effect
of the misuse of <TT>pInt</TT>. In a large program, this would be very difficult
to track down. <BR>
<BR>
Just for fun, here are the details of how 65,556 got into that memory address:

<DL>
	<DD><B>1.</B> <TT>pInt</TT> was pointed at a particular memory location, and the
	value <TT>10</TT> was assigned.<BR>
	<BR>
	<B>2.</B> <TT>delete</TT> was called on <TT>pInt</TT>, which told the compiler that
	it could put something else at that location. Then <TT>pLong</TT> was assigned the
	same memory location.<BR>
	<BR>
	<B>3.</B> The value <TT>90000</TT> was assigned to <TT>*pLong</TT>. The particular
	computer used in this example stored the four-byte value of 90,000 (00 01 5F 90)
	in byte-swapped order. Therefore, it was stored as 5F 90 00 01.<BR>
	<BR>
	<B>4.</B> <TT>pInt</TT> was assigned the value <TT>20</TT>--or 00 14 in hexadecimal
	notation. Because <TT>pInt</TT> still pointed to the same address, the first two
	bytes of <TT>pLong</TT> were overwritten, leaving 00 14 00 01.<BR>
	<BR>
	<B>5.</B> The value at <TT>pLong</TT> was printed, reversing the bytes back to their
	correct order of 00 01 00 14, which was translated into the DOS value of <TT>65556</TT>.<BR>
	<BR>
	
<HR>
<B>DO</B> use <TT>new</TT> to create objects on the free store.<B> DO</B> use <TT>delete</TT>
	to destroy objects on the free store and to return their memory. <B>DON'T</B> forget
	to balance all <TT>new</TT> statements with a <TT>delete</TT> statement. <B>DON'T</B>
	forget to assign <TT>null</TT> (<TT>0</TT>) to all pointers that you call <TT>delete</TT>
	on. <B>DO</B> check the value returned by <TT>new</TT>. 
<HR>

</DL>

<H3 ALIGN="CENTER"><A NAME="Heading42"></A><FONT COLOR="#000077">const Pointers</FONT></H3>
<P>You can use the keyword <TT>const</TT> for pointers before the type, after the
type, or in both places. For example, all of the following are legal declarations:</P>
<PRE><FONT COLOR="#0066FF">
const int * pOne;
int * const pTwo;
const int * const pThree;
</FONT></PRE>
<P><TT>pOne</TT> is a pointer to a constant integer. The value that is pointed to
can't be changed.</P>
<P><TT>pTwo</TT> is a constant pointer to an integer. The integer can be changed,
but <TT>pTwo</TT> can't point to anything else.</P>
<P><TT>pThree</TT> is a constant pointer to a constant integer. The value that is
pointed to can't be changed, and <TT>pThree</TT> can't be changed to point to anything
else.</P>
<P>The trick to keeping this straight is to look to the right of the keyword <TT>const</TT>
to find out what is being declared constant. If the type is to the right of the keyword,
it is the value that is constant. If the variable is to the right of the keyword
<TT>const</TT>, it is the pointer variable itself that is constant.</P>
<PRE><FONT COLOR="#0066FF">const int * p1;  // the int pointed to is constant
int * const p2;  // p2 is constant, it can't point to anything else
</FONT></PRE>
<H4 ALIGN="CENTER"><A NAME="Heading43"></A><FONT COLOR="#000077">const Pointers and
const Member Functions</FONT></H4>
<P>On Day 6, &quot;Basic Classes,&quot; you learned that you can apply the keyword
<TT>const</TT> to a member function. When a function is declared <TT>const</TT>,
the compiler flags as an error any attempt to change data in the object from within
that function.</P>
<P>If you declare a pointer to a <TT>const</TT> object, the only methods that you
can call with that pointer are <TT>const</TT> methods. Listing 8.10 illustrates this.</P>
<P><A NAME="Heading44"></A><FONT SIZE="4" COLOR="#000077"><B>Listing 8.10. Using
pointers to const objects.</B></FONT></P>
<PRE><FONT COLOR="#0066FF">
1:      // Listing 8.10
2:      // Using pointers with const methods
3:
4:      #include &lt;iostream.h&gt;
5:
6:      class Rectangle
7:      {
8:      public:
9:           Rectangle();
10:           ~Rectangle();
11:           void SetLength(int length) { itsLength = length; }
12:           int GetLength() const { return itsLength; }
13:
14:           void SetWidth(int width) { itsWidth = width; }
15:           int GetWidth() const { return itsWidth; }
16:
17:      private:
18:           int itsLength;
19:           int itsWidth;
20:      };
21:
22:      Rectangle::Rectangle():
23:      itsWidth(5),
24:      itsLength(10)
25:      {}
26:
27:      Rectangle::~Rectangle()
28:      {}
29:
30:      int main()
31:      {
32:           Rectangle* pRect =  new Rectangle;
33:           const Rectangle * pConstRect = new Rectangle;
34:           Rectangle * const pConstPtr = new Rectangle;
35:
36:           cout &lt;&lt; &quot;pRect width: &quot; &lt;&lt; pRect-&gt;GetWidth() &lt;&lt; &quot; feet\n&quot;;
37:           cout &lt;&lt; &quot;pConstRect width: &quot; &lt;&lt; pConstRect-&gt;GetWidth() &lt;&lt; &quot; feet\n&quot;;
38:           cout &lt;&lt; &quot;pConstPtr width: &quot; &lt;&lt; pConstPtr-&gt;GetWidth() &lt;&lt; &quot; feet\n&quot;;
39:
40:           pRect-&gt;SetWidth(10);
41:           // pConstRect-&gt;SetWidth(10);
42:           pConstPtr-&gt;SetWidth(10);
43:
44:           cout &lt;&lt; &quot;pRect width: &quot; &lt;&lt; pRect-&gt;GetWidth() &lt;&lt; &quot; feet\n&quot;;
45:           cout &lt;&lt; &quot;pConstRect width: &quot; &lt;&lt; pConstRect-&gt;GetWidth() &lt;&lt; &quot; feet\n&quot;;
46:           cout &lt;&lt; &quot;pConstPtr width: &quot; &lt;&lt; pConstPtr-&gt;GetWidth() &lt;&lt; &quot; feet\n&quot;;
47:      return 0;
<TT>48: }</TT></FONT>
<FONT COLOR="#0066FF">
Output: pRect width: 5 feet
pConstRect width: 5 feet
pConstPtr width: 5 feet
pRect width: 10 feet
pConstRect width: 5 feet
pConstPtr width: 10 feet
</FONT></PRE>
<P><FONT COLOR="#000077"><B>Analysis: </B></FONT>Lines 6-20 declare <TT>Rectangle</TT>.
Line 15 declares the <TT>GetWidth()</TT> member method <TT>const</TT>. Line 32 declares
a pointer to <TT>Rectangle</TT>. Line 33 declares <TT>pConstRect</TT>, which is a
pointer to a constant <TT>Rectangle</TT>. Line 34 declares <TT>pConstPtr</TT>, which
is a constant pointer to <TT>Rectangle</TT>.<BR>
Lines 36-38 print their values.</P>
<P>In line 40, <TT>pRect</TT> is used to set the width of the rectangle to <TT>10</TT>.
In line 41, <TT>pConstRect</TT> would be used, but it was declared to point to a
constant <TT>Rectangle</TT>. Therefore, it cannot legally call a non-<TT>const</TT>
member function; it is commented out. In line 38, <TT>pConstPtr</TT> calls <TT>SetAge()</TT>.
<TT>pConstPtr</TT> is declared to be a constant pointer to a rectangle. In other
words, the pointer is constant and cannot point to anything else, but the rectangle
is not constant.
<H4 ALIGN="CENTER"><A NAME="Heading46"></A><FONT COLOR="#000077">const this Pointers</FONT></H4>
<P>When you declare an object to be <TT>const</TT>, you are in effect declaring that
the <TT>this</TT> pointer is a pointer to a <TT>const</TT> object. A <TT>const</TT>
<TT>this</TT> pointer can be used only with <TT>const</TT> mem- ber functions.</P>
<P>Constant objects and constant pointers will be discussed again tomorrow, when
references to constant objects are discussed.


<BLOCKQUOTE>
	<P>
<HR>
<B>DO</B> protect objects passed by reference with <TT>const</TT> if they should
	not be changed. <B>DO </B>pass by reference when the object can be changed.<B> DO</B>
	pass by value when small objects should not be changed. 
<HR>


</BLOCKQUOTE>

<H3 ALIGN="CENTER"><A NAME="Heading47"></A><FONT COLOR="#000077">Summary</FONT></H3>
<P>Pointers provide a powerful way to access data by indirection. Every variable
has an address, which can be obtained using the <TT>address of</TT> operator (<TT>&amp;</TT>).
The address can be stored in a pointer.</P>
<P>Pointers are declared by writing the type of object that they point to, followed
by the indirection operator (<TT>*</TT>) and the name of the pointer. Pointers should
be initialized to point to an object or to <TT>null</TT> (<TT>0</TT>).</P>
<P>You access the value at the address stored in a pointer by using the indirection
operator (<TT>*</TT>). You can declare <TT>const</TT> pointers, which can't be reassigned
to point to other objects, and pointers to <TT>const</TT> objects, which can't be
used to change the objects to which they point.</P>
<P>To create new objects on the free store, you use the <TT>new</TT> keyword and
assign the address that is returned to a pointer. You free that memory by calling
the <TT>delete</TT> keyword on the pointer. <TT>delete</TT> frees the memory, but
it doesn't destroy the pointer. Therefore, you must reassign the pointer after its
memory has been freed.
<H3 ALIGN="CENTER"><A NAME="Heading48"></A><FONT COLOR="#000077">Q&amp;A</FONT></H3>

<DL>
	<DD><B>Q. Why are pointers so important?<BR>
	</B><BR>
	<B>A.</B> Today you saw how pointers are used to hold the address of objects on the
	free store and how they are used to pass arguments by reference. In addition, on
	Day 13, &quot;Polymorphism,&quot; you'll see how pointers are used in class polymorphism.<BR>
	<BR>
	<B>Q. Why should I bother to declare anything on the free store?<BR>
	</B><BR>
	<B>A.</B> Objects on the free store persist after the return of a function. Additionally,
	the ability to store objects on the free store enables you to decide at runtime how
	many objects you need, instead of having to declare this in advance. This is explored
	in greater depth tomorrow.<BR>
	<BR>
	<B>Q. Why should I declare an object const if it limits what I can do with it?<BR>
	</B><BR>
	<B>A.</B> As a programmer, you want to enlist the compiler in helping you find bugs.
	One serious bug that is difficult to find is a function that changes an object in
	ways that aren't obvious to the calling function. Declaring an object <TT>const</TT>
	prevents such changes.
</DL>

<H3 ALIGN="CENTER"><A NAME="Heading49"></A><FONT COLOR="#000077">Workshop</FONT></H3>
<P>The Workshop provides quiz questions to help you solidify your understanding of
the material covered and exercises to provide you with experience in using what you've
learned. Try to answer the quiz and exercise questions before checking the answers
in Appendix D, and make sure you understand the answers before continuing to the
next chapter.
<H4 ALIGN="CENTER"><A NAME="Heading50"></A><FONT COLOR="#000077">Quiz</FONT></H4>

<DL>
	<DD><B>1.</B> What operator is used to determine the address of a variable?<BR>
	<BR>
	<B>2.</B> What operator is used to find the value stored at an address held in a
	pointer?<BR>
	<BR>
	<B>3.</B> What is a pointer?<BR>
	<BR>
	<B>4.</B> What is the difference between the address stored in a pointer and the
	value at that address?<BR>
	<BR>
	<B>5.</B> What is the difference between the indirection operator and the <TT>address
	of</TT> operator?<BR>
	<BR>
	<B>6.</B> What is the difference between <TT>const int * ptrOne</TT> and <TT>int
	* const ptrTwo</TT>?
</DL>

<H4 ALIGN="CENTER"><A NAME="Heading51"></A><FONT COLOR="#000077">Exercises</FONT></H4>

<DL>
	<DD><B>1.</B> What do these declarations do?
	<DL>
		<DD><B><BR>
		a.</B> <TT>int * pOne;</TT>
	</DL>
	<DD>
	<DL>
		<DD><B>b.</B> <TT>int vTwo;</TT>
	</DL>
	<DD>
	<DL>
		<DD><B>c.</B> <TT>int * pThree = &amp;vTwo;</TT>
	</DL>
	<DD><BR>
	<B>2.</B> If you have an <TT>unsigned short</TT> variable named <TT>yourAge</TT>,
	how would you declare a pointer to manipulate <TT>yourAge</TT>?<BR>
	<BR>
	<B>3.</B> Assign the value <TT>50</TT> to the variable <TT>yourAge</TT> by using
	the pointer that you declared in Exercise 2.<BR>
	<BR>
	<B>4.</B> Write a small program that declares an integer and a pointer to integer.
	Assign the address of the integer to the pointer. Use the pointer to set a value
	in the integer variable.<BR>
	<BR>
	<B>5.</B> BUG BUSTERS: What is wrong with this code?
</DL>

<PRE><FONT COLOR="#0066FF">#include &lt;iostream.h&gt;
int main()
{      int *pInt;
     *pInt = 9;
     cout &lt;&lt; &quot;The value at pInt: &quot; &lt;&lt; *pInt;
     return 0;
}
</FONT></PRE>

<DL>
	<DD><B>6.</B> BUG BUSTERS: What is wrong with this code?
</DL>

<PRE><FONT COLOR="#0066FF">int main()
{
    int SomeVariable = 5;
    cout &lt;&lt; &quot;SomeVariable: &quot; &lt;&lt; SomeVariable &lt;&lt; &quot;\n&quot;;
    int *pVar = &amp; SomeVariable;
    pVar = 9;
    cout &lt;&lt; &quot;SomeVariable: &quot; &lt;&lt; *pVar &lt;&lt; &quot;\n&quot;;
return 0;
}
</FONT></PRE>
<P ALIGN="CENTER"><A HREF="ch07rv1.htm"><IMG SRC="../buttons/BLANPREV.GIF"
WIDTH="37" HEIGHT="37" ALIGN="BOTTOM" BORDER="0"></A><A HREF="http://www.mcp.com/sams"><IMG
SRC="../buttons/BLANHOME.GIF" WIDTH="37" HEIGHT="37" ALIGN="BOTTOM"
BORDER="0"></A><A HREF="../index.htm"><IMG SRC="../buttons/BLANTOC.GIF"
WIDTH="37" HEIGHT="37" ALIGN="BOTTOM" BORDER="0"></A><A HREF="ch09.htm"><IMG SRC="../buttons/BLANNEXT.GIF"
WIDTH="37" HEIGHT="37" ALIGN="BOTTOM" BORDER="0"></A><A HREF="#heading1"><IMG SRC="../buttons/BLANTOP.GIF"
WIDTH="37" HEIGHT="37" ALIGN="BOTTOM" BORDER="0"></A>


</BODY>

</HTML>