<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>

<HEAD>
<!-- This document was created from RTF source by rtftohtml version 3.0.1 -->

	<META NAME="GENERATOR" Content="Symantec Visual Page 1.0">
	<META HTTP-EQUIV="Content-Type" CONTENT="text/html;CHARSET=iso-8859-1">
	<TITLE>Teach Yourself C++ in 21 Days</TITLE>
</HEAD>

<BODY TEXT="#000000" BGCOLOR="#FFFFFF">

<H1 ALIGN="CENTER"><A HREF="ch15.htm"><IMG SRC="../buttons/BLANPREV.GIF"
WIDTH="37" HEIGHT="37" ALIGN="BOTTOM" BORDER="0"></A><A HREF="http://www.mcp.com/sams"><IMG
SRC="../buttons/BLANHOME.GIF" WIDTH="37" HEIGHT="37" ALIGN="BOTTOM"
BORDER="0"></A><A HREF="../index.htm"><IMG SRC="../buttons/BLANTOC.GIF"
WIDTH="37" HEIGHT="37" ALIGN="BOTTOM" BORDER="0"></A><A HREF="ch17.htm"><IMG SRC="../buttons/BLANNEXT.GIF"
WIDTH="37" HEIGHT="37" ALIGN="BOTTOM" BORDER="0"></A></H1>
<H1></H1>

<UL>
	<LI><A HREF="#Heading1">Day 16</A>
	<UL>
		<LI><A HREF="#Heading2">Streams</A>
		<UL>
			<LI><A HREF="#Heading3">Overview of Streams</A>
			<UL>
				<LI><A HREF="#Heading4">Encapsulation</A>
				<UL>
					<LI><A HREF="#Heading5">Figure 16.1.</A>
				</UL>
				<LI><A HREF="#Heading6">Buffering</A>
				<UL>
					<LI><A HREF="#Heading7">Figure 16.2.</A>
					<LI><A HREF="#Heading8">Figure 16.3.</A>
					<LI><A HREF="#Heading9">Figure 16.4.</A>
					<LI><A HREF="#Heading10">Figure 16.5.</A>
				</UL>
			</UL>
			<LI><A HREF="#Heading11">Streams and Buffers</A>
			<LI><A HREF="#Heading12">Standard I/O Objects</A>
			<LI><A HREF="#Heading13">Redirection</A>
			<LI><A HREF="#Heading14">Input Using cin</A>
			<LI><A HREF="#Heading15">Listing 16.1. cin handles different data types</A><A HREF="#Heading16">.</A>
			<UL>
				<LI><A HREF="#Heading17">Strings</A>
				<LI><A HREF="#Heading18">String Problems</A>
			</UL>
			<LI><A HREF="#Heading19">Listing 16.2. Trying to write more than one word to cin</A><A
			HREF="#Heading20">.</A>
			<LI><A HREF="#Heading21">Listing 16.3. Multiple input</A><A HREF="#Heading22">.</A>
			<UL>
				<LI><A HREF="#Heading23">operator&gt;&gt; Returns a Reference to an istream Object</A>
			</UL>
			<LI><A HREF="#Heading24">Other Member Functions of cin</A>
			<UL>
				<LI><A HREF="#Heading25">Single Character Input</A>
			</UL>
			<LI><A HREF="#Heading26">Listing 16.4. Using get() with no parameters.</A>
			<LI><A HREF="#Heading27">Listing 16.5 Using get() with parameters.</A>
			<UL>
				<LI><A HREF="#Heading28">Getting Strings from Standard Input</A>
			</UL>
			<LI><A HREF="#Heading29">Listing 16.6. Using get() with a character array</A>
			<LI><A HREF="#Heading30">.</A>
			<LI><A HREF="#Heading31">Listing 16.7. Using getline().</A>
			<UL>
				<LI><A HREF="#Heading32">Using cin.ignore()</A>
			</UL>
			<LI><A HREF="#Heading33">Listing 16.8. Using ignore().</A>
			<UL>
				<LI><A HREF="#Heading34">peek() and putback()</A>
			</UL>
			<LI><A HREF="#Heading35">Listing 16.9. Using peek() and putback().</A>
			<LI><A HREF="#Heading36">Output with cout</A>
			<UL>
				<LI><A HREF="#Heading37">Flushing the Output</A>
			</UL>
			<LI><A HREF="#Heading38">Related Functions</A>
			<LI><A HREF="#Heading39">Listing 16.10. Using put().</A>
			<LI><A HREF="#Heading40">Listing 16.11. Using write().</A>
			<LI><A HREF="#Heading41">Manipulators, Flags, and Formatting Instructions</A>
			<UL>
				<LI><A HREF="#Heading42">Using cout.width()</A>
			</UL>
			<LI><A HREF="#Heading43">Listing 16.12. Adjusting the width of output.</A>
			<UL>
				<LI><A HREF="#Heading44">Setting the Fill Characters</A>
			</UL>
			<LI><A HREF="#Heading45">Listing 16.13. Using fill()</A><A HREF="#Heading46">.</A>
			<UL>
				<LI><A HREF="#Heading47">Set Flags</A>
			</UL>
			<LI><A HREF="#Heading48">Listing 16.14. Using setf.</A>
			<LI><A HREF="#Heading49">Streams Versus the printf() Function</A>
			<LI><A HREF="#Heading50">Listing 16.15. Printing with printf().</A>
			<LI><A HREF="#Heading51">File Input and Output</A>
			<LI><A HREF="#Heading52">ofstream</A>
			<UL>
				<LI><A HREF="#Heading53">Condition States</A>
				<LI><A HREF="#Heading54">Opening Files for Input and Output</A>
			</UL>
			<LI><A HREF="#Heading55">Listing 16.16. Opening files for read and write</A><A HREF="#Heading56">.</A>
			<UL>
				<LI><A HREF="#Heading57">Changing the Default Behavior of ofstream on Open</A>
			</UL>
			<LI><A HREF="#Heading58">Listing 16.17. Appending to the end of a file</A>
			<LI><A HREF="#Heading59">.</A>
			<LI><A HREF="#Heading60">Binary Versus Text Files</A>
			<LI><A HREF="#Heading61">Listing 16.18. Writing a class to a file</A><A HREF="#Heading62">.</A>
			<LI><A HREF="#Heading63">Command-Line Processing</A>
			<LI><A HREF="#Heading64">Listing 16.19. Using command-line arguments</A><A HREF="#Heading65">.</A>
			<LI><A HREF="#Heading66">Listing 16.20. Using command-line arguments.</A>
			<LI><A HREF="#Heading67">Summary</A>
			<LI><A HREF="#Heading68">Q&amp;A</A>
			<LI><A HREF="#Heading69">Workshop</A>
			<UL>
				<LI><A HREF="#Heading70">Quiz</A>
				<LI><A HREF="#Heading71">Exercises</A>
			</UL>
		</UL>
	</UL>
</UL>

<P>
<HR SIZE="4">

<H2 ALIGN="CENTER"><A NAME="Heading1"></A><FONT COLOR="#000077">Day 16</FONT></H2>
<H2 ALIGN="CENTER"><A NAME="Heading2"></A><FONT COLOR="#000077">Streams</FONT></H2>
<P>Until now, you've been using <TT>cout</TT> to write to the screen and <TT>cin</TT>
to read from the keyboard, without a full understanding of how they work. Today,
you will learn

<UL>
	<LI>What streams are and how they are used.
	<P>
	<LI>How to manage input and output using streams.
	<P>
	<LI>How to write to and read from files using streams.
</UL>

<H3 ALIGN="CENTER"><A NAME="Heading3"></A><FONT COLOR="#000077">Overview of Streams</FONT></H3>
<P>C++ does not, as part of the language, define how data is written to the screen
or to a file, nor how data is read into a program. These are clearly essential parts
of working with C++, however, and the standard C++ library now includes the <TT>iostream</TT>
library, which facilitates input and output (I/O).</P>
<P>The advantage of having the input and output kept apart from the language and
handled in libraries is that it is easier to make the language &quot;platform-independent.&quot;
That is, you can write C++ programs on a PC and then recompile them and run them
on a Sun Workstation. The compiler manufacturer just supplies the right library,
and everything works. At least that's the theory.


<BLOCKQUOTE>
	<P>
<HR>
<FONT COLOR="#000077"><B>NOTE:</B></FONT><B> </B>A library is a collection of OBJ
	files that can be linked to your program to provide additional functionality. This
	is the most basic form of code reuse, and has been around since ancient programmers
	chiseled 1s and 0s into the walls of caves. 
<HR>


</BLOCKQUOTE>

<H4 ALIGN="CENTER"><A NAME="Heading4"></A><FONT COLOR="#000077">Encapsulation</FONT></H4>
<P>The <TT>iostream</TT> classes view the flow of data from your program to the screen
as being a stream of data, one byte following another. If the destination of the
stream is a file or the screen, the source is usually some part of your program.
If the stream is reversed, the data can come from the keyboard or a disk file and
be &quot;poured&quot; into your data variables.</P>
<P>One principal goal of streams is to encapsulate the problems of getting the data
to and from the disk or the screen. Once a stream is created, your program works
with the stream and the stream sweats the details. Figure 16.1 illustrates this fundamental
idea.<BR>
<BR>
<A NAME="Heading5"></A><A HREF="../art/ch16/16zcp01.jpg"><FONT COLOR="#000077">Figure
16.1.</FONT></A><FONT COLOR="#000077"> </FONT><I>Encapsulation through streams.</I>
<H4 ALIGN="CENTER"><A NAME="Heading6"></A><FONT COLOR="#000077">Buffering</FONT></H4>
<P>Writing to the disk (and to a lesser extent the screen) is very &quot;expensive.&quot;
It takes a long time (relatively speaking) to write data to the disk or to read data
from the disk, and execution of the program is generally blocked by disk writes and
reads. To solve this problem, streams provide &quot;buffering.&quot; Data is written
into the stream, but it is not written back out to the disk immediately. Instead,
the stream's buffer fills and fills, and when it is full it writes to the disk all
at once.</P>
<P>Picture water trickling into the top of a tank, and the tank filling and filling,
but no water running out of the bottom. Figure 16.2 illustrates this idea.</P>
<P>When the water (data) reaches the top, the valve opens and all the water flows
out in a rush. Figure 16.3 illustrates this.</P>
<P>Once the buffer is empty, the bottom valve closes, the top valve opens, and more
water flows into the buffer tank. Figure 16.4 illustrates this.</P>
<P>Every once in a while you need to get the water out of the tank even before it
is full. This is called &quot;flushing the buffer.&quot; Figure 16.5 illustrates
this idea.<BR>
<BR>
<A NAME="Heading7"></A><A HREF="../art/ch16/16zcp02a.jpg"><FONT COLOR="#000077">Figure
16.2.</FONT></A><FONT COLOR="#000077"> </FONT><I>Filling the buffer.</I><BR>
<BR>
<A NAME="Heading8"></A><A HREF="../art/ch16/16zcp02b.jpg"><FONT COLOR="#000077">Figure
16.3.</FONT></A><FONT COLOR="#000077"> </FONT><I>Emptying the buffer</I>.<BR>
<BR>
<A NAME="Heading9"></A><A HREF="../art/ch16/16zcp02c.jpg"><FONT COLOR="#000077">Figure
16.4.</FONT></A><FONT COLOR="#000077"> </FONT><I>Refilling the buffer.</I><BR>
<BR>
<A NAME="Heading10"></A><A HREF="../art/ch16/16zcp02d.jpg"><FONT COLOR="#000077">Figure
16.5.</FONT></A><FONT COLOR="#000077"> </FONT><I>Flushing the buffer.</I>
<H3 ALIGN="CENTER"><A NAME="Heading11"></A><FONT COLOR="#000077">Streams and Buffers</FONT></H3>
<P>As you might expect, C++ takes an object-oriented view toward implementing streams
and buffers.

<UL>
	<LI>The <TT>streambuf</TT> class manages the buffer, and its member functions provide
	the capability to fill, empty, flush, and otherwise manipulate the buffer.
	<P>
	<LI>The <TT>ios</TT> class is the base class to the input and output stream classes.
	The <TT>ios</TT> class has a <TT>streambuf</TT> object as a member variable.
	<P>
	<LI>The <TT>istream</TT> and <TT>ostream</TT> classes derive from the <TT>ios</TT>
	class and specialize input and output stream behavior, respectively.
	<P>
	<LI>The <TT>iostream</TT> class is derived from both the <TT>istream</TT> and the
	<TT>ostream</TT> classes and provides input and output methods for writing to the
	screen.
	<P>
	<LI>The <TT>fstream</TT> classes provide input and output from files.
</UL>

<H3 ALIGN="CENTER"><A NAME="Heading12"></A><FONT COLOR="#000077">Standard I/O Objects</FONT></H3>
<P>When a C++ program that includes the <TT>iostream</TT> classes starts, four objects
are created and initialized:


<BLOCKQUOTE>
	<P>
<HR>
<FONT COLOR="#000077"><B>NOTE:</B></FONT><B> </B>The <TT>iostream</TT> class library
	is added automatically to your program by the compiler. All you need to do to use
	these functions is to put the appropriate <TT>include</TT> statement at the top of
	your program listing. 
<HR>


</BLOCKQUOTE>


<UL>
	<LI><TT>cin</TT> (pronounced &quot;see-in&quot;) handles input from the standard
	input, the keyboard.
	<P>
	<LI><TT>cou</TT> (pronounced &quot;see-out&quot;) handles output to the standard
	output, the screen.
	<P>
	<LI><TT>cer</TT> (pronounced &quot;see-err&quot;) handles unbuffered output to the
	standard error device, the screen. Because this is unbuffered, everything sent to
	<TT>cerr</TT> is written to the standard error device immediately, without waiting
	for the buffer to fill or for a flush command to be received.
	<P>
	<LI><TT>clo</TT> (pronounced &quot;see-log&quot;) handles buffered error messages
	that are output to the standard error device, the screen. It is common for this to
	be &quot;redirected&quot; to a log file, as described in the following section.
</UL>

<H3 ALIGN="CENTER"><A NAME="Heading13"></A><FONT COLOR="#000077">Redirection</FONT></H3>
<P>Each of the standard devices, input, output, and error, can be redirected to other
devices. Standard error is often redirected to a file, and standard input and output
can be piped to files using operating system commands.</P>

<DL>
	<DD>
<HR>
<FONT COLOR="#000077"><B>New Term: </B></FONT><I>Redirecting</I> refers to sending
	output (or input) to a place different than the default. The redirection operators
	for DOS and UNIX are (<TT>&lt;</TT>) redirect input and (<TT>&gt;</TT>) redirect
	output. 
<HR>

</DL>

<P>Piping refers to using the output of one program as the input of another.</P>
<P>DOS provides rudimentary redirection commands, such as redirect output (<TT>&gt;</TT>)
and (<TT>&gt;</TT>)redirect input (<TT>&lt;</TT>). UNIX provides more advanced redirection
capabilities, but the general idea is the same: Take the output intended for the
screen and write it to a file, or pipe it into another program. Alternatively, the
input for a program can be extracted from a file rather than from the keyboard.</P>
<P>Redirection is more a function of the operating system than of the <TT>iostream</TT>
libraries. C++ just provides access to the four standard devices; it is up to the
user to redirect the devices to whatever alternatives are needed.
<H3 ALIGN="CENTER"><A NAME="Heading14"></A><FONT COLOR="#000077">Input Using cin</FONT></H3>
<P>The global object <TT>cin</TT> is responsible for input and is made available
to your program when you include <TT>iostream.h</TT>. In previous examples, you used
the overloaded extraction operator (<TT>&gt;&gt;</TT>) to put data into your program's
variables. How does this work? The syntax, as you may remember, is the following:</P>
<PRE><FONT COLOR="#0066FF">int someVariable;
cout &lt;&lt; &quot;Enter a number: &quot;;
cin &gt;&gt; someVariable;
</FONT></PRE>
<P>The global object <TT>cout</TT> is discussed later today; for now, focus on the
third line, <TT>cin &gt;&gt; someVariable;</TT>. What can you guess about <TT>cin</TT>?</P>
<P>Clearly it must be a global object, because you didn't define it in your own code.
You know from previous operator experience that <TT>cin</TT> has overloaded the extraction
operator (<TT>&gt;&gt;</TT>) and that the effect is to write whatever data <TT>cin</TT>
has in its buffer into your local variable, <TT>someVariable</TT>.</P>
<P>What may not be immediately obvious is that <TT>cin</TT> has overloaded the extraction
operator for a great variety of parameters, among them <TT>int&amp;</TT>, <TT>short&amp;</TT>,
<TT>long&amp;</TT>, <TT>double&amp;</TT>, <TT>float&amp;</TT>, <TT>char&amp;</TT>,
<TT>char*</TT>, and so forth. When you write <TT>cin &gt;&gt; someVariable;</TT>,
the type of <TT>someVariable</TT> is assessed. In the example above, <TT>someVariable</TT>
is an integer, so the following function is called:</P>
<PRE><FONT COLOR="#0066FF">istream &amp; operator&gt;&gt; (int &amp;)
</FONT></PRE>
<P>Note that because the parameter is passed by reference, the extraction operator
is able to act on the original variable. Listing 16.1 illustrates the use of <TT>cin</TT>.</P>
<P><A NAME="Heading15"></A><FONT SIZE="4" COLOR="#000077"><B>Listing 16.1. cin handles
different data types.</B></FONT></P>
<PRE><FONT COLOR="#0066FF">1:     //Listing 16.1 -- character strings and cin
2:
3:     #include &lt;iostream.h&gt;
4:
5:     int main()
6:     {
7:        int myInt;
8:        long myLong;
9:        double myDouble;
10:       float myFloat;
11:       unsigned int myUnsigned;
12:
13:       cout &lt;&lt; &quot;int: &quot;;
14:       cin &gt;&gt; myInt;
15:       cout &lt;&lt; &quot;Long: &quot;;
16:       cin &gt;&gt; myLong;
17:       cout &lt;&lt; &quot;Double: &quot;;
18:       cin &gt;&gt; myDouble;
19:       cout &lt;&lt; &quot;Float: &quot;;
20:       cin &gt;&gt; myFloat;
21:       cout &lt;&lt; &quot;Unsigned: &quot;;
22:       cin &gt;&gt; myUnsigned;
23:
24:       cout &lt;&lt; &quot;\n\nInt:\t&quot; &lt;&lt; myInt &lt;&lt; endl;
25:       cout &lt;&lt; &quot;Long:\t&quot; &lt;&lt; myLong &lt;&lt; endl;
26:       cout &lt;&lt; &quot;Double:\t&quot; &lt;&lt; myDouble &lt;&lt; endl;
27:       cout &lt;&lt; &quot;Float:\t&quot; &lt;&lt; myFloat &lt;&lt; endl;
28:       cout &lt;&lt; &quot;Unsigned:\t&quot; &lt;&lt; myUnsigned &lt;&lt; endl;
29:     return 0;
<TT>30: }</TT></FONT>
<FONT COLOR="#0066FF">
Output: int: 2
Long: 70000
Double: 987654321
Float: 3.33
Unsigned: 25

Int:    2
Long:   70000
Double: 9.87654e+08
Float:  3.33
Unsigned:       25
</FONT></PRE>
<P><FONT COLOR="#000077"><B>Analysis</B></FONT><FONT COLOR="#000000"><B>: </B></FONT>On
lines 7-11, variables of various types are declared. On lines 13-22, the user is
prompted to enter values for these variables, and the results are printed (using
<TT>cout</TT>) on lines 24-28.</P>
<P>The output reflects that the variables were put into the right &quot;kinds&quot;
of variables, and the program works as you might expect.
<H4 ALIGN="CENTER"><A NAME="Heading17"></A><FONT COLOR="#000077">Strings</FONT></H4>
<P><TT>cin</TT> can also handle character pointer (<TT>char*</TT>) arguments; thus,
you can create a character buffer and use <TT>cin</TT> to fill it. For example, you
can write this:</P>
<PRE><FONT COLOR="#0066FF">char YourName[50]
cout &lt;&lt; &quot;Enter your name: &quot;;
cin &gt;&gt; YourName;
</FONT></PRE>
<P>If you enter <TT>Jesse</TT>, the variable <TT>YourName</TT> will be filled with
the characters <TT>J, e, s, s, e, \0</TT>. The last character is a null; <TT>cin</TT>
automatically ends the string with a null character, and you must have enough room
in the buffer to allow for the entire string plus the null. The null signals &quot;end
of string&quot; to the standard library functions discussed on Day 21, &quot;What's
Next.&quot;
<H4 ALIGN="CENTER"><A NAME="Heading18"></A><FONT COLOR="#000077">String Problems</FONT></H4>
<P>After all this success with <TT>cin</TT>, you might be surprised when you try
to enter a full name into a string. <TT>cin</TT> believes that white space is a separator.
When it sees a space or a new line, it assumes the input for the parameter is complete,
and in the case of strings it adds a null character right then and there. Listing
16.2 illustrates this problem.</P>
<P><A NAME="Heading19"></A><FONT SIZE="4" COLOR="#000077"><B>Listing 16.2. Trying
to write more than one word to cin.</B></FONT></P>
<PRE><FONT COLOR="#0066FF">1:     //Listing 16.2 -- character strings and cin
2:
3:     #include &lt;iostream.h&gt;
4:
5:     int main()
6:     {
7:        char YourName[50];
8:        cout &lt;&lt; &quot;Your first name: &quot;;
9:        cin &gt;&gt; YourName;
10:       cout &lt;&lt; &quot;Here it is: &quot; &lt;&lt; YourName &lt;&lt; endl;
11:       cout &lt;&lt; &quot;Your entire name: &quot;;
12:       cin &gt;&gt; YourName;
13:       cout &lt;&lt; &quot;Here it is: &quot; &lt;&lt; YourName &lt;&lt; endl;
14:     return 0;
<TT>15: }</TT></FONT>
<FONT COLOR="#0066FF">
Output: Your first name: Jesse
Here it is: Jesse
Your entire name: Jesse Liberty
Here it is: Jesse
</FONT></PRE>
<P><FONT COLOR="#000077"><B>Analysis</B></FONT><B>: </B>On line 7, a character array
is created to hold the user's input. On line 8, the user is prompted to enter one
name, and that name is stored properly, as shown in the output.</P>
<P>On line 11, the user is again prompted, this time for a full name. <TT>cin</TT>
reads the input, and when it sees the space between the names, it puts a null character
after the first word and terminates input. This is not exactly what was intended.</P>
<P>To understand why this works this way, examine Listing 16.3, which shows input
for a number of fields.</P>
<P><A NAME="Heading21"></A><FONT SIZE="4" COLOR="#000077"><B>Listing 16.3. Multiple
input.</B></FONT></P>
<PRE><FONT COLOR="#0066FF">1:     //Listing 16.3 - character strings and cin
2:
3:     #include &lt;iostream.h&gt;
4:
5:     int main()
6:     {
7:        int myInt;
8:        long myLong;
9:        double myDouble;
10:       float myFloat;
11:       unsigned int myUnsigned;
12:       char myWord[50];
13:
14:       cout &lt;&lt; &quot;int: &quot;;
15:       cin &gt;&gt; myInt;
16:       cout &lt;&lt; &quot;Long: &quot;;
17:       cin &gt;&gt; myLong;
18:       cout &lt;&lt; &quot;Double: &quot;;
19:       cin &gt;&gt; myDouble;
20:       cout &lt;&lt; &quot;Float: &quot;;
21:       cin &gt;&gt; myFloat;
22:       cout &lt;&lt; &quot;Word: &quot;;
23:       cin &gt;&gt; myWord;
24:       cout &lt;&lt; &quot;Unsigned: &quot;;
25:       cin &gt;&gt; myUnsigned;
26:
27:       cout &lt;&lt; &quot;\n\nInt:\t&quot; &lt;&lt; myInt &lt;&lt; endl;
28:       cout &lt;&lt; &quot;Long:\t&quot; &lt;&lt; myLong &lt;&lt; endl;
29:       cout &lt;&lt; &quot;Double:\t&quot; &lt;&lt; myDouble &lt;&lt; endl;
30:       cout &lt;&lt; &quot;Float:\t&quot; &lt;&lt; myFloat &lt;&lt; endl;
31:       cout &lt;&lt; &quot;Word: \t&quot; &lt;&lt; myWord &lt;&lt; endl;
32:       cout &lt;&lt; &quot;Unsigned:\t&quot; &lt;&lt; myUnsigned &lt;&lt; endl;
33:
34:       cout &lt;&lt; &quot;\n\nInt, Long, Double, Float, Word, Unsigned: &quot;;
35:       cin &gt;&gt; myInt &gt;&gt; myLong &gt;&gt; myDouble;
36:       cin &gt;&gt; myFloat &gt;&gt; myWord &gt;&gt; myUnsigned;
37:       cout &lt;&lt; &quot;\n\nInt:\t&quot; &lt;&lt; myInt &lt;&lt; endl;
38:       cout &lt;&lt; &quot;Long:\t&quot; &lt;&lt; myLong &lt;&lt; endl;
39:       cout &lt;&lt; &quot;Double:\t&quot; &lt;&lt; myDouble &lt;&lt; endl;
40:       cout &lt;&lt; &quot;Float:\t&quot; &lt;&lt; myFloat &lt;&lt; endl;
41:       cout &lt;&lt; &quot;Word: \t&quot; &lt;&lt; myWord &lt;&lt; endl;
42:       cout &lt;&lt; &quot;Unsigned:\t&quot; &lt;&lt; myUnsigned &lt;&lt; endl;
43:
44:
45:     return 0;
<TT>46: }</TT></FONT>
<FONT COLOR="#0066FF">
Output: Int: 2
Long: 30303
Double: 393939397834
Float: 3.33
Word: Hello
Unsigned: 85

Int:    2
Long:   30303
Double: 3.93939e+11
Float:  3.33
Word:   Hello
Unsigned:       85

Int, Long, Double, Float, Word, Unsigned: 3 304938 393847473 6.66 bye -2

Int:    3
Long:   304938
Double: 3.93847e+08
Float:  6.66
Word:   bye
</FONT></PRE>
<PRE><FONT COLOR="#0066FF">
Unsigned:       65534
</FONT></PRE>
<P><FONT COLOR="#000077"><B>Analysis</B></FONT><FONT COLOR="#000000"><B>:</B></FONT><B>
</B>Once again, a number of variables are created, this time including a <TT>char</TT>
array. The user is prompted for input and the output is faithfully printed.</P>
<P>On line 34, the user is prompted for all the input at once, and then each &quot;word&quot;
of input is assigned to the appropriate variable. It is in order to facilitate this
kind of multiple assignment that <TT>cin</TT> must consider each word in the input
to be the full input for each variable. If <TT>cin</TT> was to consider the entire
input to be part of one variable's input, this kind of concatenated input would be
impossible.</P>
<P>Note that on line 35 the last object requested was an <TT>unsigned</TT> integer,
but the user entered <TT>-2</TT>. Because <TT>cin</TT> believes it is writing to
an <TT>unsigned</TT> integer, the bit pattern of <TT>-2</TT> was evaluated as an
<TT>unsigned</TT> integer, and when written out by <TT>cout</TT>, the value <TT>65534</TT>
was displayed. The <TT>unsigned</TT> value <TT>65534</TT> has the exact bit pattern
of the <TT>signed</TT> value <TT>-2</TT>.</P>
<P>Later in this chapter you will see how to enter an entire string into a buffer,
including multiple words. For now, the question arises, &quot;How does the extraction
operator manage this trick of concatenation?&quot;
<H4 ALIGN="CENTER"><A NAME="Heading23"></A><FONT COLOR="#000077">operator&gt;&gt;
Returns a Reference to an istream Object</FONT></H4>
<P>The return value of <TT>cin</TT> is a reference to an <TT>istream</TT> object.
Because <TT>cin</TT> itself is an <TT>istream</TT> object, the return value of one
extraction operation can be the input to the next extraction.</P>
<PRE><FONT COLOR="#0066FF">int VarOne, varTwo, varThree;
cout &lt;&lt; &quot;Enter three numbers: &quot;
cin &gt;&gt; VarOne &gt;&gt; varTwo &gt;&gt; varThree;
</FONT></PRE>
<P>When you write <TT>cin &gt;&gt; VarOne &gt;&gt; varTwo &gt;&gt; varThree;</TT>,
the first extraction is evaluated <TT>(cin &gt;&gt; VarOne)</TT>. The return value
from this is another <TT>istream</TT> object, and that object's extraction operator
gets the variable <TT>varTwo</TT>. It is as if you had written this:</P>
<PRE><FONT COLOR="#0066FF">((cin &gt;&gt; varOne) &gt;&gt; varTwo) &gt;&gt; varThree;
</FONT></PRE>
<P>You'll see this technique repeated later when <TT>cout</TT> is discussed.
<H3 ALIGN="CENTER"><A NAME="Heading24"></A><FONT COLOR="#000077">Other Member Functions
of cin</FONT></H3>
<P>In addition to overloading <TT>operator&gt;&gt;</TT>, <TT>cin</TT> has a number
of other member functions. These are used when finer control over the input is required.
<H4 ALIGN="CENTER"><A NAME="Heading25"></A><FONT COLOR="#000077">Single Character
Input</FONT></H4>
<P><TT>operator&gt;&gt;</TT> taking a character reference can be used to get a single
character from the standard input. The member function <TT>get()</TT> can also be
used to obtain a single character, and can do so in two ways. <TT>get()</TT> can
be used with no parameters, in which case the return value is used, or it can be
used with a reference to a character. Using get() with No Parameters The first form
of <TT>get()</TT> is without parameters. This returns the value of the character
found, and will return <TT>EOF</TT> (end of file) if the end of the file is reached.
<TT>get()</TT> with no parameters is not often used. It is not possible to concatenate
this use of <TT>get()</TT> for multiple input, because the return value is not an
<TT>iostream</TT> object. Thus, the following won't work:</P>
<PRE><FONT COLOR="#0066FF">cin.get() &gt;&gt;myVarOne &gt;&gt; myVarTwo; //   illegal
</FONT></PRE>
<P>The return value of (<TT>cin.get() &gt;&gt; myVarOne</TT>) is an integer, not
an <TT>iostream</TT> object.</P>
<P>A common use of <TT>get()</TT> with no parameters is illustrated in Listing 16.4.</P>
<P><A NAME="Heading26"></A><FONT SIZE="4" COLOR="#000077"><B>Listing 16.4. Using
get() with no parameters.</B></FONT></P>
<PRE><FONT COLOR="#0066FF">1:     // Listing 16.4 - Using get() with no parameters
2:     #include &lt;iostream.h&gt;
3:
4:     int main()
5:     {
6:        char ch;
7:        while ( (ch = cin.get()) != EOF)
8:        {
9:           cout &lt;&lt; &quot;ch: &quot; &lt;&lt; ch &lt;&lt; endl;
10:       }
11:       cout &lt;&lt; &quot;\nDone!\n&quot;;
12:     return 0;
<TT>13: }</TT></FONT></PRE>


<BLOCKQUOTE>
	<P>
<HR>
<FONT COLOR="#000077"><B>NOTE:</B></FONT><B> </B>To exit this program, you must send
	end of file from the keyboard. On DOS computers use Ctrl+Z; on UNIX units use Ctrl+D.
	
<HR>


</BLOCKQUOTE>

<PRE><FONT COLOR="#0066FF">Output: Hello
ch: H
ch: e
ch: l
ch: l
ch: o
ch:

World
ch: W
ch: o
ch: r
ch: l
ch: d
ch:

 (ctrl-z)
Done!
</FONT></PRE>
<P><FONT COLOR="#000077"><B>Analysis</B></FONT><FONT COLOR="#000000"><B>:</B></FONT><FONT
COLOR="#000077"><B> </B></FONT>On line 6, a local character variable is declared.
The <TT>while</TT> loop assigns the input received from <TT>cin.get()</TT> to <TT>ch</TT>,
and if it is not <TT>EOF</TT> the string is printed out. This output is buffered
until an end of line is read, however. Once <TT>EOF</TT> is encountered (by pressing
Ctrl+Z on a DOS machine, or Ctrl+D on a UNIX machine), the loop exits.</P>
<P>Note that not every implementation of <TT>istream</TT> supports this version of
<TT>get()</TT>. Using get() with a Character Reference Parameter When a character
is passed as input to <TT>get()</TT>, that character is filled with the next character
in the input stream. The return value is an <TT>iostream</TT> object, and so this
form of <TT>get()</TT> can be concatenated, as illustrated in Listing 16.5.</P>
<P><A NAME="Heading27"></A><FONT SIZE="4" COLOR="#000077"><B>Listing 16.5 Using get()
with parameters.</B></FONT></P>
<PRE><FONT COLOR="#0066FF">1:     // Listing 16.5 - Using get() with parameters
2:     #include &lt;iostream.h&gt;
3:
4:     int main()
5:     {
6:        char a, b, c;
7:
8:        cout &lt;&lt; &quot;Enter three letters: &quot;;
9:
10:       cin.get(a).get(b).get(c);
11:
12:       cout &lt;&lt; &quot;a: &quot; &lt;&lt; a &lt;&lt; &quot;\nb: &quot; &lt;&lt; b &lt;&lt; &quot;\nc: &quot; &lt;&lt; c &lt;&lt; endl;
13:     return 0;
<TT>14: }</TT></FONT>
<FONT COLOR="#0066FF">
Output: Enter three letters: one
a: o
b: n
c: e
</FONT></PRE>
<P><FONT COLOR="#000077"><B>Analysis</B></FONT><FONT COLOR="#000000"><B>:</B></FONT><B>
</B>On line 6, three character variables are created. On line 10, <TT>cin.get()</TT>
is called three times, concatenated. First <TT>cin.get(a)</TT> is called. This puts
the first letter into <TT>a</TT> and returns <TT>cin</TT> so that when it is done,
<TT>cin.get(b)</TT> is called, putting the next letter into <TT>b</TT>. The end result
of this is that <TT>cin.get(c)</TT> is called and the third letter is put in <TT>c</TT>.</P>
<P>Because <TT>cin.get(a)</TT> evaluates to <TT>cin</TT>, you could have written
this:</P>
<PRE><FONT COLOR="#0066FF">cin.get(a) &gt;&gt; b;</FONT></PRE>
<P>In this form, <TT>cin.get(a)</TT> evaluates to <TT>cin</TT>, so the second phrase
is <TT>cin &gt;&gt; b;</TT>.


<BLOCKQUOTE>
	<P>
<HR>
<B>DO </B>use the extraction operator (<TT>&gt;&gt;</TT>) when you need to skip over
	white space. <B>DO</B> use <TT>get()</TT> with a character parameter when you need
	to examine every character, including white space. <B>DON'T </B>use <TT>get()</TT>
	with no parameters at all; it is more or less obsolete. 
<HR>


</BLOCKQUOTE>

<H4 ALIGN="CENTER"><A NAME="Heading28"></A><FONT COLOR="#000077">Getting Strings
from Standard Input</FONT></H4>
<P>The extraction operator (<TT>&gt;&gt;</TT>) can be used to fill a character array,
as can the member functions <TT>get()</TT> and <TT>getline()</TT>.</P>
<P>The final form of <TT>get()</TT> takes three parameters. The first parameter is
a pointer to a character array, the second parameter is the maximum number of characters
to read plus one, and the third parameter is the termination character.</P>
<P>If you enter <TT>20</TT> as the second parameter, <TT>get()</TT> will read 19
characters and then will null-terminate the string, which it will store in the first
parameter. The third parameter, the termination character, defaults to newline (<TT>`\n'</TT>).
If a termination character is reached before the maximum number of characters is
read, a null is written and the termination character is left in the buffer.</P>
<P>Listing 16.6 illustrates the use of this form of <TT>get()</TT>.</P>
<P><A NAME="Heading29"></A><FONT SIZE="4" COLOR="#000077"><B>Listing 16.6. Using
get() with a character array.</B></FONT></P>
<PRE><FONT COLOR="#0066FF">1:     // Listing 16.6 - Using get() with a character array
2:     #include &lt;iostream.h&gt;
3:
4:     int main()
5:     {
6:        char stringOne[256];
7:        char stringTwo[256];
8:
9:        cout &lt;&lt; &quot;Enter string one: &quot;;
10:       cin.get(stringOne,256);
11:       cout &lt;&lt; &quot;stringOne: &quot; &lt;&lt; stringOne &lt;&lt; endl;
12:
13:       cout &lt;&lt; &quot;Enter string two: &quot;;
14:       cin &gt;&gt; stringTwo;
15:       cout &lt;&lt; &quot;StringTwo: &quot; &lt;&lt; stringTwo &lt;&lt; endl;
16:     return 0;
<TT>17: }</TT></FONT>
<FONT COLOR="#0066FF">
Output: Enter string one: Now is the time
stringOne: Now is the time
Enter string two: For all good
StringTwo: For
</FONT></PRE>
<P><FONT COLOR="#000077"><B>Analysis</B></FONT><FONT COLOR="#000000"><B>:</B></FONT><B>
</B>On lines 6 and 7, two character arrays are created. On line 9, the user is prompted
to enter a string, and <TT>cin.get()</TT> is called on line 10. The first parameter
is the buffer to fill, and the second is one more than the maximum number for <TT>get()</TT>
to accept (the extra position being given to the null character, (<TT>`\0'</TT>)).
The defaulted third parameter is a newline.</P>
<P>The user enters <TT>Now is the time</TT>. Because the user ends the phrase with
a newline, that phrase is put into <TT>stringOne</TT>, followed by a terminating
null.</P>
<P>The user is prompted for another string on line 13, and this time the extraction
operator is used. Because the extraction operator takes everything up to the first
white space, the string <TT>For</TT>, with a terminating null character, is stored
in the second string, which of course is not what was intended.</P>
<P>Another way to solve this problem is to use <TT>getline()</TT>, as illustrated
in Listing 16.7.</P>
<P><A NAME="Heading31"></A><FONT SIZE="4" COLOR="#000077"><B>Listing 16.7. Using
getline().</B></FONT></P>
<PRE><FONT COLOR="#0066FF">1:     // Listing 16.7 - Using getline()
2:     #include &lt;iostream.h&gt;
3:
4:     int main()
5:     {
6:        char stringOne[256];
7:        char stringTwo[256];
8:        char stringThree[256];
9:
10:       cout &lt;&lt; &quot;Enter string one: &quot;;
11:       cin.getline(stringOne,256);
12:       cout &lt;&lt; &quot;stringOne: &quot; &lt;&lt; stringOne &lt;&lt; endl;
13:
14:       cout &lt;&lt; &quot;Enter string two: &quot;;
15:       cin &gt;&gt; stringTwo;
16:       cout &lt;&lt; &quot;stringTwo: &quot; &lt;&lt; stringTwo &lt;&lt; endl;
17:
18:       cout &lt;&lt; &quot;Enter string three: &quot;;
19:       cin.getline(stringThree,256);
20:       cout &lt;&lt; &quot;stringThree: &quot; &lt;&lt; stringThree &lt;&lt; endl;
21:     return 0;
<TT>22: }</TT></FONT>
<FONT COLOR="#0066FF">
Output: Enter string one: one two three
stringOne: one two three
Enter string two: four five six
stringTwo: four
Enter string three: stringThree: five six
</FONT></PRE>
<P><FONT COLOR="#000077"><B>Analysis</B></FONT><FONT COLOR="#000000"><B>:</B></FONT><B>
</B>This example warrants careful examination; there are some potential surprises.
On lines 6-8, three character arrays are declared.</P>
<P>On line 10, the user is prompted to enter a string, and that string is read by
<TT>getline()</TT>. Like <TT>get()</TT>, <TT>getline()</TT> takes a buffer and a
maximum number of characters. Unlike <TT>get()</TT>, however, the terminating newline
is read and thrown away. With <TT>get()</TT> the terminating newline is not thrown
away. It is left in the input buffer.</P>
<P>On line 14, the user is prompted again, and this time the extraction operator
is used. The user enters <TT>four five six</TT>, and the first word, <TT>four</TT>,
is put in <TT>stringTwo</TT>. The string <TT>Enter string three</TT> is then displayed,
and <TT>getline()</TT> is called again. Because <TT>five six</TT> is still in the
input buffer, it is immediately read up to the newline; <TT>getline()</TT> terminates
and the string in <TT>stringThree</TT> is printed on line 20.</P>
<P>The user has no chance to enter string three, because the second <TT>getline()</TT>
call is fulfilled by the string remaining in the input buffer after the call to the
extraction operator on line 15.</P>
<P>The extraction operator (<TT>&gt;&gt;</TT>) reads up to the first white space
and puts the word into the character array.</P>
<P>The member function <TT>get()</TT> is overloaded. In one version, it takes no
parameters and returns the value of the character it receives. In the second version,
it takes a single character reference and returns the <TT>istream</TT> object by
reference.</P>
<P>In the third and final version, <TT>get()</TT> takes a character array, a number
of characters to get, and a termination character (which defaults to newline). This
version of <TT>get()</TT> reads characters into the array until it gets to one fewer
than its maximum number of characters or it encounters the termination character,
whichever comes first. If <TT>get()</TT> encounters the termination character, it
leaves that character in the input buffer and stops reading characters.</P>
<P>The member function <TT>getline()</TT> also takes three parameters: the buffer
to fill, one more than the maximum number of characters to get, and the termination
character. <TT>getline()</TT>functions exactly like <TT>get()</TT> does with these
parameters, except <TT>getline()</TT> throws away the terminating character.
<H4 ALIGN="CENTER"><A NAME="Heading32"></A><FONT COLOR="#000077">Using cin.ignore()</FONT></H4>
<P>At times you want to ignore the remaining characters on a line until you hit either
end of line (EOL) or end of file (EOF). The member function <TT>ignore()</TT> serves
this purpose. <TT>ignore()</TT> takes two parameters, the maximum number of characters
to ignore and the termination character. If you write <TT>ignore(80,'\n')</TT>, up
to 80 characters will be thrown away until a newline character is found. The newline
is then thrown away and the <TT>ignore()</TT> statement ends. Listing 16.8 illustrates
the use of <TT>ignore()</TT>.</P>
<P><A NAME="Heading33"></A><FONT SIZE="4" COLOR="#000077"><B>Listing 16.8. Using
ignore().</B></FONT></P>
<PRE><FONT COLOR="#0066FF">1:     // Listing 16.8 - Using ignore()
2:     #include &lt;iostream.h&gt;
3:
4:     int main()
5:     {
6:        char stringOne[255];
7:        char stringTwo[255];
8:
9:        cout &lt;&lt; &quot;Enter string one:&quot;;
10:       cin.get(stringOne,255);
11:       cout &lt;&lt; &quot;String one&quot; &lt;&lt; stringOne &lt;&lt; endl;
12:
13:       cout &lt;&lt; &quot;Enter string two: &quot;;
14:       cin.getline(stringTwo,255);
15:       cout &lt;&lt; &quot;String two: &quot; &lt;&lt; stringTwo &lt;&lt; endl;
16:
17:       cout &lt;&lt; &quot;\n\nNow try again...\n&quot;;
18:
19:       cout &lt;&lt; &quot;Enter string one: &quot;;
20:       cin.get(stringOne,255);
21:       cout &lt;&lt; &quot;String one: &quot; &lt;&lt; stringOne&lt;&lt; endl;
22:
23:       cin.ignore(255,'\n');
24:
25:       cout &lt;&lt; &quot;Enter string two: &quot;;
26:       cin.getline(stringTwo,255);
27:       cout &lt;&lt; &quot;String Two: &quot; &lt;&lt; stringTwo&lt;&lt; endl;
28:     return 0;
<TT>29: }</TT></FONT>
<FONT COLOR="#0066FF">
Output: Enter string one:once upon a time
String oneonce upon a time
Enter string two: String two:

Now try again...
Enter string one: once upon a time
String one: once upon a time
Enter string two: there was a
String Two: there was a</FONT></PRE>
<P><FONT COLOR="#000077"><B>Analysis</B></FONT><FONT COLOR="#000000"><B>: </B></FONT>On
lines 6 and 7, two character arrays are created. On line 9, the user is prompted
for input and types <TT>once upon a time</TT>, followed by Enter. On line 10, <TT>get()</TT>
is used to read this string. <TT>get()</TT> fills <TT>stringOne</TT> and terminates
on the newline, but leaves the newline character in the input buffer.</P>
<P>On line 13, the user is prompted again, but the <TT>getline()</TT> on line 14
reads the newline that is already in the buffer and terminates immediately, before
the user can enter any input.</P>
<P>On line 19, the user is prompted again and puts in the same first line of input.
This time, however, on line 23, <TT>ignore()</TT> is used to &quot;eat&quot; the
newline character. Thus, when the <TT>getline()</TT> call on line 26 is reached,
the input buffer is empty, and the user can input the next line of the story.
<H4 ALIGN="CENTER"><A NAME="Heading34"></A><FONT COLOR="#000077">peek() and putback()</FONT></H4>
<P>The input object <TT>cin</TT> has two additional methods that can come in rather
handy: <TT>peek()</TT>, which looks at but does not extract the next character, and
<TT>putback()</TT>, which inserts a character into the input stream. Listing 16.9
illustrates how these might be used.</P>
<P><A NAME="Heading35"></A><FONT SIZE="4" COLOR="#000077"><B>Listing 16.9. Using
peek() and putback().</B></FONT></P>
<PRE><FONT COLOR="#0066FF">1:     // Listing 16.9 - Using peek() and putback()
2:     #include &lt;iostream.h&gt;
3:
4:     int main()
5:     {
6:        char ch;
7:        cout &lt;&lt; &quot;enter a phrase: &quot;;
8:        while ( cin.get(ch) )
9:        {
10:          if (ch == `!')
11:             cin.putback(`$');
12:          else
13:             cout &lt;&lt; ch;
14:          while (cin.peek() == `#')
15:             cin.ignore(1,'#');
16:       }
17:     return 0;
<TT>18: }</TT></FONT>
<FONT COLOR="#0066FF">
Output: enter a phrase: Now!is#the!time#for!fun#!
Now$isthe$timefor$fun$
</FONT></PRE>
<P><FONT COLOR="#000077"><B>Analysis</B></FONT><FONT COLOR="#000000"><B>: </B></FONT>On
line 6, a character variable, <TT>ch</TT>, is declared, and on line 7, the user is
prompted to enter a phrase. The purpose of this program is to turn any exclamation
marks (<TT>!</TT>) into dollar signs (<TT>$</TT>) and to remove any pound symbols
(<TT>#</TT>).</P>
<P>The program loops as long as it is getting characters other than the end of file
(remember that <TT>cin.get()</TT> returns <TT>0</TT> for end of file). If the current
character is an exclamation point, it is thrown away and the <TT>$</TT> symbol is
put back into the input buffer; it will be read the next time through. If the current
item is not an exclamation point, it is printed. The next character is &quot;peeked&quot;
at, and when pound symbols are found, they are removed.</P>
<P>This is not the most efficient way to do either of these things (and it won't
find a pound symbol if it is the first character), but it does illustrate how these
methods work. They are relatively obscure, so don't spend a lot of time worrying
about when you might really use them. Put them into your bag of tricks; they'll come
in handy sooner or later.


<BLOCKQUOTE>
	<P>
<HR>
<FONT COLOR="#000077"><TT><B>TIP:</B></TT></FONT><TT><B> </B>peek()</TT> and <TT>putback()</TT>
	are typically used for parsing strings and other data, such as when writing a compiler.
	
<HR>


</BLOCKQUOTE>

<H3 ALIGN="CENTER"><A NAME="Heading36"></A><FONT COLOR="#000077">Output with cout</FONT></H3>
<P>You have used <TT>cout</TT> along with the overloaded insertion operator (<TT>&lt;&lt;</TT>)
to write strings, integers, and other numeric data to the screen. It is also possible
to format the data, aligning columns and writing the numeric data in decimal and
hexadecimal. This section will show you how.
<H4 ALIGN="CENTER"><A NAME="Heading37"></A><FONT COLOR="#000077">Flushing the Output</FONT></H4>
<P>You've already seen that using <TT>endl</TT> will flush the output buffer. <TT>endl</TT>
calls <TT>cout</TT>'s member function <TT>flush()</TT>, which writes all of the data
it is buffering. You can call the <TT>flush()</TT> method directly, either by calling
the <TT>flush()</TT> member method or by writing the following:</P>
<PRE><FONT COLOR="#0066FF">cout &lt;&lt; flush
</FONT></PRE>
<P>This can be convenient when you need to ensure that the output buffer is emptied
and that the contents are written to the screen.
<H3 ALIGN="CENTER"><A NAME="Heading38"></A><FONT COLOR="#000077">Related Functions</FONT></H3>
<P>Just as the extraction operator can be supplemented with <TT>get()</TT> and <TT>getline()</TT>,
the insertion operator can be supplemented with <TT>put()</TT> and <TT>write()</TT>.</P>
<P>The function <TT>put()</TT> is used to write a single character to the output
device. Because <TT>put()</TT> returns an <TT>ostream</TT> reference, and because
<TT>cout</TT> is an <TT>ostream</TT> object, you can concatenate <TT>put()</TT> just
as you do the insertion operator. Listing 16.10 illustrates this idea.</P>
<P><A NAME="Heading39"></A><FONT SIZE="4" COLOR="#000077"><B>Listing 16.10. Using
put().</B></FONT></P>
<PRE><FONT COLOR="#0066FF">1:     // Listing 16.10 - Using put()
2:     #include &lt;iostream.h&gt;
3:
4:     int main()
5:     {
6:        cout.put(`H').put(`e').put(`l').put(`l').put(`o').put(`\n');
7:     return 0;
<TT>8: }</TT>
Output: Hello
</FONT></PRE>
<P><FONT COLOR="#000077"><B>Analysis</B></FONT><FONT COLOR="#000000"><B>:</B></FONT><B>
</B>Line 6 is evaluated like this: <TT>cout.put(`H')</TT> writes the letter <TT>H</TT>
to the screen and returns the <TT>cout</TT> object. This leaves the following:</P>
<PRE><FONT COLOR="#0066FF">cout.put(`e').put(`l').put(`l').put(`o').put(`\n');</FONT></PRE>
<P>The letter <TT>e</TT> is written, leaving <TT>cout.put(`l')</TT>. This process
repeats, each letter being written and the <TT>cout</TT> object returned until the
final character (<TT>`\n'</TT>) is written and the function returns.</P>
<P>The function <TT>write()</TT> works just like the insertion operator (<TT>&lt;&lt;</TT>),
except that it takes a parameter that tells the function the maximum number of characters
to write. Listing 16.11 illustrates its use.</P>
<P><A NAME="Heading40"></A><FONT SIZE="4" COLOR="#000077"><B>Listing 16.11. Using
write().</B></FONT></P>
<PRE><FONT COLOR="#0066FF">1:     // Listing 16.11 - Using write()
2:     #include &lt;iostream.h&gt;
3:     #include &lt;string.h&gt;
4:
5:     int main()
6:     {
7:        char One[] = &quot;One if by land&quot;;
8:
9:
10:
11:       int fullLength = strlen(One);
12:       int tooShort = fullLength -4;
13:       int tooLong = fullLength + 6;
14:
15:       cout.write(One,fullLength) &lt;&lt; &quot;\n&quot;;
16:       cout.write(One,tooShort) &lt;&lt; &quot;\n&quot;;
17:       cout.write(One,tooLong) &lt;&lt; &quot;\n&quot;;
18:     return 0;
<TT>19: }</TT></FONT>
<FONT COLOR="#0066FF">
Output: One if by land
One if by
One if by land i?!
</FONT></PRE>


<BLOCKQUOTE>
	<P>
<HR>
<FONT COLOR="#000077"><B>NOTE:</B></FONT><B> </B>The last line of output may look
	different on your computer. 
<HR>


</BLOCKQUOTE>

<P><FONT COLOR="#000077"><B>Analysis</B></FONT><FONT COLOR="#000000"><B>: </B></FONT>On
line 7, one phrase is created. On line 11, the integer <TT>fullLength</TT> is set
to the length of the phrase and <TT>tooShort</TT> is set to that length minus four,
while <TT>tooLong</TT> is set to <TT>fullLength</TT> plus six.</P>
<P>On line 15, the complete phrase is printed using <TT>write()</TT>. The length
is set to the actual length of the phrase, and the correct phrase is printed.</P>
<P>On line 16, the phrase is printed again, but is four characters shorter than the
full phrase, and that is reflected in the output.</P>
<P>On line 17, the phrase is printed again, but this time <TT>write()</TT> is instructed
to write an extra six characters. Once the phrase is written, the next six bytes
of contiguous memory are written.
<H3 ALIGN="CENTER"><A NAME="Heading41"></A><FONT COLOR="#000077">Manipulators, Flags,
and Formatting Instructions</FONT></H3>
<P>The output stream maintains a number of state flags, determining which base (decimal
or hexadecimal) to use, how wide to make the fields, and what character to use to
fill in fields. A state flag is just a byte whose individual bits are each assigned
a special meaning. Manipulating bits in this way is discussed on Day 21. Each of
<TT>ostream</TT>'s flags can be set using member functions and manipulators.
<H4 ALIGN="CENTER"><A NAME="Heading42"></A><FONT COLOR="#000077">Using cout.width()</FONT></H4>
<P>The default width of your output will be just enough space to print the number,
character, or string in the output buffer. You can change this by using <TT>width()</TT>.
Because <TT>width()</TT> is a member function, it must be invoked with a <TT>cout</TT>
object. It only changes the width of the very next output field and then immediately
reverts to the default. Listing 16.12 illustrates its use.</P>
<P><A NAME="Heading43"></A><FONT SIZE="4" COLOR="#000077"><B>Listing 16.12. Adjusting
the width of output.</B></FONT></P>
<PRE><FONT COLOR="#0066FF">1:     // Listing 16.12 - Adjusting the width of output
2:     #include &lt;iostream.h&gt;
3:
4:     int main()
5:     {
6:        cout &lt;&lt; &quot;Start &gt;&quot;;
7:        cout.width(25);
8:        cout &lt;&lt; 123 &lt;&lt; &quot;&lt; End\n&quot;;
9:
10:       cout &lt;&lt; &quot;Start &gt;&quot;;
11:       cout.width(25);
12:       cout &lt;&lt; 123&lt;&lt; &quot;&lt; Next &gt;&quot;;
13:       cout &lt;&lt; 456 &lt;&lt; &quot;&lt; End\n&quot;;
14:
15:       cout &lt;&lt; &quot;Start &gt;&quot;;
16:       cout.width(4);
17:       cout &lt;&lt; 123456 &lt;&lt; &quot;&lt; End\n&quot;;
18:
19:     return 0;
<TT>20: }</TT></FONT>
<FONT COLOR="#0066FF">
Output: Start &gt;                  123&lt; End
Start &gt;                  123&lt; Next &gt;456&lt; End
Start &gt;123456&lt; End
</FONT></PRE>
<P><FONT COLOR="#000077"><B>Analysis</B></FONT><FONT COLOR="#000000"><B>:</B></FONT><B>
</B>The first output, on lines 6-8, prints the number 123 within a field whose width
is set to 25 on line 7. This is reflected in the first line of output.</P>
<P>The second line of output first prints the value 123 in the same field whose width
is set to 25, and then prints the value 456. Note that 456 is printed in a field
whose width is reset to just large enough; as stated, the effect of <TT>width()</TT>
lasts only as long as the very next output.</P>
<P>The final output reflects that setting a width that is smaller than the output
is exactly like setting a width that is just large enough.
<H4 ALIGN="CENTER"><A NAME="Heading44"></A><FONT COLOR="#000077">Setting the Fill
Characters</FONT></H4>
<P>Normally <TT>cout</TT> fills the empty field created by a call to <TT>width()</TT>
with spaces, as shown above. At times you may want to fill the area with other characters,
such as asterisks. To do this, you call <TT>fill()</TT> and pass in as a parameter
the character you want used as a fill character. Listing 16.13 illustrates this.</P>
<P><A NAME="Heading45"></A><FONT SIZE="4" COLOR="#000077"><B>Listing 16.13. Using
fill().</B></FONT></P>
<PRE><FONT COLOR="#0066FF">1:     // Listing 16.3 - fill()
2:
3:     #include &lt;iostream.h&gt;
4:
5:     int main()
6:     {
7:        cout &lt;&lt; &quot;Start &gt;&quot;;
8:        cout.width(25);
9:        cout &lt;&lt; 123 &lt;&lt; &quot;&lt; End\n&quot;;
10:
11:
12:        cout &lt;&lt; &quot;Start &gt;&quot;;
13:       cout.width(25);
14:       cout.fill(`*');
15:       cout &lt;&lt; 123 &lt;&lt; &quot;&lt; End\n&quot;;
16:     return 0;
<TT>17: }</TT></FONT>
<FONT COLOR="#0066FF">
Output: Start &gt;                  123&lt; End
Start &gt;******************123&lt; End
</FONT></PRE>
<P><FONT COLOR="#000077"><B>Analysis</B></FONT><FONT COLOR="#000000"><B>:</B></FONT><B>
</B>Lines 7-9 repeat the functionality from the previous example. Lines 12-15 repeat
this again, but this time, on line 14, the fill character is set to asterisks, as
reflected in the output.
<H4 ALIGN="CENTER"><A NAME="Heading47"></A><FONT COLOR="#000077">Set Flags</FONT></H4>
<P>The <TT>iostream</TT> objects keep track of their state by using flags. You can
set these flags by calling <TT>setf()</TT> and passing in one or another of the predefined
enumerated constants.</P>

<DL>
	<DD>
<HR>
<FONT COLOR="#000077"><B>New Term:</B></FONT><B> </B>Objects are said to have <I>state
	</I>when some or all of their data represents a condition that can change during
	the course of the program. 
<HR>

</DL>

<P>For example, you can set whether or not to show trailing zeros (so that 20.00
does not become truncated to 20). To turn trailing zeros on, call <TT>setf(ios::showpoint)</TT>.</P>
<P>The enumerated constants are scoped to the <TT>iostream</TT> class (<TT>ios</TT>)
and thus are called with the full qualification <TT>ios::flagname</TT>, such as <TT>ios::showpoint</TT>.</P>
<P>You can turn on the plus sign (<TT>+</TT>) before positive numbers by using <TT>ios::showpos</TT>.
You can change the alignment of the output by using <TT>ios::left</TT>,<TT> ios::right</TT>,
or <TT>ios::internal</TT>.</P>
<P>Finally, you can set the base of the numbers for display by using <TT>ios::dec</TT>
(decimal), <TT>ios::oct</TT> (octal--base eight), or <TT>ios::hex</TT> (hexadecimal--base
sixteen). These flags can also be concatenated into the insertion operator. Listing
16.14 illustrates these settings. As a bonus, Listing 16.14 also introduces the <TT>setw</TT>
manipulator, which sets the width but can also be concatenated with the insertion
operator.</P>
<P><A NAME="Heading48"></A><FONT SIZE="4" COLOR="#000077"><B>Listing 16.14. Using
setf.</B></FONT></P>
<PRE><FONT COLOR="#0066FF">1:     // Listing 16.14 - Using setf
2:     #include &lt;iostream.h&gt;
3:     #include &lt;iomanip.h&gt;
4:
5:     int main()
6:     {
7:        const int number = 185;
8:        cout &lt;&lt; &quot;The number is &quot; &lt;&lt; number &lt;&lt; endl;
9:
10:       cout &lt;&lt; &quot;The number is &quot; &lt;&lt; hex &lt;&lt;  number &lt;&lt; endl;
11:
12:       cout.setf(ios::showbase);
13:       cout &lt;&lt; &quot;The number is &quot; &lt;&lt; hex &lt;&lt;  number &lt;&lt; endl;
14:
15:       cout &lt;&lt; &quot;The number is &quot; ;
16:       cout.width(10);
17:       cout &lt;&lt; hex &lt;&lt; number &lt;&lt; endl;
18:
19:       cout &lt;&lt; &quot;The number is &quot; ;
20:       cout.width(10);
21:       cout.setf(ios::left);
22:       cout &lt;&lt; hex &lt;&lt; number &lt;&lt; endl;
23:
24:       cout &lt;&lt; &quot;The number is &quot; ;
25:       cout.width(10);
26:       cout.setf(ios::internal);
27:       cout &lt;&lt; hex &lt;&lt; number &lt;&lt; endl;
28:
29:       cout &lt;&lt; &quot;The number is:&quot; &lt;&lt; setw(10) &lt;&lt; hex &lt;&lt; number &lt;&lt; endl;
30:     return 0;
<TT>31: }</TT></FONT>
<FONT COLOR="#0066FF">
Output: The number is 185
The number is b9
The number is 0xb9
The number is         0xb9
The number is 0xb9
The number is 0x        b9
The number is:0x        b9</FONT></PRE>
<P><FONT COLOR="#000077"><B>Analysis</B></FONT><FONT COLOR="#000000"><B>:</B></FONT><B>
</B>On line 7, the constant <TT>int</TT> <TT>number</TT> is initialized to the value
<TT>185</TT>. This is displayed on line 8.</P>
<P>The value is displayed again on line 10, but this time the manipulator <TT>hex</TT>
is concatenated, causing the value to be displayed in hexadecimal as <TT>b9</TT>.
(b=11; 11*16=176+9=185).</P>
<P>On line 12, the flag <TT>showbase</TT> is set. This causes the prefix <TT>0x</TT>
to be added to all hexadecimal numbers, as reflected in the output.</P>
<P>On line 16, the width is set to <TT>10</TT>, and the value is pushed to the extreme
right. On line 20, the width is again set to <TT>10</TT>, but this time the alignment
is set to the left, and the number is again printed flush left.</P>
<P>On line 25, once again the width is set to <TT>10</TT>, but this time the alignment
is internal. Thus the <TT>0x</TT> is printed flush left, but the value, <TT>b9</TT>,
is printed flush right.</P>
<P>Finally, on line 29, the concatenation operator <TT>setw()</TT> is used to set
the width to <TT>10</TT>, and the value is printed again.
<H3 ALIGN="CENTER"><A NAME="Heading49"></A><FONT COLOR="#000077">Streams Versus the
printf() Function</FONT></H3>
<P>Most C++ implementations also provide the standard C I/O libraries, including
the <TT>printf()</TT> statement. Although <TT>printf()</TT> is in some ways easier
to use than <TT>cout</TT>, it is far less desirable.</P>
<P><TT>printf()</TT> does not provide type safety, so it is easy to inadvertently
tell it to display an integer as if it was a character and vice versa. <TT>printf()</TT>
also does not support classes, and so it is not possible to teach it how to print
your class data; you must feed each class member to <TT>printf()</TT> one by one.</P>
<P>On the other hand, <TT>printf()</TT> does make formatting much easier, because
you can put the formatting characters directly into the <TT>printf()</TT> statement.
Because <TT>printf()</TT> has its uses and many programmers still make extensive
use of it, this section will briefly review its use.</P>
<P>To use <TT>printf()</TT>, be sure to include the <TT>STDIO.H</TT> header file.
In its simplest form, <TT>printf()</TT> takes a formatting string as its first parameter
and then a series of values as its remaining parameters.</P>
<P>The formatting string is a quoted string of text and conversion specifiers. All
conversion specifiers must begin with the percent symbol (<TT>%</TT>). The common
conversion specifiers are presented in Table 16.1. <BR>
<BR>
<FONT SIZE="4"><B>Table 16.1. The Common Conversion Specifiers</B></FONT>. 
<TABLE BORDER="0" WIDTH="221">
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT"><B><I>Specifier</I></B></TD>
		<TD ALIGN="LEFT"><B><I>Used For</I></B></TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT"><TT>%s</TT></TD>
		<TD ALIGN="LEFT">strings</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT"><TT>%d</TT></TD>
		<TD ALIGN="LEFT">integers</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT"><TT>%l</TT></TD>
		<TD ALIGN="LEFT"><TT>long</TT> integer</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT"><TT>%ld</TT></TD>
		<TD ALIGN="LEFT"><TT>long</TT> integers</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT"><TT>%f</TT></TD>
		<TD ALIGN="LEFT"><TT>float</TT></TD>
	</TR>
</TABLE>
<BR>
<BR>
Each of the conversion specifiers can also provide a width statement and a precision
statement, expressed as a <TT>float</TT>, where the digits to the left of the decimal
are used for the total width, and the digits to the right of the decimal provide
the precision for <TT>float</TT>s. Thus, <TT>%5d</TT> is the specifier for a five-digit-wide
integer, and <TT>%15.5f</TT> is the specifier for a 15-digit-wide <TT>float</TT>,
of which the final five digits are dedicated to the decimal portion. Listing 16.15
illustrates various uses of <TT>printf()</TT>.</P>
<P><A NAME="Heading50"></A><FONT SIZE="4" COLOR="#000077"><B>Listing 16.15. Printing
with printf().</B></FONT></P>
<PRE><FONT COLOR="#0066FF">1:     #include &lt;stdio.h&gt;
2:     int main()
3:     {
4:        printf(&quot;%s&quot;,&quot;hello world\n&quot;);
5:
6:        char *phrase = &quot;Hello again!\n&quot;;
7:        printf(&quot;%s&quot;,phrase);
8:
9:        int x = 5;
10:       printf(&quot;%d\n&quot;,x);
11:
12:       char *phraseTwo = &quot;Here's some values: &quot;;
13:       char *phraseThree = &quot; and also these: &quot;;
14:       int y = 7, z = 35;
15:       long longVar = 98456;
16:       float floatVar =  8.8;
17:
18:       printf(&quot;%s %d %d %s %ld %f\n&quot;,phraseTwo,y,z,phraseThree,longVar,floatVar);
19:
20:       char *phraseFour = &quot;Formatted: &quot;;
21:       printf(&quot;%s %5d %10d  %10.5f\n&quot;,phraseFour,y,z,floatVar);
22:     return 0;
<TT>23: }</TT></FONT>
<FONT COLOR="#0066FF">
Output: hello world
Hello again!
5
Here's some values: 7 35  and also these: 98456 8.800000
Formatted:      7        35     8.800000
</FONT></PRE>
<P><FONT COLOR="#000077"><B>Analysis: </B></FONT>The first <TT>printf()</TT> statement,
on line 4, uses the standard form: the term <TT>printf</TT>, followed by a quoted
string with a conversion specifier (in this case <TT>%s</TT>), followed by a value
to insert into the conversion specifier.</P>
<P>The <TT>%s</TT> indicates that this is a string, and the value for the string
is, in this case, the quoted string <TT>&quot;hello world&quot;.</TT></P>
<P>The second <TT>printf()</TT> statement is just like the first, but this time a
<TT>char</TT> pointer is used, rather than quoting the string right in place in the
<TT>printf()</TT> statement.</P>
<P>The third <TT>printf()</TT>, on line 10, uses the integer conversion specifier,
and for its value the integer variable <TT>x</TT>. The fourth <TT>printf()</TT> statement,
on line 18, is more complex. Here six values are concatenated. Each conversion specifier
is supplied, and then the values are provided, separated by commas.</P>
<P>Finally, on line 21, format specifications are used to specify width and precision.
As you can see, all of this is somewhat easier than using manipulators.</P>
<P>As stated previously, however, the limitation here is that there is no type checking
and <TT>printf()</TT> cannot be declared a friend or member function of a class.
So if you want to print the various member data of a class, you must feed each accessor
method to the <TT>printf()</TT> statement explicitly.
<CENTER>
<H3><A NAME="Heading51"></A><FONT COLOR="#000077">File Input and Output</FONT></H3>
</CENTER>
<P>Streams provide a uniform way of dealing with data coming from the keyboard or
the hard disk and going out to the screen or hard disk. In either case, you can use
the insertion and extraction operators or the other related functions and manipulators.
To open and close files, you create <TT>ifstream</TT> and <TT>ofstream</TT> objects
as described in the next few sections.
<CENTER>
<H3><A NAME="Heading52"></A><FONT COLOR="#000077">ofstream</FONT></H3>
</CENTER>
<P>The particular objects used to read from or write to files are called <TT>ofstream</TT>
objects. These are derived from the <TT>iostream</TT> objects you've been using so
far.</P>
<P>To get started with writing to a file, you must first create an <TT>ofstream</TT>
object, and then associate that object with a particular file on your disk. To use
<TT>ofstream</TT> objects, you must be sure to include <TT>fstream.h</TT> in your
program.


<BLOCKQUOTE>
	<P>
<HR>
<FONT COLOR="#000077"><B>NOTE:</B></FONT><B> </B>Because <TT>fstream.h</TT> includes
	<TT>iostream.h</TT>, there is no need for you to include <TT>iostream</TT> explicitly.
	
<HR>


</BLOCKQUOTE>

<CENTER>
<H4><A NAME="Heading53"></A><FONT COLOR="#000077">Condition States</FONT></H4>
</CENTER>
<P>The <TT>iostream</TT> objects maintain flags that report on the state of your
input and output. You can check each of these flags using the Boolean functions <TT>eof()</TT>,
<TT>bad()</TT>, <TT>fail()</TT>, and <TT>good()</TT>. The function <TT>eof()</TT>
returns true if the <TT>iostream</TT> object has encountered EOF, end of file. The
function <TT>bad()</TT> returns <TT>TRUE</TT> if you attempt an invalid operation.
The function <TT>fail()</TT> returns <TT>TRUE</TT> anytime <TT>bad()</TT> is true
or an operation fails. Finally, the function <TT>good()</TT> returns <TT>TRUE</TT>
anytime all three of the other functions are <TT>FALSE</TT>.
<CENTER>
<H4><A NAME="Heading54"></A><FONT COLOR="#000077">Opening Files for Input and Output</FONT></H4>
</CENTER>
<P>To open the file <TT>myfile.cpp</TT> with an <TT>ofstream</TT> object, declare
an instance of an <TT>ofstream</TT> object and pass in the filename as a parameter:</P>
<PRE><FONT COLOR="#0066FF">ofstream fout(&quot;myfile.cpp&quot;);
</FONT></PRE>
<P>Opening this file for input works exactly the same way, except it uses an <TT>ifstream</TT>
object:</P>
<PRE><FONT COLOR="#0066FF">ifstream fin(&quot;myfile.cpp&quot;);
</FONT></PRE>
<P>Note that <TT>fout</TT> and <TT>fin</TT> are names you assign; here <TT>fout</TT>
has been used to reflect its similarity to <TT>cout</TT>, and <TT>fin</TT> has been
used to reflect its similarity to <TT>cin</TT>.</P>
<P>One important file stream function that you will need right away is <TT>close()</TT>.
Every file stream object you create opens a file for either reading or writing (or
both). It is important to <TT>close()</TT> the file after you finish reading or writing;
this ensures that the file won't be corrupted and that the data you've written is
flushed to the disk.</P>
<P>Once the stream objects are associated with files, they can be used like any other
stream objects. Listing 16.16 illustrates this.</P>
<P><A NAME="Heading55"></A><FONT SIZE="4" COLOR="#000077"><B>Listing 16.16. Opening
files for read and write.</B></FONT></P>
<PRE><FONT COLOR="#0066FF">1:     #include &lt;fstream.h&gt;
2:     int main()
3:     {
4:        char fileName[80];
5:        char buffer[255];    // for user input
6:        cout &lt;&lt; &quot;File name: &quot;;
7:        cin &gt;&gt; fileName;
8:
9:        ofstream fout(fileName);  // open for writing
10:       fout &lt;&lt; &quot;This line written directly to the file...\n&quot;;
11:       cout &lt;&lt; &quot;Enter text for the file: &quot;;
12:       cin.ignore(1,'\n');  // eat the newline after the file name
13:       cin.getline(buffer,255);  // get the user's input
14:       fout &lt;&lt; buffer &lt;&lt; &quot;\n&quot;;   // and write it to the file
15:       fout.close();             // close the file, ready for reopen
16:
17:       ifstream fin(fileName);    // reopen for reading
18:       cout &lt;&lt; &quot;Here's the contents of the file:\n&quot;;
19:       char ch;
20:       while (fin.get(ch))
21:          cout &lt;&lt; ch;
22:
23:       cout &lt;&lt; &quot;\n***End of file contents.***\n&quot;;
24:
25:       fin.close();            // always pays to be tidy
26:     return 0;
<TT>27: }</TT></FONT>
<FONT COLOR="#0066FF">
Output: File name: test1
Enter text for the file: This text is written to the file!
Here's the contents of the file:
This line written directly to the file...
This text is written to the file!

***End of file contents.***</FONT></PRE>
<P><FONT COLOR="#000077"><B>Analysis:</B></FONT><B> </B>On line 4, a buffer is set
aside for the filename, and on line 5 another buffer is set aside for user input.
The user is prompted to enter a filename on line 6, and this response is written
to the <TT>fileName</TT> buffer. On line 9, an <TT>ofstream</TT> object is created,
<TT>fout</TT>, which is associated with the new filename. This opens the file; if
the file already exists, its contents are thrown away.</P>
<P>On line 10, a string of text is written directly to the file. On line 11, the
user is prompted for input. The newline character left over from the user's input
of the filename is eaten on line 12, and the user's input is stored into <TT>buffer</TT>
on line 13. That input is written to the file along with a newline character on line
14, and then the file is closed on line 15.</P>
<P>On line 17, the file is reopened, this time in input mode, and the contents are
read, one character at a time, on lines 20 and 21.
<CENTER>
<H4><A NAME="Heading57"></A><FONT COLOR="#000077">Changing the Default Behavior of
ofstream on Open</FONT></H4>
</CENTER>
<P>The default behavior upon opening a file is to create the file if it doesn't yet
exist and to truncate the file (that is, delete all its contents) if it does exist.
If you don't want this default behavior, you can explicitly provide a second argument
to the constructor of your <TT>ofstream</TT> object.</P>
<P>Valid arguments include:

<UL>
	<LI><TT>ios::app</TT>--Appends to the end of existing files rather than truncating
	them.
	<P>
	<LI><TT>ios::at</TT>--Places you at the end of the file, but you can write data anywhere
	in the file.
	<P>
	<LI><TT>ios::trun</TT>--The default. Causes existing files to be truncated.
	<P>
	<LI><TT>ios::nocreat</TT>--If the file does not exist, the open fails.
	<P>
	<LI><TT>ios::noreplac</TT>--If the file does already exist, the open fails.
</UL>

<P>Note that <TT>app</TT> is short for append; <TT>ate</TT> is short for at end,
and <TT>trunc</TT> is short for truncate. Listing 16.17 illustrates using append
by reopening the file from Listing 16.16 and appending to it.</P>
<P><A NAME="Heading58"></A><FONT SIZE="4" COLOR="#000077"><B>Listing 16.17. Appending
to the end of a file.</B></FONT></P>
<PRE><FONT COLOR="#0066FF">1:     #include &lt;fstream.h&gt;
2:     int main()   // returns 1 on error
3:     {
4:        char fileName[80];
5:        char buffer[255];
6:        cout &lt;&lt; &quot;Please re-enter the file name: &quot;;
7:        cin &gt;&gt; fileName;
8:
9:        ifstream fin(fileName);
10:       if (fin)                // already exists?
11:       {
12:          cout &lt;&lt; &quot;Current file contents:\n&quot;;
13:          char ch;
14:          while (fin.get(ch))
15:             cout &lt;&lt; ch;
16:          cout &lt;&lt; &quot;\n***End of file contents.***\n&quot;;
17:       }
18:       fin.close();
19:
20:       cout &lt;&lt; &quot;\nOpening &quot; &lt;&lt; fileName &lt;&lt; &quot; in append mode...\n&quot;;
21:
22:       ofstream fout(fileName,ios::app);
23:       if (!fout)
24:       {
25:          cout &lt;&lt; &quot;Unable to open &quot; &lt;&lt; fileName &lt;&lt; &quot; for appending.\n&quot;;
26:          return(1);
27:       }
28:
29:       cout &lt;&lt; &quot;\nEnter text for the file: &quot;;
30:       cin.ignore(1,'\n');
31:       cin.getline(buffer,255);
32:       fout &lt;&lt; buffer &lt;&lt; &quot;\n&quot;;
33:       fout.close();
34:
35:       fin.open(fileName);  // reassign existing fin object!
36:       if (!fin)
37:       {
38:          cout &lt;&lt; &quot;Unable to open &quot; &lt;&lt; fileName &lt;&lt; &quot; for reading.\n&quot;;
39:          return(1);
40:       }
41:       cout &lt;&lt; &quot;\nHere's the contents of the file:\n&quot;;
42:       char ch;
43:       while (fin.get(ch))
44:          cout &lt;&lt; ch;
45:       cout &lt;&lt; &quot;\n***End of file contents.***\n&quot;;
46:       fin.close();
47:       return 0;
<TT>48: }</TT></FONT>
<FONT COLOR="#0066FF">
Output: Please re-enter the file name: test1
Current file contents:
This line written directly to the file...
This text is written to the file!

***End of file contents.***

Opening test1 in append mode...

Enter text for the file: More text for the file!

Here's the contents of the file:
This line written directly to the file...
This text is written to the file!
More text for the file!

***End of file contents.***
</FONT></PRE>
<P><FONT COLOR="#000077"><B>Analysis</B></FONT><FONT COLOR="#000000"><B>:</B></FONT><B>
</B>The user is again prompted to enter the filename. This time an input file stream
object is created on line 9. That open is tested on line 10, and if the file already
exists, its contents are printed on lines 12 to 16. Note that <TT>if(fin)</TT> is
synonymous with <TT>if (fin.good())</TT>.</P>
<P>The input file is then closed, and the same file is reopened, this time in append
mode, on line 22. After this open (and every open), the file is tested to ensure
that the file was opened properly. Note that <TT>if(!fout)</TT> is the same as testing
<TT>if (fout.fail())</TT>. The user is then prompted to enter text, and the file
is closed again on line 33.</P>
<P>Finally, as in Listing 16.16, the file is reopened in read mode; however, this
time <TT>fin</TT> does not need to be redeclared. It is just reassigned to the same
filename. Again the open is tested, on line 36, and if all is well, the contents
of the file are printed to the screen and the file is closed for the final time.


<BLOCKQUOTE>
	<P>
<HR>
<B>DO</B> test each open of a file to ensure that it opened successfully. <B>DO </B>reuse
	existing <TT>ifstream</TT> and <TT>ofstream</TT> objects.<B> DO</B> close all <TT>fstream</TT>
	objects when you are done using them<B>. DON'T</B> try to close or reassign <TT>cin</TT>
	or <TT>cout</TT>. 
<HR>


</BLOCKQUOTE>

<CENTER>
<H3><A NAME="Heading60"></A><FONT COLOR="#000077">Binary Versus Text Files</FONT></H3>
</CENTER>
<P>Some operating systems, such as DOS, distinguish between text files and binary
files. Text files store everything as text (as you might have guessed), so large
numbers such as 54,325 are stored as a string of numerals (`5', `4', `,', `3', `2',
`5'). This can be inefficient, but has the advantage that the text can be read using
simple programs such as the DOS program type.</P>
<P>To help the file system distinguish between text and binary files, C++ provides
the <TT>ios::binary</TT> flag. On many systems, this flag is ignored because all
data is stored in binary format. On some rather prudish systems, the <TT>ios::binary</TT>
flag is illegal and won't compile!</P>
<P>Binary files can store not only integers and strings, but entire data structures.
You can write all the data at one time by using the <TT>write()</TT> method of <TT>fstream</TT>.</P>
<P>If you use <TT>write()</TT>, you can recover the data using <TT>read()</TT>. Each
of these functions expects a pointer to character, however, so you must cast the
address of your class to be a pointer to character.</P>
<P>The second argument to these functions is the number of characters to write, which
you can determine using <TT>sizeof()</TT>. Note that what is being written is just
the data, not the methods. What is recovered is just data. Listing 16.18 illustrates
writing the contents of a class to a file.</P>
<P><A NAME="Heading61"></A><FONT SIZE="4" COLOR="#000077"><B>Listing 16.18. Writing
a class to a file.</B></FONT></P>
<PRE><FONT COLOR="#0066FF">1:     #include &lt;fstream.h&gt;
2:
3:     class Animal
4:     {
5:     public:
6:        Animal(int weight, long days):itsWeight(weight),itsNumberDaysAlive(days){}
7:        ~Animal(){}
8:
9:        int GetWeight()const { return itsWeight; }
10:       void SetWeight(int weight) { itsWeight = weight; }
11:
12:       long GetDaysAlive()const { return  itsNumberDaysAlive; }
13:       void SetDaysAlive(long days) { itsNumberDaysAlive = days; }
14:
15:    private:
16:       int itsWeight;
17:       long itsNumberDaysAlive;
18:    };
19:
20:    int main()   // returns 1 on error
21:    {
22:       char fileName[80];
23:       char buffer[255];
24:
25:       cout &lt;&lt; &quot;Please enter the file name: &quot;;
26:       cin &gt;&gt; fileName;
27:       ofstream fout(fileName,ios::binary);
28:       if (!fout)
29:       {
30:          cout &lt;&lt; &quot;Unable to open &quot; &lt;&lt; fileName &lt;&lt; &quot; for writing.\n&quot;;
31:          return(1);
32:       }
33:
34:       Animal Bear(50,100);
35:       fout.write((char*) &amp;Bear,sizeof Bear);
36:
37:       fout.close();
38:
39:       ifstream fin(fileName,ios::binary);
40:       if (!fin)
41:       {
42:          cout &lt;&lt; &quot;Unable to open &quot; &lt;&lt; fileName &lt;&lt; &quot; for reading.\n&quot;;
43:          return(1);
44:       }
45:
46:       Animal BearTwo(1,1);
47:
48:       cout &lt;&lt; &quot;BearTwo weight: &quot; &lt;&lt; BearTwo.GetWeight() &lt;&lt; endl;
49:       cout &lt;&lt; &quot;BearTwo days: &quot; &lt;&lt; BearTwo.GetDaysAlive() &lt;&lt; endl;
50:
51:       fin.read((char*) &amp;BearTwo, sizeof BearTwo);
52:
53:       cout &lt;&lt; &quot;BearTwo weight: &quot; &lt;&lt; BearTwo.GetWeight() &lt;&lt; endl;
54:       cout &lt;&lt; &quot;BearTwo days: &quot; &lt;&lt; BearTwo.GetDaysAlive() &lt;&lt; endl;
55:       fin.close();
56:       return 0;
</FONT></PRE>
<P><TT>57: }</TT></P>
<PRE><FONT COLOR="#0066FF">
Output: Please enter the file name: Animals
BearTwo weight: 1
BearTwo days: 1
BearTwo weight: 50
BearTwo days: 100
</FONT></PRE>
<P><FONT COLOR="#000077"><B>Analysis</B></FONT><B>: </B>On lines 3-18, a stripped-down
<TT>Animal</TT> class is declared. On lines 22-32, a file is created and opened for
output in binary mode. An animal whose weight is 50 and who is 100 days old is created
on line 34, and its data is written to the file on line 35.</P>
<P>The file is closed on line 37 and reopened for reading in binary mode on line
39. A second animal is created on line 46 whose weight is 1 and who is only one day
old. The data from the file is read into the new animal object on line 51, wiping
out the existing data and replacing it with the data from the file.
<CENTER>
<H3><A NAME="Heading63"></A><FONT COLOR="#000077">Command-Line Processing</FONT></H3>
</CENTER>
<P>Many operating systems, such as DOS and UNIX, enable the user to pass parameters
to your program when the program starts. These are called command-line options, and
are typically separated by spaces on the command line. For example:</P>
<PRE><FONT COLOR="#0066FF">SomeProgram Param1 Param2 Param3
</FONT></PRE>
<P>These parameters are not passed to <TT>main()</TT> directly. Instead, every program's
<TT>main()</TT> function is passed two parameters. The first is an integer count
of the number of arguments on the command line. The program name itself is counted,
so every program has at least one parameter. The example command line shown previously
has four. (The name <TT>SomeProgram</TT> plus the three parameters make a total of
four command-line arguments.)</P>
<P>The second parameter passed to <TT>main()</TT> is an array of pointers to character
strings. Because an array name is a constant pointer to the first element of the
array, you can declare this argument to be a pointer to a pointer to <TT>char</TT>,
a pointer to an array of <TT>char</TT>, or an array of arrays of <TT>char</TT>.</P>
<P>Typically, the first argument is called <TT>argc</TT> (argument count), but you
may call it anything you like. The second argument is often called <TT>argv</TT>
(argument vector), but again this is just a convention.</P>
<P>It is common to test <TT>argc</TT> to ensure you've received the expected number
of arguments, and to use <TT>argv</TT> to access the strings themselves. Note that
<TT>argv[0]</TT> is the name of the program, and <TT>argv[1]</TT> is the first parameter
to the program, represented as a string. If your program takes two numbers as arguments,
you will need to translate these numbers to strings. On Day 21 you will see how to
use the standard library conversions. Listing 16.19 illustrates how to use the command-line
arguments.</P>
<P><A NAME="Heading64"></A><FONT SIZE="4" COLOR="#000077"><B>Listing 16.19. Using
command-line arguments.</B></FONT></P>
<PRE><FONT COLOR="#0066FF">1:     #include &lt;iostream.h&gt;
2:     int main(int argc, char **argv)
3:     {
4:        cout &lt;&lt; &quot;Received &quot; &lt;&lt; argc &lt;&lt; &quot; arguments...\n&quot;;
5:        for (int i=0; i&lt;argc; i++)
6:           cout &lt;&lt; &quot;argument &quot; &lt;&lt; i &lt;&lt; &quot;: &quot; &lt;&lt; argv[i] &lt;&lt; endl;
7:     return 0;
<TT>8: }</TT></FONT>
<FONT COLOR="#0066FF">
Output: TestProgram  Teach Yourself C++ In 21 Days
Received 7 arguments...
argumnet 0: TestProgram.exe
argument 1: Teach
argument 2: Yourself
argument 3: C++
argument 4: In
argument 5: 21
argument 6: Days
</FONT></PRE>
<P><FONT COLOR="#000077"><B>Analysis</B></FONT><B>: </B>The function <TT>main()</TT>
declares two arguments: <TT>argc</TT> is an integer that contains the count of command-line
arguments, and <TT>argv</TT> is a pointer to the array of strings. Each string in
the array pointed to by <TT>argv</TT> is a command-line argument. Note that <TT>argv</TT>
could just as easily have been declared as <TT>char *argv[]</TT> or <TT>char argv[][]</TT>.
It is a matter of programming style how you declare <TT>argv</TT>; even though this
program declared it as a pointer to a pointer, array offsets were still used to access
the individual strings.</P>
<P>On line 4, <TT>argc</TT> is used to print the number of command-line arguments:
seven in all, counting the program name itself.</P>
<P>On lines 5 and 6, each of the command-line arguments is printed, passing the null-terminated
strings to <TT>cout</TT> by indexing into the array of strings.</P>
<P>A more common use of command-line arguments is illustrated by modifying Listing
16.18 to take the filename as a command-line argument. This listing does not include
the class declaration, which is unchanged.</P>
<P><A NAME="Heading66"></A><FONT SIZE="4" COLOR="#000077"><B>Listing 16.20. Using
command-line arguments.</B></FONT></P>
<PRE><FONT COLOR="#0066FF">1:     #include &lt;fstream.h&gt;
2:     int main(int argc, char *argv[])   // returns 1 on error
3:     {
4:        if (argc != 2)
5:        {
6:           cout &lt;&lt; &quot;Usage: &quot; &lt;&lt; argv[0] &lt;&lt; &quot; &lt;filename&gt;&quot; &lt;&lt; endl;
7:           return(1);
8:        }
9:
10:       ofstream fout(argv[1],ios::binary);
11:       if (!fout)
12:       {
13:          cout &lt;&lt; &quot;Unable to open &quot; &lt;&lt; argv[1] &lt;&lt; &quot; for writing.\n&quot;;
14:          return(1);
15:       }
16:
17:       Animal Bear(50,100);
18:       fout.write((char*) &amp;Bear,sizeof Bear);
19:
20:       fout.close();
21:
22:       ifstream fin(argv[1],ios::binary);
23:       if (!fin)
24:       {
25:          cout &lt;&lt; &quot;Unable to open &quot; &lt;&lt; argv[1] &lt;&lt; &quot; for reading.\n&quot;;
26:          return(1);
27:       }
28:
29:       Animal BearTwo(1,1);
30:
31:       cout &lt;&lt; &quot;BearTwo weight: &quot; &lt;&lt; BearTwo.GetWeight() &lt;&lt; endl;
32:       cout &lt;&lt; &quot;BearTwo days: &quot; &lt;&lt; BearTwo.GetDaysAlive() &lt;&lt; endl;
33:
34:       fin.read((char*) &amp;BearTwo, sizeof BearTwo);
35:
36:       cout &lt;&lt; &quot;BearTwo weight: &quot; &lt;&lt; BearTwo.GetWeight() &lt;&lt; endl;
37:       cout &lt;&lt; &quot;BearTwo days: &quot; &lt;&lt; BearTwo.GetDaysAlive() &lt;&lt; endl;
38:       fin.close();
39:       return 0;
<TT>40: }</TT></FONT>
<FONT COLOR="#0066FF">
Output: BearTwo weight: 1
BearTwo days: 1
BearTwo weight: 50
BearTwo days: 100
</FONT></PRE>
<P><FONT COLOR="#000077"><B>Analysis</B></FONT><B>: </B>The declaration of the <TT>Animal</TT>
class is the same as in Listing 16.18, and so is left out of this example. This time,
however, rather than prompting the user for the filename, command-line arguments
are used. On line 2, <TT>main()</TT> is declared to take two parameters: the count
of the command-line arguments and a pointer to the array of command-line argument
strings.</P>
<P>On lines 4-8, the program ensures that the expected number of arguments (exactly
two) is received. If the user fails to supply a single filename, an error message
is printed:</P>
<PRE><FONT COLOR="#0066FF">Usage TestProgram &lt;filename&gt;
</FONT></PRE>
<P>Then the program exits. Note that by using <TT>argv[0]</TT> rather than hard-coding
a program name, you can compile this program to have any name, and this usage statement
will work automatically.</P>
<P>On line 10, the program attempts to open the supplied filename for binary output.
There is no reason to copy the filename into a local temporary buffer. It can be
used directly by accessing <TT>argv[1]</TT>.</P>
<P>This technique is repeated on line 22 when the same file is reopened for input,
and is used in the error condition statements when the files cannot be opened, on
lines 13 and 25.
<CENTER>
<H3><A NAME="Heading67"></A><FONT COLOR="#000077">Summary</FONT></H3>
</CENTER>
<P>Today streams were introduced, and the global objects <TT>cout</TT> and <TT>cin</TT>
were described. The goal of the <TT>istream</TT> and <TT>ostream</TT> objects is
to encapsulate the work of writing to device drivers and buffering input and output.</P>
<P>There are four standard stream objects created in every program: <TT>cout</TT>,
<TT>cin</TT>, <TT>cerr</TT>, and <TT>clog</TT>. Each of these can be &quot;redirected&quot;
by many operating systems.</P>
<P>The <TT>istream</TT> object <TT>cin</TT> is used for input, and its most common
use is with the overloaded extraction operator (<TT>&gt;&gt;</TT>). The <TT>ostream</TT>
object <TT>cout</TT> is used for output, and its most common use is with the overloaded
insertion operator (<TT>&lt;&lt;</TT>).</P>
<P>Each of these objects has a number of other member functions, such as <TT>get()</TT>
and <TT>put()</TT>. Because the common forms of each of these methods returns a reference
to a stream object, it is easy to concatenate each of these operators and functions.</P>
<P>The state of the stream objects can be changed by using manipulators. These can
set the formatting and display characteristics and various other attributes of the
stream objects.</P>
<P>File I/O can be accomplished by using the <TT>fstream</TT> classes, which derive
from the <TT>stream</TT> classes. In addition to supporting the normal insertion
and extraction operators, these objects also support <TT>read()</TT> and <TT>write()</TT>
for storing and retrieving large binary objects.
<CENTER>
<H3><A NAME="Heading68"></A><FONT COLOR="#000077">Q&amp;A</FONT></H3>
</CENTER>

<DL>
	<DD><B>Q. How do you know when to use the insertion and extraction operators and
	when to use the other member functions of the stream classes?<BR>
	</B><BR>
	<B>A.</B> In general, it is easier to use the insertion and extraction operators,
	and they are preferred when their behavior is what is needed. In those unusual circumstances
	when these operators don't do the job (such as reading in a string of words), the
	other functions can be used.<BR>
	<BR>
	<B>Q. What is the difference between cerr and clog?<BR>
	</B><BR>
	<B>A.</B> <TT>cerr</TT> is not buffered. Everything written to <TT>cerr</TT> is immediately
	written out. This is fine for errors to be written to the screen, but may have too
	high a performance cost for writing logs to disk. <TT>clog</TT> buffers its output,
	and thus can be more efficient.<BR>
	<BR>
	<B>Q. Why were streams created if printf() works well?<BR>
	</B><BR>
	<B>A.</B> <TT>printf()</TT> does not support the strong type system of C++, and it
	does not support user-defined classes.<BR>
	<BR>
	<B>Q. When would you ever use putback()?<BR>
	</B><BR>
	<B>A. </B>When one read operation is used to determine whether or not a character
	is valid, but a different read operation (perhaps by a different object) needs the
	character to be in the buffer. This is most often used when parsing a file; for example,
	the C++ compiler might use <TT>putback()</TT>.<BR>
	<BR>
	<B>Q. When would you use ignore()?<BR>
	</B><BR>
	<B>A.</B> A common use of this is after using <TT>get()</TT>. Because <TT>get()</TT>
	leaves the terminating character in the buffer, it is not uncommon to immediately
	follow a call to <TT>get()</TT> with a call to <TT>ignore(1,'\n');</TT>. Once again,
	this is often used in parsing.<BR>
	<BR>
	<B>Q. My friends use printf() in their C++ programs. Can I?<BR>
	</B><BR>
	<B>A.</B> Sure. You'll gain some convenience, but you'll pay by sacrificing type
	safety.
</DL>

<CENTER>
<H3><A NAME="Heading69"></A><FONT COLOR="#000077">Workshop</FONT></H3>
</CENTER>
<P>The Workshop contains quiz questions to help solidify your understanding of the
material covered and exercises to provide you with experience in using what you've
learned. Try to answer the quiz and exercise questions before checking the answers
in Appendix D, and make sure you understand the answers before going to the next
chapter.
<CENTER>
<H4><A NAME="Heading70"></A><FONT COLOR="#000077">Quiz</FONT></H4>
</CENTER>

<DL>
	<DD><B>1.</B> What is the insertion operator, and what does it do?<BR>
	<BR>
	<B>2.</B> What is the extraction operator, and what does it do?<BR>
	<BR>
	<B>3.</B> What are the three forms of <TT>cin.get()</TT>, and what are their differences?<BR>
	<BR>
	<B>4.</B> What is the difference between <TT>cin.read()</TT> and <TT>cin.getline()</TT>?<BR>
	<BR>
	<B>5.</B> What is the default width for outputting a long integer using the insertion
	operator?<BR>
	<BR>
	<B>6.</B> What is the return value of the insertion operator?<BR>
	<BR>
	<B>7.</B> What parameter does the constructor to an <TT>ofstream</TT> object take?<BR>
	<BR>
	<B>8.</B> What does the <TT>ios::ate</TT> argument do?
</DL>

<CENTER>
<H4><A NAME="Heading71"></A><FONT COLOR="#000077">Exercises</FONT></H4>
</CENTER>

<DL>
	<DD><B>1.</B> Write a program that writes to the four standard iostream objects:
	<TT>cin</TT>, <TT>cout</TT>, <TT>cerr</TT>, and <TT>clog</TT>.<BR>
	<B><BR>
	2</B>. Write a program that prompts the user to enter her full name and then displays
	it on the screen.<BR>
	<B><BR>
	3.</B> Rewrite Listing 16.9 to do the same thing, but without using <TT>putback()</TT>
	or <TT>ignore()</TT>.<BR>
	<B><BR>
	4.</B> Write a program that takes a filename as a parameter and opens the file for
	reading. Read every character of the file and display only the letters and punctuation
	to the screen. (Ignore all nonprinting characters.) Then close the file and exit.<BR>
	<B><BR>
	5.</B> Write a program that displays its command-line arguments in reverse order
	and does not display the program name.<BR>
	
	<P ALIGN="CENTER"><A HREF="ch15.htm"><IMG SRC="../buttons/BLANPREV.GIF"
	WIDTH="37" HEIGHT="37" ALIGN="BOTTOM" BORDER="0"></A><A HREF="http://www.mcp.com/sams"><IMG
	SRC="../buttons/BLANHOME.GIF" WIDTH="37" HEIGHT="37" ALIGN="BOTTOM"
	BORDER="0"></A><A HREF="../index.htm"><IMG SRC="../buttons/BLANTOC.GIF"
	WIDTH="37" HEIGHT="37" ALIGN="BOTTOM" BORDER="0"></A><A HREF="ch17.htm"><IMG SRC="../buttons/BLANNEXT.GIF"
	WIDTH="37" HEIGHT="37" ALIGN="BOTTOM" BORDER="0"></A><A HREF="#heading1"><IMG SRC="../buttons/BLANTOP.GIF"
	WIDTH="37" HEIGHT="37" ALIGN="BOTTOM" BORDER="0"></A>
</DL>



</BODY>

</HTML>