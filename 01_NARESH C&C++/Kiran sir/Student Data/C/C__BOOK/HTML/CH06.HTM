<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>

<HEAD>
<!-- This document was created from RTF source by rtftohtml version 3.0.1 -->

	<META NAME="GENERATOR" Content="Symantec Visual Page 1.0">
	<META HTTP-EQUIV="Content-Type" CONTENT="text/html;CHARSET=iso-8859-1">
	<TITLE>Teach Yourself C++ in 21 Days</TITLE>
</HEAD>

<BODY TEXT="#000000" BGCOLOR="#FFFFFF">

<H1 ALIGN="CENTER"><A HREF="ch05.htm"><IMG SRC="../buttons/BLANPREV.GIF"
WIDTH="37" HEIGHT="37" ALIGN="BOTTOM" BORDER="0"></A><A HREF="http://www.mcp.com/sams"><IMG
SRC="../buttons/BLANHOME.GIF" WIDTH="37" HEIGHT="37" ALIGN="BOTTOM"
BORDER="0"></A><A HREF="../index.htm"><IMG SRC="../buttons/BLANTOC.GIF"
WIDTH="37" HEIGHT="37" ALIGN="BOTTOM" BORDER="0"></A><A HREF="ch07.htm"><IMG SRC="../buttons/BLANNEXT.GIF"
WIDTH="37" HEIGHT="37" ALIGN="BOTTOM" BORDER="0"></A></H1>
<H1></H1>

<UL>
	<LI><A HREF="#Heading1">Day 6</A>
	<UL>
		<LI><A HREF="#Heading2">Basic Classes</A>
		<UL>
			<LI><A HREF="#Heading3">Creating New Types</A>
			<UL>
				<LI><A HREF="#Heading4">Why Create a New Type?</A>
			</UL>
			<LI><A HREF="#Heading5">Classes and Members</A>
			<UL>
				<LI><A HREF="#Heading6">Declaring a Class</A>
				<LI><A HREF="#Heading7">A Word on Naming Conventions</A>
				<LI><A HREF="#Heading8">Defining an Object</A>
				<LI><A HREF="#Heading9">Classes Versus Objects</A>
			</UL>
			<LI><A HREF="#Heading10">Accessing Class Members</A>
			<UL>
				<LI><A HREF="#Heading11">Assign to Objects, Not to Classes</A>
				<LI><A HREF="#Heading12">If You Dont Declare It, Your Class Wont Have It</A>
			</UL>
			<LI><A HREF="#Heading13">Private Versus Public</A>
			<LI><A HREF="#Heading14">Listing 6.1. Accessing the public members</A>
			<LI><A HREF="#Heading15">of a simple class.</A>
			<UL>
				<LI><A HREF="#Heading16">Make Member Data Private</A>
			</UL>
			<LI><A HREF="#Heading17">Listing 6.2. A class with accessor methods</A><A HREF="#Heading18">.</A>
			<UL>
				<LI><A HREF="#Heading19">Privacy Versus Security</A>
			</UL>
			<LI><A HREF="#Heading20">The class keyword</A>
			<LI><A HREF="#Heading21">Implementing Class Methods</A>
			<LI><A HREF="#Heading22">Listing 6.3. Implementing</A>
			<LI><A HREF="#Heading23">the methods of a simple class.</A>
			<LI><A HREF="#Heading24">Constructors and Destructors</A>
			<UL>
				<LI><A HREF="#Heading25">Default Constructors and Destructors</A>
			</UL>
			<LI><A HREF="#Heading26">Listing 6.4. Using constructors and destructors</A><A HREF="#Heading27">.</A>
			<LI><A HREF="#Heading28">const Member Functions</A>
			<LI><A HREF="#Heading29">Interface Versus Implementation</A>
			<LI><A HREF="#Heading30">Listing 6.5. A demonstration of violations of the interface</A><A
			HREF="#Heading31">.</A>
			<LI><A HREF="#Heading32">Why Use the Compiler to Catch Errors?</A>
			<LI><A HREF="#Heading33">Where to Put Class Declarations and Method Definitions</A>
			<LI><A HREF="#Heading34">Inline Implementation</A>
			<LI><A HREF="#Heading35">Listing 6.6. Cat class declaration in CAT.HPP</A><A HREF="#Heading36">.</A>
			<LI><A HREF="#Heading37">Listing 6.7. Cat implementation in CAT.CPP.</A>
			<LI><A HREF="#Heading38">Classes with Other Classes as Member Data</A>
			<LI><A HREF="#Heading40">Listing 6.8. Declaring a complete class</A><A HREF="#Heading41">.</A>
			<LI><A HREF="#Heading42">Listing 6.9. RECT.CPP</A><A HREF="#Heading43">.</A>
			<LI><A HREF="#Heading44">Structures</A>
			<UL>
				<LI><A HREF="#Heading45">Why Two Keywords Do the Same Thing</A>
			</UL>
			<LI><A HREF="#Heading46">Summary</A>
			<LI><A HREF="#Heading47">Q&amp;A</A>
			<LI><A HREF="#Heading48">Workshop</A>
			<UL>
				<LI><A HREF="#Heading49">Quiz</A>
				<LI><A HREF="#Heading50">Exercises</A>
			</UL>
		</UL>
	</UL>
</UL>

<P>
<HR SIZE="4">

<H2 ALIGN="CENTER"><A NAME="Heading1"></A><FONT COLOR="#000077">Day 6</FONT></H2>

<H2 ALIGN="CENTER"><A NAME="Heading2"></A><FONT COLOR="#000077">Basic Classes</FONT></H2>
<P>Classes extend the built-in capabilities of C++ to assist you in representing
and solving complex, real-world problems. Today you will learn

<UL>
	<LI>What classes and objects are.
	<P>
	<LI>How to define a new class and create objects of that class.
	<P>
	<LI>What member functions and member data are.
	<P>
	<LI>What constructors are and how to use them.
</UL>

<H3 ALIGN="CENTER"><A NAME="Heading3"></A><FONT COLOR="#000077">Creating New Types</FONT></H3>
<P>You've already learned about a number of variable types, including unsigned integers
and characters. The type of a variable tells you quite a bit about it. For example,
if you declare <TT>Height</TT> and <TT>Width</TT> to be unsigned integers, you know
that each one can hold a number between 0 and 65,535, assuming an integer is two
bytes. That is the meaning of saying they are unsigned integers; trying to hold anything
else in these variables causes an error. You can't store your name in an unsigned
short integer, and you shouldn't try.</P>
<P>Just by declaring these variables to be unsigned short integers, you know that
it is possible to add <TT>Height</TT> to <TT>Width</TT> and to assign that number
to another number.</P>
<P>The type of these variables tells you:

<UL>
	<LI>Their size in memory.
	<P>
	<LI>What information they can hold.
	<P>
	<LI>What actions can be performed on them.
</UL>

<P>More generally, a type is a category. Familiar types include car, house, person,
fruit, and shape. In C++, the programmer can create any type needed, and each of
these new types can have all the functionality and power of the built-in types.
<H4 ALIGN="CENTER"><A NAME="Heading4"></A><FONT COLOR="#000077">Why Create a New
Type?</FONT></H4>
<P>Programs are usually written to solve real-world problems, such as keeping track
of employee records or simulating the workings of a heating system. Although it is
possible to solve complex problems by using programs written with only integers and
characters, it is far easier to grapple with large, complex problems if you can create
representations of the objects that you are talking about. In other words, simulating
the workings of a heating system is easier if you can create variables that represent
rooms, heat sensors, thermostats, and boilers. The closer these variables correspond
to reality, the easier it is to write the program.
<H3 ALIGN="CENTER"><A NAME="Heading5"></A><FONT COLOR="#000077">Classes and Members</FONT></H3>
<P>You make a new type by declaring a class. A class is just a collection of variables--often
of different types--combined with a set of related functions.</P>
<P>One way to think about a car is as a collection of wheels, doors, seats, windows,
and so forth. Another way is to think about what a car can do: It can move, speed
up, slow down, stop, park, and so on. A class enables you to encapsulate, or bundle,
these various parts and various functions into one collection, which is called an
object.</P>
<P>Encapsulating everything you know about a car into one class has a number of advantages
for a programmer. Everything is in one place, which makes it easy to refer to, copy,
and manipulate the data. Likewise, clients of your class--that is, the parts of the
program that use your class--can use your object without worry about what is in it
or how it works.</P>
<P>A class can consist of any combination of the variable types and also other class
types. The variables in the class are referred to as the member variables or data
members. A <TT>Car</TT> class might have member variables representing the seats,
radio type, tires, and so forth.</P>

<DL>
	<DD>
<HR>
<FONT COLOR="#000077"><B>New Term:</B></FONT><B> </B><I>Member variables </I>, also
	known as<I> data members</I> , are the variables in your class. Member variables
	are part of your class, just like the wheels and engine are part of your car. 
<HR>

</DL>

<P>The functions in the class typically manipulate the member variables. They are
referred to as member functions or methods of the class. Methods of the <TT>Car</TT>
class might include <TT>Start()</TT> and <TT>Brake()</TT>. A <TT>Cat</TT> class might
have data members that represent age and weight; its methods might include <TT>Sleep()</TT>,
<TT>Meow()</TT>, and <TT>ChaseMice()</TT>.</P>

<DL>
	<DD>
<HR>
<FONT COLOR="#000077"><B>New Term:</B></FONT><B> </B><I>Member functions</I> , also
	known as <I>methods </I>, are the functions in your class. Member functions are as
	much a part of your class as the member variables. They determine what the objects
	of your class can do. 
<HR>

</DL>

<H4 ALIGN="CENTER"><A NAME="Heading6"></A><FONT COLOR="#000077">Declaring a Class</FONT></H4>
<P>To declare a class, use the <TT>class</TT> keyword followed by an opening brace,
and then list the data members and methods of that class. End the declaration with
a closing brace and a semicolon. Here's the declaration of a class called <TT>Cat</TT>:</P>
<PRE><FONT COLOR="#0066FF">class Cat
{
unsigned int  itsAge;
unsigned int  itsWeight;
Meow();
};
</FONT></PRE>
<P>Declaring this class doesn't allocate memory for a <TT>Cat</TT>. It just tells
the compiler what a <TT>Cat</TT> is, what data it contains (<TT>itsAge</TT> and <TT>itsWeight</TT>),
and what it can do (<TT>Meow()</TT>). It also tells the compiler how big a <TT>Cat</TT>
is--that is, how much room the compiler must set aside for each <TT>Cat</TT> that
you create. In this example, if an integer is two bytes, a <TT>Cat</TT> is only four
bytes big: <TT>itsAge</TT> is two bytes, and <TT>itsWeight</TT> is another two bytes.
<TT>Meow()</TT> takes up no room, because no storage space is set aside for member
functions (methods).
<H4 ALIGN="CENTER"><A NAME="Heading7"></A><FONT COLOR="#000077">A Word on Naming
Conventions</FONT></H4>
<P>As a programmer, you must name all your member variables, member functions, and
classes. As you learned on Day 3, &quot;Variables and Constants,&quot; these should
be easily understood and meaningful names. <TT>Cat</TT>, <TT>Rectangle</TT>, and
<TT>Employee</TT> are good class names. <TT>Meow()</TT>, <TT>ChaseMice()</TT>, and
<TT>StopEngine()</TT> are good function names, because they tell you what the functions
do. Many programmers name the member variables with the prefix <TT>its</TT>, as in
<TT>itsAge</TT>, <TT>itsWeight</TT>, and <TT>itsSpeed</TT>. This helps to distinguish
member variables from nonmember variables.</P>
<P>C++ is case-sensitive, and all class names should follow the same pattern. That
way you never have to check how to spell your class name; was it <TT>Rectangle</TT>,
<TT>rectangle</TT>, or <TT>RECTANGLE</TT>? Some programmers like to prefix every
class name with a particular letter--for example, <TT>cCat</TT> or <TT>cPerson</TT>--whereas
others put the name in all uppercase or all lowercase. The convention that I use
is to name all classes with initial-capitalization, as in <TT>Cat</TT> and <TT>Person</TT>.</P>
<P>Similarly, many programmers begin all functions with capital letters and all variables
with lowercase. Words are usually separated with an underbar--as in <TT>Chase_Mice</TT>--or
by capitalizing each word--for example, <TT>ChaseMice</TT> or <TT>DrawCircle</TT>.</P>
<P>The important idea is that you should pick one style and stay with it through
each program. Over time, your style will evolve to include not only naming conventions,
but also indentation, alignment of braces, and commenting style.


<BLOCKQUOTE>
	<P>
<HR>
<FONT COLOR="#000077"><B>NOTE:</B></FONT><B> </B>It's common for development companies
	to have house standards for many style issues. This ensures that all developers can
	easily read one another's code. 
<HR>


</BLOCKQUOTE>

<H4 ALIGN="CENTER"><A NAME="Heading8"></A><FONT COLOR="#000077">Defining an Object</FONT></H4>
<P>You define an object of your new type just as you define an integer variable:</P>
<PRE><FONT COLOR="#0066FF">unsigned int GrossWeight;         // define an unsigned integer
Cat Frisky;                       // define a Cat
</FONT></PRE>
<P>This code defines a variable called <TT>Gross Weight</TT> whose type is an unsigned
integer. It also defines <TT>Frisky</TT>, which is an object whose class (or type)
is <TT>Cat</TT>.
<H4 ALIGN="CENTER"><A NAME="Heading9"></A><FONT COLOR="#000077">Classes Versus Objects</FONT></H4>
<P>You never pet the definition of a cat; you pet individual cats. You draw a distinction
between the idea of a cat, and the particular cat that right now is shedding all
over your living room. In the same way, C++ differentiates between the class <TT>Cat</TT>,
which is the idea of a cat, and each individual <TT>Cat</TT> object. Thus, Frisky
is an object of type <TT>Cat</TT> in the same way in which <TT>GrossWeight</TT> is
a variable of type unsigned <TT>int</TT>.</P>

<DL>
	<DD>
<HR>
<FONT COLOR="#000077"><B>New Term:</B></FONT><B> </B>An <I>object</I> is an individual
	instance of a class. 
<HR>

</DL>

<H3 ALIGN="CENTER"><A NAME="Heading10"></A><FONT COLOR="#000077">Accessing Class
Members</FONT></H3>
<P>Once you define an actual <TT>Cat</TT> object--for example, Frisky--you use the
dot operator (<TT>.</TT>) to access the members of that object. Therefore, to assign
50 to Frisky's <TT>Weight</TT> member variable, you would write</P>
<PRE><FONT COLOR="#0066FF">Frisky.Weight = 50;
</FONT></PRE>
<P>In the same way, to call the <TT>Meow()</TT> function, you would write</P>
<PRE><FONT COLOR="#0066FF">Frisky.Meow();
</FONT></PRE>
<P>When you use a class method, you call the method. In this example, you are calling
<TT>Meow()</TT> on Frisky.
<H4 ALIGN="CENTER"><A NAME="Heading11"></A><FONT COLOR="#000077">Assign to Objects,
Not to Classes</FONT></H4>
<P>In C++ you don't assign values to types; you assign values to variables. For example,
you would never write</P>
<PRE><FONT COLOR="#0066FF">int = 5;               // wrong
</FONT></PRE>
<P>The compiler would flag this as an error, because you can't assign <TT>5</TT>
to an integer. Rather, you must define an integer variable and assign <TT>5</TT>
to that variable. For example,</P>
<PRE><FONT COLOR="#0066FF">int  x;                // define x to be an int
x = 5;                 // set x's value to 5
</FONT></PRE>
<P>This is a shorthand way of saying, &quot;Assign <TT>5</TT> to the variable <TT>x</TT>,
which is of type <TT>int</TT>.&quot; In the same way, you wouldn't write</P>
<PRE><FONT COLOR="#0066FF">Cat.age=5;             // wrong
???
</FONT></PRE>
<P>The compiler would flag this as an error, because you can't assign <TT>5</TT>
to the age part of a <TT>Cat</TT>. Rather, you must define a <TT>Cat</TT> object
and assign <TT>5</TT> to that object. For example,</P>
<PRE><FONT COLOR="#0066FF">Cat Frisky;            // just like  int x;
Frisky.age = 5;        // just like  x = 5;
</FONT></PRE>
<H4 ALIGN="CENTER"><A NAME="Heading12"></A><FONT COLOR="#000077">If You Dont Declare
It, Your Class Wont Have It</FONT></H4>
<P>Try this experiment: Walk up to a three-year-old and show her a cat. Then say,
&quot;This is Frisky. Frisky knows a trick. Frisky, bark.&quot; The child will giggle
and say, &quot;No, silly, cats can't bark.&quot;</P>
<P>If you wrote</P>
<PRE><FONT COLOR="#0066FF">Cat  Frisky;           // make a Cat named Frisky
Frisky.Bark()          // tell Frisky to bark
</FONT></PRE>
<P>the compiler would say, <TT>No, silly, Cats can't bark</TT>. (Your compiler's
wording may vary). The compiler knows that Frisky can't bark because the <TT>Cat</TT>
class doesn't have a <TT>Bark()</TT> function. The compiler wouldn't even let Frisky
meow if you didn't define a <TT>Meow()</TT> function.


<BLOCKQUOTE>
	<P>
<HR>
<B>DO </B>use the keyword <TT>class</TT> to declare a class. <B>DON'T</B> confuse
	a declaration with a definition. A declaration says what a class is. A definition
	sets aside memory for an object. <B>DON'T</B> confuse a class with an object. <B>DON'T</B>
	assign values to a class. Assign values to the data members of an object. <B>DO</B>
	use the dot operator (<TT>.</TT>) to access class members and functions. 
<HR>


</BLOCKQUOTE>

<H3 ALIGN="CENTER"><A NAME="Heading13"></A><FONT COLOR="#000077">Private Versus Public</FONT></H3>
<P>Other keywords are used in the declaration of a class. Two of the most important
are <TT>public</TT> and <TT>private</TT>.</P>
<P>All members of a class--data and methods--are private by default. Private members
can be accessed only within methods of the class itself. Public members can be accessed
through any object of the class. This distinction is both important and confusing.
To make it a bit clearer, consider an example from earlier in this chapter:</P>
<PRE><FONT COLOR="#0066FF">class Cat
{
unsigned int  itsAge;
unsigned int  itsWeight;
Meow();
};
</FONT></PRE>
<P>In this declaration, <TT>itsAge</TT>, <TT>itsWeight</TT>, and <TT>Meow()</TT>
are all private, because all members of a class are private by default. This means
that unless you specify otherwise, they are private.</P>
<P>However, if you write</P>
<PRE><FONT COLOR="#0066FF">Cat  Boots;
Boots.itsAge=5;        // error! can't access private data!
</FONT></PRE>
<P>the compiler flags this as an error. In effect, you've said to the compiler, &quot;I'll
access <TT>itsAge</TT>, <TT>itsWeight</TT>, and <TT>Meow()</TT> only from within
member functions of the <TT>Cat</TT> class.&quot; Yet here you've accessed the <TT>itsAge</TT>
member variable of the <TT>Boots</TT> object from outside a <TT>Cat</TT> method.
Just because <TT>Boots</TT> is an object of class <TT>Cat</TT>, that doesn't mean
that you can access the parts of <TT>Boots</TT> that are private.</P>
<P>This is a source of endless confusion to new C++ programmers. I can almost hear
you yelling, &quot;Hey! I just said Boots is a cat. Why can't Boots access his own
age?&quot; The answer is that Boots can, but you can't. Boots, in his own methods,
can access all his parts--public and private. Even though you've created a <TT>Cat</TT>,
that doesn't mean that you can see or change the parts of it that are private.</P>
<P>The way to use <TT>Cat</TT> so that you can access the data members is</P>
<PRE><FONT COLOR="#0066FF">class Cat
{
public:
unsigned int  itsAge;
unsigned int  itsWeight;
Meow();
};
<B></B></FONT></PRE>
<P>Now <TT>itsAge</TT>, <TT>itsWeight</TT>, and <TT>Meow()</TT> are all public. <TT>Boots.itsAge=5</TT>
compiles without problems.<B></B></P>

<P>Listing 6.1 shows the declaration of a <TT>Cat</TT> class with public member variables.</P>

<P><A NAME="Heading14"></A><FONT SIZE="4" COLOR="#000077"><B>Listing 6.1. Accessing
the public members of a simple class.</B></FONT><FONT COLOR="#0066FF"></FONT></P>
<PRE><FONT COLOR="#0066FF">1:   // Demonstrates declaration of a class and
2:   // definition of an object of the class,
3:
4:   #include &lt;iostream.h&gt;   // for cout
5:
6:   class Cat                // declare the class object
7:   {
8:    public:                 // members which follow are public
9:      int itsAge;
10:     int itsWeight;
11:  };
12:
13:
14:  void main()
15:  {
16:     Cat Frisky;
17:     Frisky.itsAge = 5;    // assign to the member variable
18:     cout &lt;&lt; &quot;Frisky is a cat who is &quot; ;
19:     cout &lt;&lt; Frisky.itsAge &lt;&lt; &quot; years old.\n&quot;;
<TT>20: </TT>
Output: Frisky is a cat who is 5 years old.
</FONT></PRE>
<P><FONT COLOR="#000077"><B>Analysis:</B></FONT><B> </B>Line 6 contains the keyword
<TT>class</TT>. This tells the compiler that what follows is a declaration. The name
of the new class comes after the keyword <TT>class</TT>. In this case, it is <TT>Cat</TT>.<BR>
The body of the declaration begins with the opening brace in line 7 and ends with
a closing brace and a semicolon in line 11. Line 8 contains the keyword <TT>public</TT>,
which indicates that everything that follows is public until the keyword <TT>private</TT>
or the end of the class declaration.</P>
<P>Lines 9 and 10 contain the declarations of the class members <TT>itsAge</TT> and
<TT>itsWeight</TT>.</P>
<P>Line 14 begins the main function of the program. <TT>Frisky</TT> is defined in
line 16 as an instance of a <TT>Cat</TT>--that is, as a <TT>Cat</TT> object. <TT>Frisky</TT>'s
age is set in line 17 to <TT>5</TT>. In lines 18 and 19, the <TT>itsAge</TT> member
variable is used to print out a message about <TT>Frisky</TT>.


<BLOCKQUOTE>
	<P>
<HR>
<FONT COLOR="#000077"><B>NOTE:</B></FONT><B> </B>Try commenting out line 8 and try
	to recompile. You will receive an error on line 17 because <TT>itsAge</TT> will no
	longer have public access. The default for classes is private access. 
<HR>


</BLOCKQUOTE>

<H4 ALIGN="CENTER"><A NAME="Heading16"></A><FONT COLOR="#000077">Make Member Data
Private</FONT></H4>
<P>As a general rule of design, you should keep the member data of a class private.
Therefore, you must create public functions known as accessor methods to set and
get the private member variables. These accessor methods are the member functions
that other parts of your program call to get and set your private member variables.</P>

<DL>
	<DD>
<HR>
<FONT COLOR="#000077"><B>New Term:</B></FONT><B> </B>A <I>public accessor method</I>
	is a class member function used either to read the value of a private class member
	variable or to set its value. 
<HR>

</DL>

<P>Why bother with this extra level of indirect access? After all, it is simpler
and easier to use the data, instead of working through accessor functions.</P>
<P>Accessor functions enable you to separate the details of how the data is stored
from how it is used. This enables you to change how the data is stored without having
to rewrite functions that use the data.</P>
<P>If a function that needs to know a <TT>Cat</TT>'s age accesses <TT>itsAge</TT>
directly, that function would need to be rewritten if you, as the author of the <TT>Cat</TT>
class, decided to change how that data is stored. By having the function call <TT>GetAge()</TT>,
your <TT>Cat</TT> class can easily return the right value no matter how you arrive
at the age. The calling function doesn't need to know whether you are storing it
as an unsigned integer or a <TT>long</TT>, or whether you are computing it as needed.</P>
<P>This technique makes your program easier to maintain. It gives your code a longer
life because design changes don't make your program obsolete.</P>
<P>Listing 6.2 shows the <TT>Cat</TT> class modified to include private member data
and public accessor methods. Note that this is not an executable listing.</P>

<P><A NAME="Heading17"></A><FONT SIZE="4" COLOR="#000077"><B>Listing 6.2. A class
with accessor methods.</B></FONT><FONT COLOR="#0066FF"></FONT>
<PRE><FONT COLOR="#0066FF">1:       // Cat class declaration
2:       // Data members are private, public accessor methods
3:       // mediate setting and getting the values of the private data
4:
5:  class Cat
6:  {
7:  public:
8:       // public accessors
9:     unsigned int GetAge();
10:    void SetAge(unsigned int Age);
11:
12:    unsigned int GetWeight();
13:    void SetWeight(unsigned int Weight);
14:
15:      // public member functions
16:    Meow();
17:
18:      // private member data
19: private:
20:    unsigned int  itsAge;
21:    unsigned int  itsWeight;
22:
<TT>23: };</TT></FONT> 
</PRE>
<P><FONT COLOR="#000077"><B>Analysis: </B></FONT>This class has five public methods.
Lines 9 and 10 contain the accessor methods for <TT>itsAge</TT>. Lines 12 and 13
contain the accessor methods for <TT>itsWeight</TT>. These accessor functions set
the member variables and return their values.<BR>
The public member function <TT>Meow()</TT> is declared in line 16. <TT>Meow()</TT>
is not an accessor function. It doesn't get or set a member variable; it performs
another service for the class, printing the word <TT>Meow</TT>.</P>
<P>The member variables themselves are declared in lines 20 and 21. <BR>
<BR>
To set Frisky's age, you would pass the value to the <TT>SetAge()</TT> method, as
in</P>
<PRE><FONT COLOR="#0066FF">Cat  Frisky;
Frisky.SetAge(5);    // set Frisky's age using the public accessor
</FONT></PRE>
<H4 ALIGN="CENTER"><A NAME="Heading19"></A><FONT COLOR="#000077">Privacy Versus Security</FONT></H4>
<P>Declaring methods or data private enables the compiler to find programming mistakes
before they become bugs. Any programmer worth his consulting fees can find a way
around privacy if he wants to. Stroustrup, the inventor of C++, said, &quot;The C++
access control mechanisms provide protection against accident--not against fraud.&quot;
(ARM, 1990.)
<H3 ALIGN="CENTER"><A NAME="Heading20"></A><FONT COLOR="#000077">The class keyword</FONT></H3>
<P>Syntax for the <TT>class</TT> keyword is as follows.</P>
<PRE><FONT COLOR="#0066FF">
class class_name
{
// access control keywords here
// class variables and methods declared here
};
</FONT></PRE>
<P>You use the <TT>class</TT> keyword to declare new types. A class is a collection
of class member data, which are variables of various types, including other classes.
The class also contains class functions--or methods--which are functions used to
manipulate the data in the class and to perform other services for the class. You
define objects of the new type in much the same way in which you define any variable.
State the type (class) and then the variable name (the object). You access the class
members and functions by using the dot (<TT>.</TT>) operator. You use access control
keywords to declare sections of the class as public or private. The default for access
control is private. Each keyword changes the access control from that point on to
the end of the class or until the next access control keyword. Class declarations
end with a closing brace and a semicolon. Example 1</P>
<PRE><FONT COLOR="#0066FF">class Cat
{
public:
unsigned int Age;
unsigned int Weight;
void Meow();
};

Cat  Frisky;
Frisky.Age = 8;
Frisky.Weight = 18;
Frisky.Meow();</FONT></PRE>
<P><BR>
Example</P>
<PRE><FONT COLOR="#0066FF">class Car
{
public:                            // the next five are public

void Start();
void Accelerate();
void Brake();
void SetYear(int year);
int GetYear();

private:                           // the rest is private

int Year;
Char Model [255];
};                                 // end of class declaration

Car OldFaithful;                   // make an instance of car
int bought;                        // a local variable of type int
OldFaithful.SetYear(84) ;          // assign 84 to the year
bought = OldFaithful.GetYear();    // set bought to 84
OldFaithful.Start();               // call the start method
</FONT></PRE>


<BLOCKQUOTE>
	<P>
<HR>
<B>DO </B>declare member variables private. <B>DO</B> use public accessor methods.
	<B>DON'T</B> try to use private member variables from outside the class. <B>DO</B>
	access private member variables from within class member functions. 
<HR>


</BLOCKQUOTE>

<H3 ALIGN="CENTER"><A NAME="Heading21"></A><FONT COLOR="#000077">Implementing Class
Methods</FONT></H3>
<P>As you've seen, an accessor function provides a public interface to the private
member data of the class. Each accessor function, along with any other class methods
that you declare, must have an implementation. The implementation is called the function
definition.</P>
<P>A member function definition begins with the name of the class, followed by two
colons, the name of the function, and its parameters. Listing 6.3 shows the complete
declaration of a simple <TT>Cat</TT> class and the implementation of its accessor
function and one general class member function.</P>

<P><A NAME="Heading22"></A><FONT SIZE="4" COLOR="#000077"><B>Listing 6.3. Implementing
the methods of a simple class.</B></FONT><FONT COLOR="#0066FF"></FONT>
<PRE><FONT COLOR="#0066FF">1:   // Demonstrates declaration of a class and
2:   // definition of class methods,
3:
4:   #include &lt;iostream.h&gt;      // for cout
5:
6:   class Cat                   // begin declaration of the class
7:   {
8:     public:                   // begin public section
9:       int GetAge();           // accessor function
10:      void SetAge (int age);  // accessor function
11:      void Meow();            // general function
12:    private:                  // begin private section
13:      int itsAge;             // member variable
14:  };
15:
16:  // GetAge, Public accessor function
17:  // returns value of itsAge member
18:  int Cat::GetAge()
19:  {
20:     return itsAge;
21:  }
22:
23:  // definition of SetAge, public
24:  // accessor function
25:  // returns sets itsAge member
26:  void Cat::SetAge(int age)
27:  {
28:     // set member variable its age to
29:     // value passed in by parameter age
30:     itsAge = age;
31:  }
32:
33:  // definition of Meow method
34:  // returns: void
35:  // parameters: None
36:  // action: Prints &quot;meow&quot; to screen
37:  void Cat::Meow()
38:  {
39:     cout &lt;&lt; &quot;Meow.\n&quot;;
40:  }
41:
42:  // create a cat, set its age, have it
43:  // meow, tell us its age, then meow again.
44:  int main()
45:  {
46:     Cat Frisky;
47:     Frisky.SetAge(5);
48:     Frisky.Meow();
49:     cout &lt;&lt; &quot;Frisky is a cat who is &quot; ;
50:     cout &lt;&lt; Frisky.GetAge() &lt;&lt; &quot; years old.\n&quot;;
51:     Frisky.Meow();
52;      return 0;
<TT>53: }</TT>
Output: Meow.
Frisky is a cat who is 5 years old.
Meow.
</FONT></PRE>
<P><FONT COLOR="#000077"><B>Analysis:</B></FONT><B> </B>Lines 6-14 contain the definition
of the <TT>Cat</TT> class. Line 8 contains the keyword <TT>public</TT>, which tells
the compiler that what follows is a set of public members. Line 9 has the declaration
of the public accessor method <TT>GetAge()</TT>. <TT>GetAge()</TT> provides access
to the private member variable <TT>itsAge</TT>, which is declared in line 13. Line
10 has the public accessor function <TT>SetAge()</TT>. <TT>SetAge()</TT> takes an
integer as an argument and sets <TT>itsAge</TT> to the value of that argument.<BR>
Line 11 has the declaration of the class method <TT>Meow()</TT>. <TT>Meow()</TT>
is not an accessor function. Here it is a general method that prints the word <TT>Meow</TT>
to the screen.</P>
<P>Line 12 begins the private section, which includes only the declaration in line
13 of the private member variable <TT>itsAge</TT>. The class declaration ends with
a closing brace and semicolon in line 14.</P>
<P>Lines 18-21 contain the definition of the member function <TT>GetAge()</TT>. This
method takes no parameters; it returns an integer. Note that class methods include
the class name followed by two colons and the function name (Line 18). This syntax
tells the compiler that the <TT>GetAge()</TT> function that you are defining here
is the one that you declared in the <TT>Cat</TT> class. With the exception of this
header line, the <TT>GetAge()</TT> function is created like any other function.</P>
<P>The <TT>GetAge()</TT> function takes only one line; it returns the value in <TT>itsAge</TT>.
Note that the <TT>main()</TT> function cannot access <TT>itsAge</TT> because <TT>itsAge</TT>
is private to the <TT>Cat</TT> class. The<TT> main()</TT> function has access to
the public method<TT> GetAge()</TT>. Because <TT>GetAge()</TT> is a member function
of the <TT>Cat</TT> class, it has full access to the <TT>itsAge</TT> variable. This
access enables <TT>GetAge()</TT> to return the value of <TT>itsAge</TT> to <TT>main()</TT>.</P>
<P>Line 26 contains the definition of the <TT>SetAge()</TT> member function. It takes
an integer parameter and sets the value of <TT>itsAge</TT> to the value of that parameter
in line 30. Because it is a member of the <TT>Cat</TT> class, <TT>SetAge()</TT> has
direct access to the member variable <TT>itsAge</TT>.</P>
<P>Line 37 begins the definition, or implementation, of the <TT>Meow()</TT> method
of the <TT>Cat</TT> class. It is a one-line function that prints the word <TT>Meow</TT>
to the screen, followed by a new line. Remember that the <TT>\n</TT> character prints
a new line to the screen.</P>
<P>Line 44 begins the body of the program with the familiar <TT>main()</TT> function.
In this case, it takes no arguments and returns <TT>void</TT>. In line 46, <TT>main()</TT>
declares a <TT>Cat</TT> named <TT>Frisky</TT>. In line 47, the value <TT>5</TT> is
assigned to the <TT>itsAge</TT> member variable by way of the <TT>SetAge()</TT> accessor
method. Note that the method is called by using the class name (<TT>Frisky</TT>)
followed by the member operator (<TT>.</TT>) and the method name (<TT>SetAge()</TT>).
In this same way, you can call any of the other methods in a class.</P>
<P>Line 48 calls the <TT>Meow()</TT> member function, and line 49 prints a message
using the <TT>GetAge()</TT> accessor. Line 51 calls <TT>Meow()</TT> again.
<H3 ALIGN="CENTER"><A NAME="Heading24"></A><FONT COLOR="#000077">Constructors and
Destructors</FONT></H3>
<P>There are two ways to define an integer variable. You can define the variable
and then assign a value to it later in the program. For example,</P>
<PRE><FONT COLOR="#0066FF">int Weight;            // define a variable
...                    // other code here
Weight = 7;            // assign it a value
</FONT></PRE>
<P>Or you can define the integer and immediately initialize it. For example,</P>
<PRE><FONT COLOR="#0066FF">int Weight = 7;        // define and initialize to 7
</FONT></PRE>
<P>Initialization combines the definition of the variable with its initial assignment.
Nothing stops you from changing that value later. Initialization ensures that your
variable is never without a meaningful value.</P>
<P>How do you initialize the member data of a class? Classes have a special member
function called a constructor. The constructor can take parameters as needed, but
it cannot have a return value--not even <TT>void</TT>. The constructor is a class
method with the same name as the class itself.</P>
<P>Whenever you declare a constructor, you'll also want to declare a destructor.
Just as constructors create and initialize objects of your class, destructors clean
up after your object and free any memory you might have allocated. A destructor always
has the name of the class, preceded by a tilde (<TT>~</TT>). Destructors take no
arguments and have no return value. Therefore, the <TT>Cat</TT> declaration includes</P>
<PRE><FONT COLOR="#0066FF">~Cat();
</FONT></PRE>
<H4 ALIGN="CENTER"><A NAME="Heading25"></A><FONT COLOR="#000077">Default Constructors
and Destructors</FONT></H4>
<P>If you don't declare a constructor or a destructor, the compiler makes one for
you. The default constructor and destructor take no arguments and do nothing.</P>
<P>What good is a constructor that does nothing? In part, it is a matter of form.
All objects must be constructed and destructed, and these do-nothing functions are
called at the right time. However, to declare an object without passing in parameters,
such as</P>
<PRE><FONT COLOR="#0066FF">Cat Rags;           // Rags gets no parameters
</FONT></PRE>
<P>you must have a constructor in the form</P>
<PRE><FONT COLOR="#0066FF">Cat();
</FONT></PRE>
<P>When you define an object of a class, the constructor is called. If the <TT>Cat</TT>
constructor took two parameters, you might define a <TT>Cat</TT> object by writing</P>
<PRE><FONT COLOR="#0066FF">Cat Frisky (5,7);
</FONT></PRE>
<P>If the constructor took one parameter, you would write</P>
<PRE><FONT COLOR="#0066FF">Cat Frisky (3);
</FONT></PRE>
<P>In the event that the constructor takes no parameters at all, you leave off the
parentheses and write</P>
<PRE><FONT COLOR="#0066FF">Cat Frisky ;
</FONT></PRE>
<P>This is an exception to the rule that states all functions require parentheses,
even if they take no parameters. This is why you are able to write</P>
<PRE><FONT COLOR="#0066FF">Cat Frisky;
</FONT></PRE>
<P>which is a call to the default constructor. It provides no parameters, and it
leaves off the parentheses. You don't have to use the compiler-provided default constructor.
You are always free to write your own constructor with no parameters. Even constructors
with no parameters can have a function body in which they initialize their objects
or do other work.</P>
<P>As a matter of form, if you declare a constructor, be sure to declare a destructor,
even if your destructor does nothing. Although it is true that the default destructor
would work correctly, it doesn't hurt to declare your own. It makes your code clearer.</P>
<P>Listing 6.4 rewrites the <TT>Cat</TT> class to use a constructor to initialize
the <TT>Cat</TT> object, setting its age to whatever initial age you provide, and
it demonstrates where the destructor is called.</P>

<P><A NAME="Heading26"></A><FONT SIZE="4" COLOR="#000077"><B>Listing 6.4. Using constructors
and destructors.</B></FONT><FONT COLOR="#0066FF"></FONT>
<PRE><FONT COLOR="#0066FF">1:   // Demonstrates declaration of a constructors and
2:   // destructor for the Cat class
3:
4:   #include &lt;iostream.h&gt;      // for cout
5:
6:   class Cat                   // begin declaration of the class
7:   {
8:    public:                    // begin public section
9:      Cat(int initialAge);     // constructor
10:     ~Cat();                  // destructor
11:     int GetAge();            // accessor function
12:     void SetAge(int age);    // accessor function
13:     void Meow();
14:   private:                   // begin private section
15:     int itsAge;              // member variable
16:  };
17:
18:  // constructor of Cat,
19:  Cat::Cat(int initialAge)
20:  {
21:     itsAge = initialAge;
22:  }
23:
24:  Cat::~Cat()                 // destructor, takes no action
25:  {
26:  }
27:
28:  // GetAge, Public accessor function
29:  // returns value of itsAge member
30:  int Cat::GetAge()
31:  {
32:     return itsAge;
33:  }
34:
35:  // Definition of SetAge, public
36:  // accessor function
37:
38:  void Cat::SetAge(int age)
39:  {
40:     // set member variable its age to
41:     // value passed in by parameter age
42:     itsAge = age;
43:  }
44:
45:  // definition of Meow method
46:  // returns: void
47:  // parameters: None
48:  // action: Prints &quot;meow&quot; to screen
49:  void Cat::Meow()
50:  {
51:     cout &lt;&lt; &quot;Meow.\n&quot;;
52:  }
53:
54:  // create a cat, set its age, have it
55   // meow, tell us its age, then meow again.
56:  int main()
57:  {
58:    Cat Frisky(5);
59:    Frisky.Meow();
60:    cout &lt;&lt; &quot;Frisky is a cat who is &quot; ;
61:    cout &lt;&lt; Frisky.GetAge() &lt;&lt; &quot; years old.\n&quot;;
62:    Frisky.Meow();
63:    Frisky.SetAge(7);
64:    cout &lt;&lt; &quot;Now Frisky is &quot; ;
65:    cout &lt;&lt; Frisky.GetAge() &lt;&lt; &quot; years old.\n&quot;;
66;     return 0;
<TT>67: }</TT></FONT>
<FONT COLOR="#0066FF">
Output: Meow.
Frisky is a cat who is 5 years old.
Meow.
Now Frisky is 7 years old.
</FONT></PRE>
<P><FONT COLOR="#000077"><B>Analysis:</B></FONT><B> </B>Listing 6.4 is similar to
6.3, except that line 9 adds a constructor that takes an integer. Line 10 declares
the destructor, which takes no parameters. Destructors never take parameters, and
neither constructors nor destructors return a value--not even <TT>void</TT>.<BR>
Lines 19-22 show the implementation of the constructor. It is similar to the implementation
of the <TT>SetAge()</TT> accessor function. There is no return value.</P>
<P>Lines 24-26 show the implementation of the destructor <TT>~Cat()</TT>. This function
does nothing, but you must include the definition of the function if you declare
it in the class declaration.</P>
<P>Line 58 contains the definition of a <TT>Cat</TT> object, <TT>Frisky</TT>. The
value <TT>5</TT> is passed in to <TT>Frisky</TT>'s constructor. There is no need
to call <TT>SetAge()</TT>, because Frisky was created with the value <TT>5</TT> in
its member variable <TT>itsAge</TT>, as shown in line 61. In line 63, Frisky's <TT>itsAge</TT>
variable is reassigned to 7. Line 65 prints the new value.


<BLOCKQUOTE>
	<P>
<HR>
<B>DO </B>use constructors to initialize your objects. <B>DON'T </B>give constructors
	or destructors a return value. <B>DON'T</B> give destructors parameters. 
<HR>


</BLOCKQUOTE>

<H3 ALIGN="CENTER"><A NAME="Heading28"></A><FONT COLOR="#000077">const Member Functions</FONT></H3>
<P>If you declare a class method <TT>const</TT>, you are promising that the method
won't change the value of any of the members of the class. To declare a class method
constant, put the keyword <TT>const</TT> after the parentheses but before the semicolon.
The declaration of the constant member function <TT>SomeFunction()</TT> takes no
arguments and returns <TT>void</TT>. It looks like this:</P>
<PRE><FONT COLOR="#0066FF">void SomeFunction() const;
</FONT></PRE>
<P>Accessor functions are often declared as constant functions by using the <TT>const</TT>
modifier. The <TT>Cat</TT> class has two accessor functions:</P>
<PRE><FONT COLOR="#0066FF">void SetAge(int anAge);
int GetAge();
</FONT></PRE>
<P><TT>SetAge()</TT> cannot be <TT>const</TT> because it changes the member variable
<TT>itsAge</TT>. <TT>GetAge()</TT>, on the other hand, can and should be <TT>const</TT>
because it doesn't change the class at all. <TT>GetAge()</TT> simply returns the
current value of the member variable <TT>itsAge</TT>. Therefore, the declaration
of these functions should be written like this:</P>
<PRE><FONT COLOR="#0066FF">void SetAge(int anAge);
int GetAge() const;
</FONT></PRE>
<P>If you declare a function to be <TT>const</TT>, and the implementation of that
function changes the object by changing the value of any of its members, the compiler
flags it as an error. For example, if you wrote <TT>GetAge()</TT> in such a way that
it kept count of the number of times that the <TT>Cat</TT> was asked its age, it
would generate a compiler error. This is because you would be changing the <TT>Cat</TT>
object by calling this method.


<BLOCKQUOTE>
	<P>
<HR>
<FONT COLOR="#000077"><B>NOTE:</B></FONT><B> </B>Use <TT>const</TT> whenever possible.
	Declare member functions to be <TT>const</TT> whenever they should not change the
	object. This lets the compiler help you find errors; it's faster and less expensive
	than doing it yourself. 
<HR>


</BLOCKQUOTE>

<P>It is good programming practice to declare as many methods to be <TT>const</TT>
as possible. Each time you do, you enable the compiler to catch your errors, instead
of letting your errors become bugs that will show up when your program is running.
<H3 ALIGN="CENTER"><A NAME="Heading29"></A><FONT COLOR="#000077">Interface Versus
Implementation</FONT></H3>
<P>As you've learned, clients are the parts of the program that create and use objects
of your class. You can think of the interface to your class--the class declaration--as
a contract with these clients. The contract tells what data your class has available
and how your class will behave.</P>
<P>For example, in the <TT>Cat</TT> class declaration, you create a contract that
every <TT>Cat</TT> will have a member variable <TT>itsAge</TT> that can be initialized
in its constructor, assigned to by its <TT>SetAge()</TT> accessor function, and read
by its <TT>GetAge()</TT> accessor. You also promise that every <TT>Cat</TT> will
know how to <TT>Meow()</TT>.</P>
<P>If you make <TT>GetAge()</TT> a <TT>const</TT> function--as you should--the contract
also promises that <TT>GetAge()</TT> won't change the <TT>Cat</TT> on which it is
called.</P>
<P>C++ is strongly typed, which means that the compiler enforces these contracts
by giving you a compiler error when you violate them. Listing 6.5 demonstrates a
program that doesn't compile because of violations of these contracts.


<BLOCKQUOTE>
	<P>
<HR>
<FONT COLOR="#000077"><B>WARNING:</B></FONT><B> </B>Listing 6.5 does not compile!
	
<HR>


</BLOCKQUOTE>

<P><A NAME="Heading30"></A><FONT SIZE="4" COLOR="#000077"><B>Listing 6.5. A demonstration
of violations of the interface</B></FONT><FONT SIZE="2" COLOR="#000077"><B>.</B></FONT><FONT
COLOR="#0066FF"></FONT>
<PRE><FONT COLOR="#0066FF">1:   // Demonstrates compiler errors
2:
3:
4:   #include &lt;iostream.h&gt;          // for cout
5:
6:  class Cat
7:  {
8:   public:
9:      Cat(int initialAge);
10:     ~Cat();
11:     int GetAge() const;          // const accessor function
12:     void SetAge (int age);
13:     void Meow();
14:  private:
15:    int itsAge;
16: };
17:
18:    // constructor of Cat,
19:    Cat::Cat(int initialAge)
20:    {
21:       itsAge = initialAge;
21:       cout &lt;&lt; &quot;Cat Constructor\n&quot;;
22:    }
23:
24:    Cat::~Cat()                   // destructor, takes no action
25:    {
26:       cout &lt;&lt; &quot;Cat Destructor\n&quot;;
27:    }
28:   // GetAge, const function
29:   // but we violate const!
30:   int Cat::GetAge() const
31:   {
32:      return (itsAge++);         // violates const!
33:   }
34:
35:   // definition of SetAge, public
36:   // accessor function
37:
38:   void Cat::SetAge(int age)
39:   {
40:      // set member variable its age to
41:      // value passed in by parameter age
42:      itsAge = age;
43:   }
44:
45:  // definition of Meow method
46:  // returns: void
47:  // parameters: None
48:  // action: Prints &quot;meow&quot; to screen
49:  void Cat::Meow()
50:  {
51:     cout &lt;&lt; &quot;Meow.\n&quot;;
52:  }
53:
54:  // demonstrate various violations of the
55   // interface, and resulting compiler errors
56:  int main()
57:  {
58:     Cat Frisky;                 // doesn't match declaration
59:     Frisky.Meow();
60:     Frisky.Bark();              // No, silly, cat's can't bark.
61:     Frisky.itsAge = 7;          // itsAge is private
62:      return 0;
<TT>63: }</TT></FONT> 
</PRE>
<P><FONT COLOR="#000077"><B>Analysis:</B></FONT><B> </B>As it is written, this program
doesn't compile. Therefore, there is no output.<BR>
This program was fun to write because there are so many errors in it.</P>
<P>Line 11 declares <TT>GetAge()</TT> to be a <TT>const</TT> accessor function--as
it should be. In the body of <TT>GetAge()</TT>, however, in line 32, the member variable
<TT>itsAge</TT> is incremented. Because this method is declared to be <TT>const</TT>,
it must not change the value of <TT>itsAge</TT>. Therefore, it is flagged as an error
when the program is compiled.</P>
<P>In line 13, <TT>Meow()</TT> is not declared <TT>const</TT>. Although this is not
an error, it is bad programming practice. A better design takes into account that
this method doesn't change the member variables of <TT>Cat</TT>. Therefore, <TT>Meow()</TT>
should be <TT>const</TT>.</P>
<P>Line 58 shows the definition of a <TT>Cat</TT> object, <TT>Frisky</TT>. <TT>Cat</TT>s
now have a constructor, which takes an integer as a parameter. This means that you
must pass in a parameter. Because there is no parameter in line 58, it is flagged
as an error.</P>
<P>Line 60 shows a call to a class method, <TT>Bark()</TT>. <TT>Bark()</TT> was never
declared. Therefore, it is illegal.</P>
<P>Line 61 shows <TT>itsAge</TT> being assigned the value <TT>7</TT>. Because <TT>itsAge</TT>
is a private data member, it is flagged as an error when the program is compiled.
<H3 ALIGN="CENTER"><A NAME="Heading32"></A><FONT COLOR="#000077">Why Use the Compiler
to Catch Errors?</FONT></H3>
<P>While it would be wonderful to write 100 percent bug-free code, few programmers
have been able to do so. However, many programmers have developed a system to help
minimize bugs by catching and fixing them early in the process. Although compiler
errors are infuriating and are the bane of a programmer's existence, they are far
better than the alternative. A weakly typed language enables you to violate your
contracts without a peep from the compiler, but your program will crash at run-time--when,
for example, your boss is watching. Compile-time errors--that is, errors found while
you are compiling--are far better than run-time errors--that is, errors found while
you are executing the program. This is because compile-time errors can be found much
more reliably. It is possible to run a program many times without going down every
possible code path. Thus, a run-time error can hide for quite a while. Compile-time
errors are found every time you compile. Thus, they are easier to identify and fix.
It is the goal of quality programming to ensure that the code has no runtime bugs.
One tried-and-true technique to accomplish this is to use the compiler to catch your
mistakes early in the development process.
<H3 ALIGN="CENTER"><A NAME="Heading33"></A><FONT COLOR="#000077">Where to Put Class
Declarations and Method Definitions</FONT></H3>
<P>Each function that you declare for your class must have a definition. The definition
is also called the function implementation. Like other functions, the definition
of a class method has a function header and a function body.</P>
<P>The definition must be in a file that the compiler can find. Most C++ compilers
want that file to end with <TT>.C</TT> or <TT>.CPP</TT>. This book uses <TT>.CPP</TT>,
but check your compiler to see what it prefers.


<BLOCKQUOTE>
	<P>
<HR>
<FONT COLOR="#000077"><B>NOTE</B></FONT><B>: </B>Many compilers assume that files
	ending with <TT>.C</TT> are C programs, and that C++ program files end with <TT>.CPP</TT>.
	You can use any extension, but <TT>.CPP</TT> will minimize confusion. 
<HR>


</BLOCKQUOTE>

<P>You are free to put the declaration in this file as well, but that is not good
programming practice. The convention that most programmers adopt is to put the declaration
into what is called a header file, usually with the same name but ending in <TT>.H</TT>,
<TT>.HP</TT>, or <TT>.HPP</TT>. This book names the header files with <TT>.HPP</TT>,
but check your compiler to see what it prefers.</P>
<P>For example, you put the declaration of the <TT>Cat</TT> class into a file named
<TT>CAT.HPP</TT>, and you put the definition of the class methods into a file called
<TT>CAT.CPP</TT>. You then attach the header file to the <TT>.CPP</TT> file by putting
the following code at the top of <TT>CAT.CPP</TT>:</P>
<PRE><FONT COLOR="#0066FF">#include Cat.hpp
</FONT></PRE>
<P>This tells the compiler to read <TT>CAT.HPP</TT> into the file, just as if you
had typed in its contents at this point. Why bother separating them if you're just
going to read them back in? Most of the time, clients of your class don't care about
the implementation specifics. Reading the header file tells them everything they
need to know; they can ignore the implementation files.


<BLOCKQUOTE>
	<P>
<HR>
<FONT COLOR="#000077"><B>NOTE:</B></FONT><B> </B>The declaration of a class tells
	the compiler what the class is, what data it holds, and what functions it has. The
	declaration of the class is called its interface because it tells the user how to
	interact with the class. The interface is usually stored in an <TT>.HPP</TT> file,
	which is referred to as a header file. The function definition tells the compiler
	how the function works. The function definition is called the implementation of the
	class method, and it is kept in a <TT>.CPP</TT> file. The implementation details
	of the class are of concern only to the author of the class. Clients of the class--that
	is, the parts of the program that use the class--don't need to know, and don't care,
	how the functions are implemented. 
<HR>


</BLOCKQUOTE>

<H3 ALIGN="CENTER"><A NAME="Heading34"></A><FONT COLOR="#000077">Inline Implementation</FONT></H3>
<P>Just as you can ask the compiler to make a regular function inline, you can make
class methods inline. The keyword <TT>inline</TT> appears before the return value.
The inline implementation of the <TT>GetWeight()</TT> function, for example, looks
like this:</P>
<PRE><FONT COLOR="#0066FF">inline int Cat::GetWeight()
{
return itsWeight;         // return the Weight data member
}
</FONT></PRE>
<P>You can also put the definition of a function into the declaration of the class,
which automatically makes that function inline. For example,</P>
<PRE><FONT COLOR="#0066FF">class Cat
{
public:
int GetWeight() { return itsWeight; }    // inline
void SetWeight(int aWeight);
};
</FONT></PRE>
<P>Note the syntax of the <TT>GetWeight()</TT> definition. The body of the inline
function begins im-mediately after the declaration of the class method; there is
no semicolon after the paren-theses. Like any function, the definition begins with
an opening brace and ends with a closing brace. As usual, whitespace doesn't matter;
you could have written the declaration as</P>
<PRE><FONT COLOR="#0066FF">class Cat
{
public:
int GetWeight()
{
return itsWeight;
}                           // inline
void SetWeight(int aWeight);
};
</FONT></PRE>
<P>Listings 6.6 and 6.7 re-create the <TT>Cat</TT> class, but they put the declaration
in <TT>CAT.HPP</TT> and the implementation of the functions in <TT>CAT.CPP</TT>.
Listing 6.7 also changes the accessor functions and the <TT>Meow()</TT> function
to inline.</P>

<P><A NAME="Heading35"></A><FONT SIZE="4" COLOR="#000077"><B>Listing 6.6. Cat class
declaration in CAT.HPP</B></FONT><FONT COLOR="#0066FF"></FONT>
<PRE><FONT COLOR="#0066FF">1:  #include &lt;iostream.h&gt;
2:  class Cat
3:   {
4:  public:
5:   Cat (int initialAge);
6:   ~Cat();
7:    int GetAge() { return itsAge;}             // inline!
8:    void SetAge (int age) { itsAge = age;}     // inline!
9:    void Meow() { cout &lt;&lt; &quot;Meow.\n&quot;;}             // inline!
10:  private:
11: int itsAge;
<TT>12: };</TT></FONT>
</PRE>
<P><A NAME="Heading37"></A><FONT SIZE="4" COLOR="#000077"><B>Listing 6.7. Cat implementation
in CAT.CPP</B></FONT><FONT SIZE="2" COLOR="#000077"><B>.</B></FONT><FONT COLOR="#0066FF"></FONT>
<PRE><FONT COLOR="#0066FF">1:   // Demonstrates inline functions
2:   // and inclusion of header files
3:
4:   #include &quot;cat.hpp&quot;  // be sure to include the header files!
5:
6:
7:   Cat::Cat(int initialAge)   //constructor
8:   {
9:      itsAge = initialAge;
10:  }
11:
12:  Cat::~Cat()             //destructor, takes no action
13:  {
14:  }
15:
16:  // Create a cat, set its age, have it
17:  // meow, tell us its age, then meow again.
18:  int main()
19:  {
20:     Cat Frisky(5);
21:     Frisky.Meow();
22:     cout &lt;&lt; &quot;Frisky is a cat who is &quot; ;
23:     cout &lt;&lt; Frisky.GetAge() &lt;&lt; &quot; years old.\n&quot;;
24:     Frisky.Meow();
25:     Frisky.SetAge(7);
26:     cout &lt;&lt; &quot;Now Frisky is &quot; ;
27:     cout &lt;&lt; Frisky.GetAge() &lt;&lt; &quot; years old.\n&quot;;
28:      return 0;
<TT>29: }</TT></FONT>
<FONT COLOR="#0066FF">
Output: Meow.
Frisky is a cat who is 5 years old.
Meow.
Now Frisky is 7 years old.
</FONT></PRE>
<P><FONT COLOR="#000077"><B>Analysis: </B></FONT>The code presented in Listing 6.6
and Listing 6.7 is similar to the code in Listing 6.4, except that three of the methods
are written inline in the declaration file and the declaration has been separated
into <TT>CAT.HPP</TT>.<BR>
<TT>GetAge()</TT> is declared in line 7, and its inline implementation is provided.
Lines 8 and 9 provide more inline functions, but the functionality of these functions
is unchanged from the previous &quot;outline&quot; implementations.</P>
<P>Line 4 of Listing 6.7 shows <TT>#include &quot;cat.hpp&quot;</TT>, which brings
in the listings from <TT>CAT.HPP</TT>. By including <TT>cat.hpp</TT>, you have told
the precompiler to read <TT>cat.hpp</TT> into the file as if it had been typed there,
starting on line 5.</P>
<P>This technique allows you to put your declarations into a different file from
your implementation, yet have that declaration available when the compiler needs
it. This is a very common technique in C++ programming. Typically, class declarations
are in an <TT>.HPP</TT> file that is then <TT>#includ</TT>ed into the associated
CPP file.</P>
<P>Lines 18-29 repeat the main function from Listing 6.4. This shows that making
these functions inline doesn't change their performance.
<H3 ALIGN="CENTER"><A NAME="Heading38"></A><FONT COLOR="#000077">Classes with Other
Classes as Member Data</FONT></H3>
<P>It is not uncommon to build up a complex class by declaring simpler classes and
including them in the declaration of the more complicated class. For example, you
might declare a wheel class, a motor class, a transmission class, and so forth, and
then combine them into a car class. This declares a has-a relationship. A car has
a motor, it has wheels, and it has a transmission.</P>
<P>Consider a second example. A rectangle is composed of lines. A line is defined
by two points. A point is defined by an x-coordinate and a y-coordinate. Listing
6.8 shows a complete declaration of a <TT>Rectangle</TT> class, as might appear in
<TT>RECTANGLE.HPP</TT>. Because a rectangle is defined as four lines connecting four
points and each point refers to a coordinate on a graph, we first declare a <TT>Point</TT>
class, to hold the x,y coordinates of each point. Listing 6.9 shows a complete declaration
of both classes.</P>

<P><A NAME="Heading40"></A><FONT SIZE="4" COLOR="#000077"><B>Listing 6.8. Declaring
a complete class.</B></FONT><FONT COLOR="#0066FF"></FONT>
<PRE><FONT COLOR="#0066FF">1:   // Begin Rect.hpp
2:   #include &lt;iostream.h&gt;
3:   class Point     // holds x,y coordinates
4:   {
5:      // no constructor, use default
6:      public:
7:         void SetX(int x) { itsX = x; }
8:         void SetY(int y) { itsY = y; }
9:         int GetX()const { return itsX;}
10:        int GetY()const { return itsY;}
11:     private:
12:        int itsX;
13:        int itsY;
14:  };    // end of Point class declaration
15:
16:
17:  class  Rectangle
18:  {
19:     public:
20:        Rectangle (int top, int left, int bottom, int right);
21:        ~Rectangle () {}
22:
23:        int GetTop() const { return itsTop; }
24:        int GetLeft() const { return itsLeft; }
25:        int GetBottom() const { return itsBottom; }
26:        int GetRight() const { return itsRight; }
27:
28:        Point  GetUpperLeft() const { return itsUpperLeft; }
29:        Point  GetLowerLeft() const { return itsLowerLeft; }
30:        Point  GetUpperRight() const { return itsUpperRight; }
31:        Point  GetLowerRight() const { return itsLowerRight; }
32:
33:        void SetUpperLeft(Point Location)  {itsUpperLeft = Location;}
34:        void SetLowerLeft(Point Location)  {itsLowerLeft = Location;}
35:        void SetUpperRight(Point Location)  {itsUpperRight = Location;}
36:        void SetLowerRight(Point Location)  {itsLowerRight = Location;}
37:
38:        void SetTop(int top) { itsTop = top; }
39:        void SetLeft (int left) { itsLeft = left; }
40:        void SetBottom (int bottom) { itsBottom = bottom; }
41:        void SetRight (int right) { itsRight = right; }
42:
43:        int GetArea() const;
44:
45:     private:
46:        Point  itsUpperLeft;
47:        Point  itsUpperRight;
48:        Point  itsLowerLeft;
49:        Point  itsLowerRight;
50:        int    itsTop;
51:        int    itsLeft;
52:        int    itsBottom;
53:        int    itsRight;
54:  };
<TT>55: // end Rect.hpp</TT></FONT></PRE>
<P><A NAME="Heading42"></A><FONT SIZE="4" COLOR="#000077"><B>Listing 6.9. RECT.CPP.</B></FONT></P>
<PRE><FONT COLOR="#0066FF">1:   // Begin rect.cpp
2:   #include &quot;rect.hpp&quot;
3:   Rectangle::Rectangle(int top, int left, int bottom, int right)
4:   {
5:         itsTop = top;
6:         itsLeft = left;
7:         itsBottom = bottom;
8:         itsRight = right;
9:
10:        itsUpperLeft.SetX(left);
11:        itsUpperLeft.SetY(top);
12:
13:        itsUpperRight.SetX(right);
14:        itsUpperRight.SetY(top);
15:
16:        itsLowerLeft.SetX(left);
17:        itsLowerLeft.SetY(bottom);
18:
19:        itsLowerRight.SetX(right);
20:        itsLowerRight.SetY(bottom);
21:  }
22:
23:
24:  // compute area of the rectangle by finding corners,
25:  // establish width and height and then multiply
26:  int Rectangle::GetArea() const
27:  {
28:        int Width = itsRight-itsLeft;
29:        int Height = itsTop - itsBottom;
30:        return (Width * Height);
31:  }
32:
33:  int main()
34:  {
35:        //initialize a local Rectangle variable
36:        Rectangle MyRectangle (100, 20, 50, 80 );
37:
38:        int Area = MyRectangle.GetArea();
39:
40:        cout &lt;&lt; &quot;Area: &quot; &lt;&lt; Area &lt;&lt; &quot;\n&quot;;
41:        cout &lt;&lt; &quot;Upper Left X Coordinate: &quot;;
42:        cout &lt;&lt; MyRectangle.GetUpperLeft().GetX();
43:      return 0;
<TT>44: }</TT>
Output: Area: 3000
Upper Left X Coordinate: 20
</FONT></PRE>
<P><FONT COLOR="#000077"><B>Analysis: </B></FONT>Lines 3-14 in Listing 6.8 declare
the class <TT>Point</TT>, which is used to hold a specific x,y coordinate on a graph.
As written, this program doesn't use <TT>Point</TT>s much. However, other drawing
methods require <TT>Point</TT>s.<BR>
Within the declaration of the class <TT>Point</TT>, you declare two member variables
(<TT>itsX</TT> and <TT>itsY</TT>) on lines 12 and 13. These variables hold the values
of the coordinates. As the x-coordinate increases, you move to the right on the graph.
As the y-coordinate increases, you move upward on the graph. Other graphs use different
systems. Some windowing programs, for example, increase the y-coordinate as you move
down in the window.</P>
<P>The <TT>Point</TT> class uses inline accessor functions to get and set the <TT>X</TT>
and <TT>Y</TT> points declared on lines 7-10. <TT>Point</TT>s use the default constructor
and destructor. Therefore, you must set their coordinates explicitly.</P>
<P>Line 17 begins the declaration of a <TT>Rectangle</TT> class. A <TT>Rectangle</TT>
consists of four points that represent the corners of the <TT>Rectangle</TT>.</P>
<P>The constructor for the <TT>Rectangle</TT> (line 20) takes four integers, known
as <TT>top</TT>,<TT> left</TT>,<TT> bottom</TT>, and <TT>right</TT>. The four parameters
to the constructor are copied into four member variables (Listing 6.9) and then the
four <TT>Points</TT> are established.</P>
<P>In addition to the usual accessor functions, <TT>Rectangle</TT> has a function
<TT>GetArea()</TT> declared in line 43. Instead of storing the area as a variable,
the <TT>GetArea()</TT> function computes the area on lines 28-29 of Listing 6.9.
To do this, it computes the width and the height of the rectangle, and then it multiplies
these two values.</P>
<P>Getting the x-coordinate of the upper-left corner of the rectangle requires that
you access the <TT>UpperLeft</TT> point, and ask that point for its <TT>X</TT> value.
Because <TT>GetUpperLeft()</TT>is <TT>()</TT>a method of <TT>Rectangle</TT>, it can
directly access the private data of <TT>Rectangle</TT>, including <TT>itsUpperLeft</TT>.
Because <TT>itsUpperLeft</TT> is a <TT>Point</TT> and <TT>Point</TT>'s <TT>itsX</TT>
value is private, <TT>GetUpperLeft()</TT> cannot directly access this data. Rather,
it must use the public accessor function <TT>GetX()</TT> to obtain that value.</P>
<P>Line 33 of Listing 6.9 is the beginning of the body of the actual program. Until
line 36, no memory has been allocated, and nothing has really happened. The only
thing you've done is tell the compiler how to make a point and how to make a rectangle,
in case one is ever needed.</P>
<P>In line 36, you define a <TT>Rectangle</TT> by passing in values for <TT>Top</TT>,
<TT>Left</TT>, <TT>Bottom</TT>, and <TT>Right</TT>.</P>
<P>In line 38, you make a local variable, <TT>Area</TT>, of type <TT>int</TT>. This
variable holds the area of the <TT>Rectangle</TT> that you've created. You initialize
<TT>Area</TT> with the value returned by <TT>Rectangle</TT>'s <TT>GetArea()</TT>
function.</P>
<P>A client of <TT>Rectangle</TT> could create a <TT>Rectangle</TT> object and get
its area without ever looking at the implementation of <TT>GetArea()</TT>.</P>
<P><TT>RECT.HPP</TT> is shown in Listing 6.8. Just by looking at the header file,
which contains the declaration of the <TT>Rectangle</TT> class, the programmer knows
that <TT>GetArea()</TT> returns an <TT>int</TT>. How <TT>GetArea()</TT> does its
magic is not of concern to the user of class <TT>Rectangle</TT>. In fact, the author
of <TT>Rectangle</TT> could change <TT>GetArea()</TT> without affecting the programs
that use the <TT>Rectangle</TT> class.
<H3 ALIGN="CENTER"><A NAME="Heading44"></A><FONT COLOR="#000077">Structures</FONT></H3>
<P>A very close cousin to the <TT>class</TT> keyword is the keyword <TT>struct</TT>,
which is used to declare a structure. In C++, a structure is exactly like a class,
except that its members are public by default. You can declare a structure exactly
as you declare a class, and you can give it exactly the same data members and functions.
In fact, if you follow the good programming practice of always explicitly declaring
the private and public sections of your class, there will be no difference whatsoever.</P>
<P>Try re-entering Listing 6.8 with these changes:

<UL>
	<LI>In line 3, change <TT>class Point</TT> to <TT>struct Point</TT>.
	<P>
	<LI>In line 17, change <TT>class Rectangle</TT> to <TT>struct Rectangle</TT>.
</UL>

<P>Now run the program again and compare the output. There should be no change.
<H4 ALIGN="CENTER"><A NAME="Heading45"></A><FONT COLOR="#000077">Why Two Keywords
Do the Same Thing</FONT></H4>
<P>You're probably wondering why two keywords do the same thing. This is an accident
of history. When C++ was developed, it was built as an extension of the C language.
C has structures, although C structures don't have class methods. Bjarne Stroustrup,
the creator of C++, built upon <TT>struct</TT>s, but he changed the name to <TT>class</TT>
to represent the new, expanded functionality.


<BLOCKQUOTE>
	<P>
<HR>
<B>DO</B> put your class declaration in an HPP file and your member functions in
	a CPP file. <B>DO</B> use <TT>const</TT> whenever you can.<B> DO</B> understand classes
	before you move on. 
<HR>


</BLOCKQUOTE>

<H3 ALIGN="CENTER"><A NAME="Heading46"></A><FONT COLOR="#000077">Summary</FONT></H3>
<P>Today you learned how to create new data types called classes. You learned how
to define variables of these new types, which are called objects.</P>
<P>A class has data members, which are variables of various types, including other
classes. A class also includes member functions--also known as methods. You use these
member functions to manipulate the member data and to perform other services.</P>
<P>Class members, both data and functions, can be public or private. Public members
are accessible to any part of your program. Private members are accessible only to
the member functions of the class.</P>
<P>It is good programming practice to isolate the interface, or declaration, of the
class in a header file. You usually do this in a file with an <TT>.HPP</TT> extension.
The implementation of the class methods is written in a file with a <TT>.CPP</TT>
extension.</P>
<P>Class constructors initialize objects. Class destructors destroy objects and are
often used to free memory allocated by methods of the class.
<H3 ALIGN="CENTER"><A NAME="Heading47"></A><FONT COLOR="#000077">Q&amp;A</FONT></H3>

<DL>
	<DD><B>Q. How big is a class object?<BR>
	</B><BR>
	<B>A</B>. A class object's size in memory is determined by the sum of the sizes of
	its member variables. Class methods don't take up room as part of the memory set
	aside for the object.<BR>
	Some compilers align variables in memory in such a way that two-byte variables actually
	consume somewhat more than two bytes. Check your compiler manual to be sure, but
	at this point there is no reason to be concerned with these details.<BR>
	<BR>
	<B>Q. If I declare a class Cat with a private member itsAge and then define two Cat
	objects, Frisky and Boots, can Boots access Frisky's itsAge member variable?</B><BR>
	<BR>
	<B>A</B>. No. While private data is available to the member functions of a class,
	different instances of the class cannot access each other's data. In other words,<TT>
	Frisky</TT>'s member functions can access <TT>Frisky</TT>'s data, but not <TT>Boots</TT>'.
	In fact, <TT>Frisky</TT> is a completely independent cat from <TT>Boots</TT>, and
	that is just as it should be.<BR>
	<BR>
	<B>Q. Why shouldn't I make all the member data public?<BR>
	</B><BR>
	<B>A</B>. Making member data private enables the client of the class to use the data
	without worrying about how it is stored or computed. For example, if the <TT>Cat</TT>
	class has a method <TT>GetAge()</TT>, clients of the <TT>Cat</TT> class can ask for
	the cat's age without knowing or caring if the cat stores its age in a member variable,
	or computes its age on the fly.<BR>
	<BR>
	<B>Q. If using a const function to change the class causes a compiler error, why
	shouldn't I just leave out the word const and be sure to avoid errors?</B><BR>
	<BR>
	<B>A</B>. If your member function logically shouldn't change the class, using the
	keyword <TT>const</TT> is a good way to enlist the compiler in helping you find silly
	mistakes. For example, <TT>GetAge()</TT> might have no reason to change the <TT>Cat</TT>
	class, but your implementation has this line:
</DL>

<PRE><FONT COLOR="#0066FF">
if (itsAge = 100) cout &lt;&lt; &quot;Hey! You're 100 years old\n&quot;;
</FONT></PRE>

<DL>
	<DD>Declaring <TT>GetAge()</TT> to be <TT>const</TT> causes this code to be flagged
	as an error. You meant to check whether <TT>itsAge</TT> is equal to 100, but instead
	you inadvertently assigned 100 to <TT>itsAge</TT>. Because this assignment changes
	the class--and you said this method would not change the class--the compiler is able
	to find the error.<BR>
	This kind of mistake can be hard to find just by scanning the code. The eye often
	sees only what it expects to see. More importantly, the program might appear to run
	correctly, but <TT>itsAge</TT> has now been set to a bogus number. This will cause
	problems sooner or later.<BR>
	<BR>
	<B>Q. Is there ever a reason to use a structure in a C++ program?<BR>
	</B><BR>
	<B>A.</B> Many C++ programmers reserve the <TT>struct</TT> keyword for classes that
	have no functions. This is a throwback to the old C structures, which could not have
	functions. Frankly, I find it confusing and poor programming practice. Today's methodless
	structure might need methods tomorrow. Then you'll be forced either to change the
	type to <TT>class</TT> or to break your rule and end up with a structure with methods.
</DL>

<H3 ALIGN="CENTER"><A NAME="Heading48"></A><FONT COLOR="#000077">Workshop</FONT></H3>
<P>The Workshop provides quiz questions to help you solidify your understanding of
the material covered and exercises to provide you with experience in using what you've
learned. Try to answer the quiz and exercise questions before checking the answers
in Appendix D, and make sure you understand the answers before continuing to the
next chapter.
<H4 ALIGN="CENTER"><A NAME="Heading49"></A><FONT COLOR="#000077">Quiz</FONT></H4>

<DL>
	<DD><B>1.</B> What is the dot operator, and what is it used for?<BR>
	<BR>
	<B>2.</B> Which sets aside memory--declaration or definition?<BR>
	<BR>
	<B>3.</B> Is the declaration of a class its interface or its implementation?<BR>
	<BR>
	<B>4.</B> What is the difference between public and private data members?<BR>
	<BR>
	<B>5.</B> Can member functions be private?<BR>
	<BR>
	<B>6.</B> Can member data be public?<BR>
	<BR>
	<B>7.</B> If you declare two <TT>Cat</TT> objects, can they have different values
	in their <TT>itsAge</TT> member data?<BR>
	<BR>
	<B>8. </B>Do class declarations end with a semicolon? Do class method definitions?<BR>
	<BR>
	<B>9.</B> What would the header for a <TT>Cat</TT> function, <TT>Meow</TT>, that
	takes no parameters and returns <TT>void</TT> look like?<BR>
	<B><BR>
	10.</B> What function is called to initialize a class?
</DL>

<H4 ALIGN="CENTER"><A NAME="Heading50"></A><FONT COLOR="#000077">Exercises</FONT></H4>

<DL>
	<DD><B>1.</B> Write the code that declares a class called <TT>Employee</TT> with
	these data members: <TT>age</TT>, <TT>yearsOfService</TT>, and <TT>Salary</TT>.<BR>
	<B><BR>
	2.</B> Rewrite the <TT>Employee</TT> class to make the data members private, and
	provide public accessor methods to get and set each of the data members.<BR>
	<B><BR>
	3.</B> Write a program with the <TT>Employee</TT> class that makes two <TT>Employee</TT>s;
	sets their <TT>age</TT>, <TT>YearsOfService</TT>, and <TT>Salary</TT>; and prints
	their values.<BR>
	<B><BR>
	4.</B> Continuing from Exercise 3, provide a method of <TT>Employee</TT> that reports
	how many thousands of dollars the employee earns, rounded to the nearest 1,000.<BR>
	<B><BR>
	5.</B> Change the <TT>Employee</TT> class so that you can initialize <TT>age</TT>,
	<TT>YearsOfService</TT>, and <TT>Salary</TT> when you create the employee.<BR>
	<B><BR>
	6.</B> BUG BUSTERS: What is wrong with the following declaration?
</DL>

<PRE><FONT COLOR="#0066FF">class Square
{
public:
    int Side;
}
</FONT></PRE>

<DL>
	<DD><B>7</B>. BUG BUSTERS: Why isn't the following class declaration very useful?
</DL>

<PRE><FONT COLOR="#0066FF">class Cat
{
    int GetAge()const;
private:
    int itsAge;
};
</FONT></PRE>

<DL>
	<DD><B>8.</B> BUG BUSTERS: What three bugs in this code will the compiler find?
</DL>

<PRE><FONT COLOR="#0066FF">class  TV
{
public:
    void SetStation(int Station);
    int GetStation() const;
private:
    int itsStation;
};
main()
{
    TV myTV;
    myTV.itsStation = 9;
    TV.SetStation(10);
    TV myOtherTv(2);
}
</FONT></PRE>
<PRE ALIGN="CENTER"><FONT COLOR="#0066FF"></FONT></PRE>
<P ALIGN="CENTER"><A HREF="ch05.htm"><IMG SRC="../buttons/BLANPREV.GIF"
WIDTH="37" HEIGHT="37" ALIGN="BOTTOM" BORDER="0"></A><A HREF="http://www.mcp.com/sams"><IMG
SRC="../buttons/BLANHOME.GIF" WIDTH="37" HEIGHT="37" ALIGN="BOTTOM"
BORDER="0"></A><A HREF="../index.htm"><IMG SRC="../buttons/BLANTOC.GIF"
WIDTH="37" HEIGHT="37" ALIGN="BOTTOM" BORDER="0"></A><A HREF="ch07.htm"><IMG SRC="../buttons/BLANNEXT.GIF"
WIDTH="37" HEIGHT="37" ALIGN="BOTTOM" BORDER="0"></A><A HREF="#heading1"><IMG SRC="../buttons/BLANTOP.GIF"
WIDTH="37" HEIGHT="37" ALIGN="BOTTOM" BORDER="0"></A>


</BODY>

</HTML>