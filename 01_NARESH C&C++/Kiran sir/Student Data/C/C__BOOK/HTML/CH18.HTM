<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>

<HEAD>
<!-- This document was created from RTF source by rtftohtml version 3.0.1 -->

	<META NAME="GENERATOR" Content="Symantec Visual Page 1.0">
	<META HTTP-EQUIV="Content-Type" CONTENT="text/html;CHARSET=iso-8859-1">
	<TITLE>Teach Yourself C++ in 21 Days</TITLE>
</HEAD>

<BODY TEXT="#000000" BGCOLOR="#FFFFFF">

<H1 ALIGN="CENTER"><A HREF="ch17.htm"><IMG SRC="../buttons/BLANPREV.GIF"
WIDTH="37" HEIGHT="37" ALIGN="BOTTOM" BORDER="0"></A><A HREF="http://www.mcp.com/sams"><IMG
SRC="../buttons/BLANHOME.GIF" WIDTH="37" HEIGHT="37" ALIGN="BOTTOM"
BORDER="0"></A><A HREF="../index.htm"><IMG SRC="../buttons/BLANTOC.GIF"
WIDTH="37" HEIGHT="37" ALIGN="BOTTOM" BORDER="0"></A><A HREF="ch19.htm"><IMG SRC="../buttons/BLANNEXT.GIF"
WIDTH="37" HEIGHT="37" ALIGN="BOTTOM" BORDER="0"></A></H1>
<H1></H1>

<UL>
	<LI><A HREF="#Heading1">Day 18</A>
	<UL>
		<LI><A HREF="#Heading2">Object-Oriented Analysis and Design</A>
		<UL>
			<LI><A HREF="#Heading3">The Development Cycle</A>
			<LI><A HREF="#Heading4">Simulating an Alarm System</A>
			<UL>
				<LI><A HREF="#Heading5">Preliminary Design</A>
				<LI><A HREF="#Heading6">What Are the Objects?</A>
				<LI><A HREF="#Heading7">Other Objects</A>
				<LI><A HREF="#Heading8">What Are the Classes?</A>
				<LI><A HREF="#Heading9">How Are Alarms Reported?</A>
				<LI><A HREF="#Heading10">Event Loops</A>
			</UL>
			<LI><A HREF="#Heading11">Listing 18.1. A simple event loop</A><A HREF="#Heading12">.</A>
			<LI><A HREF="#Heading13">PostMaster</A>
			<LI><A HREF="#Heading14">Measure Twice, Cut Once</A>
			<LI><A HREF="#Heading15">Divide and Conquer</A>
			<LI><A HREF="#Heading16">Message Format</A>
			<LI><A HREF="#Heading17">Initial Class Design</A>
			<LI><A HREF="#Heading18">Rooted Hierarchies Versus Non-Rooted Hierarchies</A>
			<UL>
				<LI><A HREF="#Heading19">Figure 18.1.</A>
			</UL>
			<LI><A HREF="#Heading20">Designing the Interfaces</A>
			<UL>
				<LI><A HREF="#Heading21">Building a Prototype</A>
				<LI><A HREF="#Heading22">The 80/80 Rule</A>
			</UL>
			<LI><A HREF="#Heading23">Designing the PostMasterMessage Class</A>
			<UL>
				<LI><A HREF="#Heading24">Application Program Interface</A>
			</UL>
			<LI><A HREF="#Heading25">Listing 18.2. PostMasterMessages interface</A><A HREF="#Heading26">.</A>
			<UL>
				<LI><A HREF="#Heading27">Programming in Large Groups</A>
				<LI><A HREF="#Heading28">Ongoing Design Considerations</A>
			</UL>
			<LI><A HREF="#Heading29">Design Decisions</A>
			<UL>
				<LI><A HREF="#Heading30">Decisions, Decisions</A>
			</UL>
			<LI><A HREF="#Heading31">Working with Driver Programs</A>
			<LI><A HREF="#Heading32">Listing 18.3. A driver program for PostMasterMessage</A><A
			HREF="#Heading33">.</A>
			<LI><A HREF="#Heading34">Summary</A>
			<LI><A HREF="#Heading35">Q&amp;A</A>
			<LI><A HREF="#Heading36">Workshop</A>
			<UL>
				<LI><A HREF="#Heading37">Quiz</A>
				<LI><A HREF="#Heading38">Exercises</A>
			</UL>
		</UL>
	</UL>
</UL>

<P>
<HR SIZE="4">

<H2 ALIGN="CENTER"><A NAME="Heading1"></A><FONT COLOR="#000077">Day 18</FONT></H2>
<H2 ALIGN="CENTER"><A NAME="Heading2"></A><FONT COLOR="#000077">Object-Oriented Analysis
and Design</FONT></H2>
<P>It is easy to become focused on the syntax of C++ and to lose sight of how and
why you use these techniques to build programs. Today you will learn

<UL>
	<LI>How to analyze problems from an object-oriented perspective.
	<P>
	<LI>How to design your program from an object-oriented perspective.
	<P>
	<LI>How to design for reusability and extensibility.
</UL>

<H3 ALIGN="CENTER"><A NAME="Heading3"></A><FONT COLOR="#000077">The Development Cycle</FONT></H3>
<P>Many volumes have been written about the development cycle. Some propose a &quot;waterfall&quot;
method, in which designers determine what the program should do; architects determine
how the program will be built, what classes will be used, and so forth; and then
programmers implement the design and architecture. By the time the design and architecture
is given to the programmer, it is complete; all the programmer needs to do is implement
the required functionality.</P>
<P>Even if the waterfall method worked, it would probably be a poor method for writing
good programs. As the programmer proceeds, there is a necessary and natural feedback
between what has been written so far and what remains to be done. While it is true
that good C++ programs are designed in great detail before a line of code is written,
it is not true that that design remains unchanged throughout the cycle.</P>
<P>The amount of design that must be finished &quot;up front,&quot; before programming
begins, is a function of the size of the program. A highly complex effort, involving
dozens of programmers working for many months, will require a more fully articulated
architecture than a quick-and-dirty utility written in one day by a single programmer.</P>
<P>This chapter will focus on the design of large, complex programs which will be
expanded and enhanced over many years. Many programmers enjoy working at the bleeding
edge of technology; they tend to write programs whose complexity pushes at the limits
of their tools and understanding. In many ways, C++ was designed to extend the complexity
that a programmer or team of programmers could manage.</P>
<P>This chapter will examine a number of design problems from an object-oriented
perspective. The goal will be to review the analysis process, and then to understand
how you apply the syntax of C++ to implement these design objectives.
<H3 ALIGN="CENTER"><A NAME="Heading4"></A><FONT COLOR="#000077">Simulating an Alarm
System</FONT></H3>
<P>A simulation is a computer model of a part of a real-world system. There are many
reasons to build a simulation, but a good design must start with an understanding
of what questions you hope the simulation will answer.</P>
<P>As a starting point, examine this problem: You have been asked to simulate the
alarm system for a house. The house is a center hall colonial with four bedrooms,
a finished basement, and an under-the-house garage.</P>
<P>The downstairs has the following windows: three in the kitchen, four in the dining
room, one in the half-bathroom, two each in the living room and the family room,
and two small windows next to the door. All four bedrooms are upstairs, each of which
has two windows except for the master bedroom, which has four. There are two baths,
each with one window. Finally, there are four half-windows in the basement, and one
window in the garage.</P>
<P>Normal access to the house is through the front door. Additionally, the kitchen
has a sliding glass door, and the garage has two doors for the cars and one door
for easy access to the basement. There is also a cellar door in the backyard.</P>
<P>All the windows and doors are alarmed, and there are panic buttons on each phone
and next to the bed. The grounds are alarmed as well, though these are carefully
calibrated so that they are not set off by small animals or birds.</P>
<P>There is a central alarm system in the basement, which sounds a warning chirp
when the alarm has been tripped. If the alarm is not disabled within a setable amount
of time, the police are called. If a panic button is pushed, the police are called
immediately.</P>
<P>The alarm is also wired into the fire and smoke detectors and the sprinkler system,
and the alarm system itself is fault tolerant, has its own internal backup power
supply, and is encased in a fireproof box.
<H4 ALIGN="CENTER"><A NAME="Heading5"></A><FONT COLOR="#000077">Preliminary Design</FONT></H4>
<P>You begin by asking, &quot;What questions might this simulation answer?&quot;
For example, you might be able to use the simulation to answer the questions, &quot;How
long might a sensor be broken before anyone notices?&quot; or &quot;Is there a way
to defeat the window alarms without the police being notified?&quot;</P>
<P>Once you understand the purpose of the simulation you will know what parts of
the real system the program must model. Once that is well understood, it becomes
much easier to design the program itself.
<H4 ALIGN="CENTER"><A NAME="Heading6"></A><FONT COLOR="#000077">What Are the Objects?</FONT></H4>
<P>One way to approach this problem is to set aside issues relating to the user interface
and to focus only on the components of the &quot;problem space.&quot; A first approximation
of an object-oriented design might be to list the objects that you need to simulate,
and then to examine what these objects &quot;know&quot; and &quot;do.&quot;</P>

<DL>
	<DD>
<HR>
<FONT COLOR="#000077"><B>New Term:</B></FONT><B> </B>The <I>problem space</I> is
	the set of problems and issues your program is trying to solve. The solution space
	is the set of possible solutions to the problems. 
<HR>

</DL>

<P>For example, clearly you have sensors of various types, a central alarm system,
buttons, wires, and telephones. Further thought convinces you that you must also
simulate rooms, perhaps floors, and possibly groups of people such as owners and
police.</P>
<P>The sensors can be divided into motion detectors, trip wires, sound detectors,
smoke detectors, and so forth. All of these are types of sensors, though there is
no such thing as a sensor per se. This is a good indication that sensor is an abstract
data type (ADT).</P>
<P>As an ADT, the class sensor would provide the complete interface for all types
of sensors, and each derived type would provide the implementation. Clients of the
various sensors would use them without regard to which type of sensor they are, and
they would each &quot;do the right thing&quot; based on their real type.</P>
<P>To create a good ADT, you need to have a complete understanding of what sensors
do (rather than how they work). For example, are sensors passive devices or are they
active? Do they wait for some element to heat up, a wire to break, or a piece of
caulk to melt, or do they probe their environment? Perhaps some sensors have only
a binary state (alarm state or okay), but others have a more analog state (what is
the current temperature?). The interface to the abstract data type should be sufficiently
complete to handle all the anticipated needs of the myriad derived classes.
<H4 ALIGN="CENTER"><A NAME="Heading7"></A><FONT COLOR="#000077">Other Objects</FONT></H4>
<P>The design continues in this way, teasing out the various other classes that will
be required to meet the specification. For example, if a log is to be kept, probably
a timer will be needed; should the timer poll each sensor or should each sensor file
its own report periodically?</P>
<P>The user is going to need to be able to set up, disarm, and program the system,
and so a terminal of some sort will be required. You may want a separate object in
your simulation for the alarm program itself.
<H4 ALIGN="CENTER"><A NAME="Heading8"></A><FONT COLOR="#000077">What Are the Classes?</FONT></H4>
<P>As you solve these problems, you will begin to design your classes. For example,
you already have an indication that <TT>HeatSensor</TT> will derive from <TT>Sensor</TT>.
If the sensor is to make periodic reports, it may also derive via multiple inheritance
from <TT>Timer</TT>, or it may have a timer as a member variable.</P>
<P>The <TT>HeatSensor</TT> will probably have member functions such as <TT>CurrentTemp()</TT>
and <TT>SetTempLimit()</TT> and will probably inherit functions such as <TT>SoundAlarm()</TT>
from its base class, <TT>Sensor</TT>.</P>
<P>A frequent issue in object-oriented design is that of encapsulation. You could
imagine a design in which the alarm system has a setting for <TT>MaxTemp</TT>. The
alarm system asks the heat sensor what the current temperature is, compares it to
the maximum temperature, and sounds the alarm if it is too hot. One could argue that
this violates the principle of encapsulation. Perhaps it would be better if the alarm
system didn't know or care what the details are of temperature analysis; arguably
that should be in the <TT>HeatSensor</TT>.</P>
<P>Whether or not you agree with that argument, it is the kind of decision you want
to focus on during the analysis of the problem. To continue this analysis, one could
argue that only the <TT>Sensor</TT> and the <TT>Log</TT> object should know any details
of how sensor activity is logged; the <TT>Alarm</TT> object shouldn't know or care.</P>
<P>Good encapsulation is marked by each class having a coherent and complete set
of responsibilities, and no other class having the same responsibilities. If the
sensor is responsible for noting the current temperature, no other class should have
that responsibility.</P>
<P>On the other hand, other classes might help deliver the necessary functionality.
For example, while it might be the responsibility of the <TT>Sensor</TT> class to
note and log the current temperature, it might implement that responsibility by delegating
to a <TT>Log</TT> object the job of actually recording the data.</P>
<P>Maintaining a firm division of responsibilities makes your program easier to extend
and maintain. When you decide to change the alarm system for an enhanced module,
its interface to the log and to the sensors will be narrow and well defined. Changes
to the alarm system should not affect the <TT>Sensor</TT> classes, and vice versa.</P>
<P>Should the <TT>HeatSensor</TT> have a <TT>ReportAlarm()</TT> function? All sensors
will need the ability to report an alarm. This is a good indication that <TT>ReportAlarm()</TT>
should be a virtual method of <TT>Sensor</TT>, and that <TT>Sensor</TT> may be an
abstract base class. It is possible that <TT>HeatSensor</TT> will chain up to <TT>Sensor</TT>'s
more general <TT>ReportAlarm()</TT> method; the overridden function would just fill
in the details it is uniquely qualified to supply.
<H4 ALIGN="CENTER"><A NAME="Heading9"></A><FONT COLOR="#000077">How Are Alarms Reported?</FONT></H4>
<P>When your sensors report an alarm condition, they will want to provide a lot of
information to the object that phones the police and to the log. It may well be that
you'll want to create a <TT>Condition</TT> class, whose constructor takes a number
of measurements. Depending on the complexity of the measurements, these too might
be objects, or they might be simple scalar values such as integers.</P>
<P>It is possible that <TT>Condition</TT> objects are passed to the central <TT>Alarm</TT>
object, or that <TT>Condition</TT> objects are subclassed into <TT>Alarm</TT> objects,
which themselves know how to take emergency action. Perhaps there is no central object;
instead there might be sensors, which know how to create <TT>Condition</TT> objects.
Some <TT>Condition</TT> objects would know how to log themselves; others might know
how to contact the police.</P>
<P>A well-designed event-driven system need not have a central coordinator. One can
imagine the sensors all independently receiving and sending message objects to one
another, setting parameters, taking readings, and monitoring the house. When a fault
is detected, an <TT>Alarm</TT> object is created, which logs the problem (by sending
a message to the <TT>Log</TT> object) and takes the appropriate action.
<H4 ALIGN="CENTER"><A NAME="Heading10"></A><FONT COLOR="#000077">Event Loops</FONT></H4>
<P>To simulate such an event-driven system, your program needs to create an event
loop. An event loop is typically an infinite loop such as <TT>while(1)</TT>, which
gets messages from the operating system (mouse clicks, keyboard presses, and so on)
and dispatches them one by one, returning to the loop until an exit condition is
satisfied. Listing 18.1 shows a rudimentary event loop.</P>
<P><A NAME="Heading11"></A><FONT SIZE="4" COLOR="#000077"><B>Listing 18.1. A simple
event loop.</B></FONT></P>
<PRE><FONT COLOR="#0066FF">1:     // Listing 18.1
2:
3:     #include &lt;iostream.h&gt;
4:
5:     class Condition
6:     {
7:     public:
8:        Condition() { }
9:        virtual ~Condition() {}
10:       virtual void Log() = 0;
11:    };
12:
13:    class Normal : public Condition
14:    {
15:    public:
16:       Normal() { Log(); }
17:       virtual ~Normal() {}
18:       virtual void Log() { cout &lt;&lt; &quot;Logging normal conditions...\n&quot;; }
19:    };
20:
21:    class Error : public Condition
22:    {
23:    public:
24:       Error() {Log();}
25:       virtual ~Error() {}
26:       virtual void Log() { cout &lt;&lt; &quot;Logging error!\n&quot;; }
27:    };
28:
29:    class Alarm : public Condition
30:    {
31:    public:
32:       Alarm ();
33:       virtual   ~Alarm() {}
34:       virtual void Warn() { cout &lt;&lt; &quot;Warning!\n&quot;; }
35:       virtual void Log() { cout &lt;&lt; &quot;General Alarm log\n&quot;; }
36:       virtual void Call() = 0;
37:
38:    };
39:
40:    Alarm::Alarm()
41:    {
42:        Log();
43:       Warn();
44:    }
45:    class FireAlarm : public Alarm
46:    {
47:    public:
48:       FireAlarm(){Log();};
49:       virtual ~FireAlarm() {}
50:       virtual void Call() { cout&lt;&lt; &quot;Calling Fire Dept.!\n&quot;; }
51:       virtual void Log() { cout &lt;&lt; &quot;Logging fire call.\n&quot;; }
52:    };
53:
54:    int main()
55:    {
56:       int input;
57:       int okay = 1;
58:       Condition * pCondition;
59:       while (okay)
60:       {
61:          cout &lt;&lt; &quot;(0)Quit (1)Normal (2)Fire: &quot;;
62:          cin &gt;&gt; input;
63:          okay = input;
64:          switch (input)
65:          {
66:             case 0: break;
67:             case 1:
68:                pCondition = new Normal;
69:                delete pCondition;
70:                break;
71:             case 2:
72:                pCondition = new FireAlarm;
73:                delete pCondition;
74:                break;
75:             default:
76:                pCondition = new Error;
77:                delete pCondition;
78:                okay = 0;
79:                break;
80:          }
81:       }
82:     return 0;
<TT>83: }</TT></FONT>
<FONT COLOR="#0066FF">
Output: (0)Quit (1)Normal (2)Fire: 1
Logging normal conditions...
(0)Quit (1)Normal (2)Fire: 2
General Alarm log
Warning!
Logging fire call.
(0)Quit (1)Normal (2)Fire: 0
</FONT></PRE>
<P><FONT COLOR="#000077"><B>Analysis:</B></FONT><B> </B>The simple loop created on
lines 59-80 allows the user to enter input simulating a normal report from a sensor
and a report of a fire. Note that the effect of this report is to spawn a <TT>Condition</TT>
object whose constructor calls various member functions.<BR>
<BR>
Calling virtual member functions from a constructor can cause confusing results if
you are not mindful of the order of construction of objects. For example, when the
<TT>FireAlarm</TT> object is created on line 72, the order of construction is <TT>Condition</TT>,
<TT>Alarm</TT>, <TT>FireAlarm</TT>. The <TT>Alarm</TT> constructor calls <TT>Log</TT>,
but it is <TT>Alarm</TT>'s <TT>Log()</TT>, not <TT>FireAlarm</TT>'s, that is invoked,
despite <TT>Log()</TT> being declared virtual. This is because at the time <TT>Alarm</TT>'s
constructor runs, there is no <TT>FireAlarm</TT> object. Later, when <TT>FireAlarm</TT>
itself is constructed, its constructor calls <TT>Log()</TT> again, and this time
<TT>FireAlarm::Log()</TT> is called.
<H3 ALIGN="CENTER"><A NAME="Heading13"></A><FONT COLOR="#000077">PostMaster</FONT></H3>
<P>Here's another problem on which to practice your object-oriented analysis: You
have been hired by Acme Software, Inc., to start a new software project and to hire
a team of C++ programmers to implement your program. Jim Grandiose, vice-president
of new product development, is your new boss. He wants you to design and build PostMaster,
a utility to read electronic mail from various unrelated e-mail providers. The potential
customer is a businessperson who uses more than one e-mail product, for example Interchange,
CompuServe, Prodigy, America Online, Delphi, Internet Mail, Lotus Notes, AppleMail,
cc:Mail, and so forth.</P>
<P>The customer will be able to &quot;teach&quot; PostMaster how to dial up or otherwise
connect to each of the e-mail providers, and PostMaster will get the mail and then
present it in a uniform manner, allowing the customer to organize the mail, reply,
forward letters among services, and so forth.</P>
<P>PostMasterProfessional, to be developed as version 2 of PostMaster, is already
anticipated. It will add an Administrative Assistant mode, which will allow the user
to designate another person to read some or all of the mail, to handle routine correspondence,
and so forth. There is also speculation in the marketing department that an artificial
intelligence component might add the capability for PostMaster to pre-sort and prioritize
the mail based on subject and content keywords and associations.</P>
<P>Other enhancements have been talked about, including the ability to handle not
only mail but discussion groups such as Interchange discussions, CompuServe forums,
Internet newsgroups, and so forth. It is obvious that Acme has great hopes for PostMaster,
and you are under severe time constraints to bring it to market, though you seem
to have a nearly unlimited budget.
<H3 ALIGN="CENTER"><A NAME="Heading14"></A><FONT COLOR="#000077">Measure Twice, Cut
Once</FONT></H3>
<P>You set up your office and order your equipment, and then your first order of
business is to get a good specification for the product. After examining the market,
you decide to recommend that development be focused on a single platform, and you
set out to decide among DOS; UNIX; the Macintosh; and Windows, Windows NT, and OS/2.</P>
<P>You have many painful meetings with Jim Grandiose, and it becomes clear that there
is no right choice, and so you decide to separate the front end, that is the user
interface or UI, from the back end, the communications and database part. To get
things going quickly, you decide to write for DOS first, followed by Win32, the Mac,
and then UNIX and OS/2.</P>
<P>This simple decision has enormous ramifications for your project. It quickly becomes
obvious that you will need a class library or a series of libraries to handle memory
management, the various user interfaces, and perhaps also the communications and
database components.</P>
<P>Mr. Grandiose believes strongly that projects live or die by having one person
with a clear vision, so he asks that you do the initial architectural analysis and
design before hiring any programmers. You set out to analyze the problem.
<H3 ALIGN="CENTER"><A NAME="Heading15"></A><FONT COLOR="#000077">Divide and Conquer</FONT></H3>
<P>It quickly becomes obvious that you really have more than one problem to solve.
You divide the project into these significant sub-projects:

<DL>
	<DD><B>1.</B> Communications: the ability for the software to dial into the e-mail
	provider via modem, or to connect over a network.<BR>
	<BR>
	<B>2.</B> Database: the ability to store data and to retrieve it from disk.<BR>
	<BR>
	<B>3.</B> E-mail: the ability to read various e-mail formats and to write new messages
	to each system.<BR>
	<BR>
	<B>4.</B> Editing: providing state-of-the-art editors for the creation and manipulation
	of messages.<BR>
	<BR>
	<B>5.</B> Platform issues: the various UI issues presented by each platform (DOS,
	Macintosh, and so on).<BR>
	<BR>
	<B>6.</B> Extensibility: planning for growth and enhancements.<BR>
	<BR>
	<B>7.</B> Organization and scheduling: managing the various developers and their
	code interdependencies. Each group must devise and publish schedules, and then be
	able to plan accordingly. Senior management and marketing need to know when the product
	will be ready.
</DL>

<P>You decide to hire a manager to handle item 7, organization and scheduling. You
then hire senior developers to help you analyze and design, and then to manage the
implementation of the remaining areas. These senior developers will create the following
teams:

<DL>
	<DD><B>1.</B> Communications: responsible for both dial-up and network communications.
	They deal with packets, streams, and bits, rather than with e-mail messages per se.<BR>
	<BR>
	<B>2.</B> Message format: responsible for converting messages from each e-mail provider
	to a canonical form (PostMaster standard) and back. It is also their job to write
	these messages to disk and to get them back off the disk as needed.<BR>
	<BR>
	<B>3.</B> Message editors: This group is responsible for the entire UI of the product,
	on each platform. It is their job to ensure that the interface between the back end
	and the front end of the product is sufficiently narrow that extending the product
	to other platforms does not require duplication of code.
</DL>

<H3 ALIGN="CENTER"><A NAME="Heading16"></A><FONT COLOR="#000077">Message Format</FONT></H3>
<P>You decide to focus on the message format first, setting aside the issues relating
to communications and user interface. These will follow once you understand more
fully what it is you are dealing with. There is little sense in worrying about how
to present the information to the user until you understand what information you
are dealing with.</P>
<P>An examination of the various e-mail formats reveals that they have many things
in common, despite their various differences. Each e-mail message has a point of
origination, a destination, and a creation date. Nearly all such messages have a
title or subject line and a body which may consist of simple text, rich text (text
with formatting), graphics, and perhaps even sound or other fancy additions. Most
such e-mail services also support attachments, so that users can send programs and
other files.</P>
<P>You confirm your early decision that you will read each mail message out of its
original format and into PostMaster format. This way you will only have to store
one record format, and writing to and reading from the disk will be simplified. You
also decide to separate the &quot;header&quot; information (sender, recipient, date,
title, and so on) from the body of the message. Often the user will want to scan
the headers without necessarily reading the contents of all the messages. You anticipate
that a time may come when users will want to download only the headers from the message
provider, without getting the text at all, but for now you intend that version 1
of PostMaster will always get the full message, although it may not display it to
the user.
<H3 ALIGN="CENTER"><A NAME="Heading17"></A><FONT COLOR="#000077">Initial Class Design</FONT></H3>
<P>This analysis of the messages leads you to design the <TT>Message</TT> class.
In anticipation of extending the program to non-e-mail messages, you derive <TT>EmailMessage</TT>
from the abstract base <TT>Message</TT>. From <TT>EmailMessage</TT> you derive <TT>PostMasterMessage</TT>,
<TT>InterchangeMessage</TT>, <TT>CISMessage</TT>, <TT>ProdigyMessage</TT>, and so
forth.</P>
<P>Messages are a natural choice for objects in a program handling mail messages,
but finding all the right objects in a complex system is the single greatest challenge
of object-oriented programming. In some cases, such as with messages, the primary
objects seem to &quot;fall out&quot; of your understanding of the problem. More often,
however, you have to think long and hard about what you are trying to accomplish
to find the right objects.</P>
<P>Don't despair. Most designs are not perfect the first time. A good starting point
is to describe the problem out loud. Make a list of all the nouns and verbs you use
when describing the project. The nouns are good candidates for objects. The verbs
might be the methods of those objects (or they may be objects in their own right).
This is not a foolproof method, but it is a good technique to use when getting started
on your design.</P>
<P>That was the easy part. Now the question arises, &quot;Should the message header
be a separate class from the body?&quot; If so, do you need parallel hierarchies,
<TT>CompuServeBody</TT> and <TT>CompuServeHeader</TT>, as well as <TT>ProdigyBody</TT>
and <TT>ProdigyHeader</TT>?</P>
<P>Parallel hierarchies are often a warning sign of a bad design. It is a common
error in object-oriented design to have a set of objects in one hierarchy, and a
matching set of &quot;managers&quot; of those objects in another. The burden of keeping
these hierarchies up-to-date and in sync with each other soon becomes overwhelming:
a classic maintenance nightmare.</P>
<P>There are no hard-and-fast rules, of course, and at times such parallel hierarchies
are the most efficient way to solve a particular problem. Nonetheless, if you see
your design moving in this direction, you should rethink the problem; there may be
a more elegant solution available.</P>
<P>When the messages arrive from the e-mail provider, they will not necessarily be
separated into header and body; many will be one large stream of data, which your
program will have to disentangle. Perhaps your hierarchy should reflect that idea
directly.</P>
<P>Further reflection on the tasks at hand leads you to try to list the properties
of these messages, with an eye towards introducing capabilities and data storage
at the right level of abstraction. Listing properties of your objects is a good way
to find the data members, as well as to &quot;shake out&quot; other objects you might
need.</P>
<P>Mail messages will need to be stored, as will the user's preferences, phone numbers,
and so forth. Storage clearly needs to be high up in the hierarchy. Should the mail
messages necessarily share a base class with the preferences?
<H3 ALIGN="CENTER"><A NAME="Heading18"></A><FONT COLOR="#000077">Rooted Hierarchies
Versus Non-Rooted Hierarchies</FONT></H3>
<P>There are two overall approaches to inheritance hierarchies: you can have all,
or nearly all, of your classes descend from a common root class, or you can have
more than one inheritance hierarchy. An advantage of a common root class is that
you often can avoid multiple inheritance; a disadvantage is that many times implementation
will percolate up into the base class.</P>

<DL>
	<DD>
<HR>
<FONT COLOR="#000077"><B>New Term: </B></FONT>A set of classes is <I>rooted</I> if
	all share a common ancestor. <I>Non-rooted</I> hierarchies do not all share a common
	base class. 
<HR>

</DL>

<P>Because you know that your product will be developed on many platforms, and because
multiple inheritance is complex and not necessarily well supported by all compilers
on all platforms, your first decision is to use a rooted hierarchy and single inheritance.
You decide to identify those places where multiple inheritance might be used in the
future, and to design so that breaking apart the hierarchy and adding multiple inheritance
at a later time need not be traumatic to your entire design.</P>
<P>You decide to prefix the name of all of your internal classes with the letter
<TT>p</TT> so that you can easily and quickly tell which classes are yours and which
are from other libraries. On Day 21, &quot;What's Next,&quot; you'll learn about
name spaces, which can reinforce this idea, but for now the initial will do nicely.</P>
<P>Your root class will be <TT>pObject</TT>; virtually every class you create will
descend from this object. <TT>pObject</TT> itself will be kept fairly simple; only
that data which absolutely every item shares will appear in this class.</P>
<P>If you want a rooted hierarchy, you'll want to give the root class a fairly generic
name (like <TT>pObject</TT>) and few capabilities. The point of a root object is
to be able to create collections of all its descendants and refer to them as instances
of <TT>pObject</TT>. The trade-off is that rooted hierarchies often percolate interface
up into the root class. You will pay the price; by percolating these interfaces up
into the root object, other descendants will have interfaces that are inappropriate
to their design. The only good solution to this problem, in single inheritance, is
to use templates. Templates are discussed tomorrow.</P>
<P>The next likely candidates for top of the hierarchy status are <TT>pStored</TT>
and <TT>pWired</TT>. <TT>pStored</TT> objects are saved to disk at various times
(for example when the program is not in use), and <TT>pWired</TT> objects are sent
over the modem or network. Because nearly all of your objects will need to be stored
to disk, it makes sense to push this functionality up high in the hierarchy. Because
all the objects that are sent over the modem must be stored, but not all stored objects
must be sent over the wire, it makes sense to derive <TT>pWired</TT> from <TT>pStored</TT>.</P>
<P>Each derived class acquires all the knowledge (data) and functionality (methods)
of its base class, and each should add one discrete additional ability. Thus, <TT>pWired</TT>
may add various methods, but all are in service of adding the ability to be transferred
over the modem.</P>
<P>It is possible that all wired objects are stored, or that all stored objects are
wired, or that neither of these statements is true. If only some wired objects are
stored, and only some stored objects are wired, you will be forced either to use
multiple inheritance or to &quot;hack around&quot; the problem. A potential &quot;hack&quot;
for such a situation would be to inherit, for example, <TT>Wired</TT> from <TT>Stored</TT>,
and then for those objects that are sent via modem, but are never stored, to make
the stored methods do nothing or return an error.</P>
<P>In fact, you realize that some stored objects clearly are not wired: for example,
user preferences. All wired objects, however, are stored, and so your inheritance
hierarchy so far is as reflected in Figure 18.1.<BR>
<BR>
<A NAME="Heading19"></A><A HREF="../art/ch18/18zcp01.jpg"><FONT COLOR="#000077">Figure
18.1.</FONT></A><FONT COLOR="#000077"> </FONT><I>Initial inheritance hierarchy.</I>
<H3 ALIGN="CENTER"><A NAME="Heading20"></A><FONT COLOR="#000077">Designing the Interfaces</FONT></H3>
<P>It is important at this stage of designing your product to avoid being concerned
with implementation. You want to focus all of your energies on designing a clean
interface among the classes and then delineating what data and methods each class
will need.</P>
<P>It is often a good idea to have a solid understanding of the base classes before
trying to design the more derived classes, so you decide to focus on <TT>pObject</TT>,
<TT>pStored</TT>, and <TT>pWired</TT>.</P>
<P>The root class, <TT>pObject</TT>, will only have the data and methods that are
common to everything on your system. Perhaps every object should have a unique identification
number. You could create <TT>pID</TT> (PostMaster ID) and make that a member of <TT>pObject</TT>;
but first you must ask yourself, &quot;Does any object that is not stored and not
wired need such a number?&quot; That begs the question, &quot;Are there any objects
that are not stored, but that are part of this hierarchy?&quot;</P>
<P>If there are no such objects, you may want to consider collapsing <TT>pObject</TT>
and <TT>pStored</TT> into one class; after all, if all objects are stored, what is
the point of the differentiation? Thinking this through, you realize that there may
be some objects, such as address objects, that it would be beneficial to derive from
<TT>pObject</TT>, but that will never be stored on their own; if they are stored,
they will be as part of some other object.</P>
<P>That says that for now having a separate <TT>pObject</TT> class would be useful.
One can imagine that there will be an address book that would be a collection of
<TT>pAddress</TT> objects, and while no <TT>pAddress</TT> will ever be stored on
its own, there would be utility in having each one have its own unique identification
number. You tentatively assign <TT>pID</TT> to <TT>pObject</TT>, and this means that
<TT>pObject</TT>, at a minimum, will look like this:</P>
<PRE><FONT COLOR="#0066FF">class pObject
{
public:
pObject();
~pObject();
pID GetID()const;
void SetID();
private:
pID  itsID;
}
</FONT></PRE>
<P>There are a number of things to note about this class declaration. First, this
class is not declared to derive from any other; this is your root class. Second,
there is no attempt to show implementation, even for methods such as <TT>GetID()</TT>
that are likely to have inline implementation when you are done.</P>
<P>Third, <TT>const</TT> methods are already identified; this is part of the interface,
not the implementation. Finally, a new data type is implied: <TT>pID</TT>. Defining
<TT>pID</TT> as a type, rather than using, for example, <TT>unsigned long</TT>, puts
greater flexibility into your design.</P>
<P>If it turns out that you don't need an <TT>unsigned long</TT>, or that an <TT>unsigned
long</TT> is not sufficiently large, you can modify <TT>pID</TT>. That modification
will affect every place <TT>pID</TT> is used, and you won't have to track down and
edit every file with a <TT>pID</TT> in it.</P>
<P>For now, you will use <TT>typedef</TT> to declare <TT>pID</TT> to be <TT>ULONG</TT>,
which in turn you will declare to be <TT>unsigned long</TT>. This raises the question:
Where do these declarations go?</P>
<P>When programming a large project, an overall design of the files is needed. A
standard approach, one which you will follow for this project, is that each class
appears in its own header file, and the implementation for the class methods appears
in an associated CPP file. Thus, you will have a file called <TT>OBJECT.HPP</TT>
and another called <TT>OBJECT.CPP</TT>. You anticipate having other files such as
<TT>MSG.HPP</TT> and <TT>MSG.CPP</TT>, with the declaration of <TT>pMessage</TT>
and the implementation of its methods, respectively.


<BLOCKQUOTE>
	<P>
<HR>
<FONT COLOR="#000077"><B>NOTE:</B></FONT><B> </B>Buy it or write it? One question
	that you will confront throughout the design phase of your program is which routines
	might you buy and which must you write yourself. It is entirely possible that you
	can take advantage of existing commercial libraries to solve some or all of your
	communications issues. Licensing fees and other non-technical concerns must also
	be resolved. It is often advantageous to purchase such a library, and to focus your
	energies on your specific program, rather than to &quot;reinvent the wheel&quot;
	about secondary technical issues. You might even want to consider purchasing libraries
	that were not necessarily intended for use with C++, if they can provide fundamental
	functionality you'd otherwise have to engineer yourself. This can be instrumental
	in helping you hit your deadlines. 
<HR>


</BLOCKQUOTE>

<H4 ALIGN="CENTER"><A NAME="Heading21"></A><FONT COLOR="#000077">Building a Prototype</FONT></H4>
<P>For a project as large as PostMaster, it is unlikely that your initial design
will be complete and perfect. It would be easy to become overwhelmed by the sheer
scale of the problem, and trying to create all the classes and to complete their
interface before writing a line of working code is a recipe for disaster.</P>
<P>There are a number of good reasons to try out your design on a prototype--a quick-and-dirty
working example of your core ideas. There are a number of different types of prototypes,
however, each meeting different needs.</P>
<P>An interface design prototype provides the chance to test the look and feel of
your product with potential users.</P>
<P>A functionality prototype might be designed that does not have the final user
interface, but allows users to try out various features, such as forwarding messages
or attaching files without worrying about the final interface.</P>
<P>Finally, an architecture prototype might be designed to give you a chance to develop
a smaller version of the program and to assess how easily your design decisions will
&quot;scale up,&quot; as the program is fleshed out.</P>
<P>It is imperative to keep your prototyping goals clear. Are you examining the user
interface, experimenting with functionality, or building a scale model of your final
product? A good architecture prototype makes a poor user interface prototype, and
vice versa.</P>
<P>It is also important to keep an eye on over-engineering the prototype, or becoming
so concerned with the investment you've made in the prototype that you are reluctant
to tear the code down and redesign as you progress.
<H4 ALIGN="CENTER"><A NAME="Heading22"></A><FONT COLOR="#000077">The 80/80 Rule</FONT></H4>
<P>A good design rule of thumb at this stage is to design for those things that 80
percent of the people want to do 80 percent of the time, and to set aside your concerns
about the remaining 20 percent. The &quot;boundary conditions&quot; will need to
be addressed sooner or later, but the core of your design should focus on the 80/80.</P>
<P>In the face of this, you might decide to start by designing the principal classes,
setting aside the need for the secondary classes. Further, when you identify multiple
classes that will have similar designs with only minor refinements, you might choose
to pick one representative class and focus on that, leaving until later the design
and implementation of its close cousins.


<BLOCKQUOTE>
	<P>
<HR>
<FONT COLOR="#000077"><B>NOTE:</B></FONT><B> </B>There is another rule, the 80/20
	rule, which states that &quot;the first 20% of your program will take 80% of your
	time to code, and the remaining 80% of your program will take the other 80% of your
	time!&quot; 
<HR>


</BLOCKQUOTE>

<H3 ALIGN="CENTER"><A NAME="Heading23"></A><FONT COLOR="#000077">Designing the PostMasterMessage
Class</FONT></H3>
<P>In keeping with these considerations, you decide to focus on <TT>PostMasterMessage</TT>.
This is the class that is most under your direct control.</P>
<P>As part of its interface, <TT>PostMasterMessage</TT> will need to talk with other
types of messages, of course. You hope to be able to work closely with the other
message providers and to get their message format specifications, but for now you
can make some smart guesses just by observing what is sent to your computer as you
use their services.</P>
<P>In any case, you know that every <TT>PostMasterMessage</TT> will have a sender,
a recipient, a date, and a subject, as well as the body of the message and perhaps
attached files. This tells you that you'll need accessor methods for each of these
attributes, as well as methods to report on the size of the attached files, the size
of the messages, and so forth.</P>
<P>Some of the services to which you will connect will use rich text--that is, text
with formatting instructions to set the font, character size, and attributes, such
as bold and italic. Other services do not support these attributes, and those that
do may or may not use their own proprietary scheme for managing rich text. Your class
will need conversion methods for turning rich text into plain ASCII, and perhaps
for turning other formats into PostMaster formats.
<H4 ALIGN="CENTER"><A NAME="Heading24"></A><FONT COLOR="#000077">Application Program
Interface</FONT></H4>
<P>An Application Program Interface (API) is a set of documentation and routines
for using a service. Many of the mail providers will give you an API so that PostMaster
mail will be able to take advantage of their more advanced features, such as rich
text and embedding files. PostMaster will also want to publish its own API so that
other providers can plan for working with PostMaster in the future.</P>
<P>Your <TT>PostMasterMessage</TT> class will want to have a well-designed public
interface, and the conversion functions will be a principal component of PostMaster's
API. Listing 18.2 illustrates what <TT>PostMasterMessage</TT>'s interface looks like
so far.</P>
<P><A NAME="Heading25"></A><FONT SIZE="4" COLOR="#000077"><B>Listing 18.2. PostMasterMessages
interface</B></FONT></P>
<PRE><FONT COLOR="#0066FF">1:     class PostMasterMessage : public MailMessage
2:     {
3:     public:
4:       PostMasterMessage();
5:       PostMasterMessage(
6:           pAddress Sender,
7:           pAddress Recipient,
8:           pString Subject,
9:           pDate creationDate);
10:
11:      // other constructors here
12:      // remember to include copy constructor
13:      // as well as constructor from storage
14:      // and constructor from wire format
15:      // Also include constructors from other formats
16:      ~PostMasterMessage();
17:      pAddress&amp; GetSender() const;
18:      void SetSender(pAddress&amp;);
19:      // other member accessors
20:
21:      // operator methods here, including operator equals
22:      // and conversion routines to turn PostMaster messages
23:      // into messages of other formats.
24:
25:    private:
26:       pAddress itsSender;
27:       pAddress itsRecipient;
28:       pString  itsSubject;
29:       pDate itsCreationDate;
30:       pDate itsLastModDate;
31:       pDate itsReceiptDate;
32:       pDate itsFirstReadDate;
33:       pDate itsLastReadDate;
<TT>34: };</TT></FONT></PRE>
<P><FONT COLOR="#000000"><B><BR>
Output: </B></FONT>None. <BR>
<FONT COLOR="#000077"><B><BR>
Analysis: </B></FONT>Class <TT>PostMasterMessage</TT> is declared to derive from
<TT>MailMessage</TT>. A number of constructors will be provided, facilitating the
creation of <TT>PostMasterMessage</TT>s from other types of mail messages.</P>
<P>A number of accessor methods are anticipated for reading and setting the various
member data, as well as operators for turning all or part of this message into other
message formats. You anticipate storing these messages to disk and reading them from
the wire, so accessor methods are needed for those purposes as well.
<H4 ALIGN="CENTER"><A NAME="Heading27"></A><FONT COLOR="#000077">Programming in Large
Groups</FONT></H4>
<P>Even this preliminary architecture is enough to indicate how the various development
groups ought to proceed. The communications group can go ahead and start work on
the communications back end, negotiating a narrow interface with the message format
group.</P>
<P>The message format group will probably lay out the general interface to the <TT>Message</TT>
classes, as was begun above, and then will turn its attention to the question of
how to write data to the disk and read it back. Once this disk interface is well
understood, they will be in a good position to negotiate the interface to the communications
layer.</P>
<P>The message editors will be tempted to create editors with an intimate knowledge
of the internals of the <TT>Message</TT> class, but this would be a bad design mistake.
They too must negotiate a very narrow interface to the <TT>Message</TT> class; message
editor objects should know very little about the internal structure of messages.
<H4 ALIGN="CENTER"><A NAME="Heading28"></A><FONT COLOR="#000077">Ongoing Design Considerations</FONT></H4>
<P>As the project continues, you will repeatedly confront this basic design issue:
In which class should you put a given set of functionality (or information)? Should
the <TT>Message</TT> class have this function, or should the <TT>Address</TT> class?
Should the editor store this information, or should the message store it itself?</P>
<P>Your classes should operate on a &quot;need to know&quot; basis, much like secret
agents. They shouldn't share any more knowledge than is absolutely necessary.
<H3 ALIGN="CENTER"><A NAME="Heading29"></A><FONT COLOR="#000077">Design Decisions</FONT></H3>
<P>As you progress with your program, you will face hundreds of design issues. They
will range from the more global questions, &quot;What do we want this to do?&quot;
to the more specific, &quot;How do we make this work?&quot;</P>
<P>While the details of your implementation won't be finalized until you ship the
code, and some of the interfaces will continue to shift and change as you work, you
must ensure that your design is well understood early in the process. It is imperative
that you know what you are trying to build before you write the code. The single
most frequent cause of software dying on the vine must be that there was not sufficient
agreement early enough in the process about what was being built.
<H4 ALIGN="CENTER"><A NAME="Heading30"></A><FONT COLOR="#000077">Decisions, Decisions</FONT></H4>
<P>To get a feel for what the design process is like, examine this question, &quot;What
will be on the menu?&quot; For PostMaster, the first choice is probably &quot;new
mail message,&quot; and this immediately raises another design issue: When the user
presses <TT>New Message</TT>, what happens? Does an editor get created, which in
turn creates a mail message, or does a new mail message get created, which then creates
the editor?</P>
<P>The command you are working with is &quot;new mail message,&quot; so creating
a new mail message seems like the obvious thing to do. But what happens if the user
hits Cancel after starting to write the message? Perhaps it would be cleaner to first
create the editor and have it create (and own) the new message.</P>
<P>The problem with this approach is that the editor will need to act differently
if it is creating a message than if it is editing the message, whereas if the message
is created first and then handed to the editor, only one set of code need exist:
Everything is an edit of an existing message.</P>
<P>If a message is created first, who creates it? Is it created by the menu command
code? If so, does the menu also tell the message to edit itself, or is this part
of the constructor method of the message?</P>
<P>It makes sense for the constructor to do this at first glance; after all, every
time you create a message you'll probably want to edit it. Nonetheless, this is not
a good design idea. First, it is very possible that the premise is wrong: You may
well create &quot;canned&quot; messages (that is, error messages mailed to the system
operator) that are not put into an editor. Second, and more important, a constructor's
job is to create an object; it should do no more and no less than that. Once a mail
message is created, the constructor's job is done; adding a call to the edit method
just confuses the role of the constructor and makes the mail message vulnerable to
failures in the editor.</P>
<P>What is worse, the edit method will call another class, the editor, causing its
constructor to be called. Yet the editor is not a base class of the message, nor
is it contained within the message; it would be unfortunate if the construction of
the message depended on successful construction of the editor.</P>
<P>Finally, you won't want to call the editor at all if the message can't be successfully
created; yet successful creation would, in this scenario, depend on calling the editor!
Clearly you want to fully return from the message's constructor before calling <TT>Message::Edit()</TT>.


<BLOCKQUOTE>
	<P>
<HR>
<B>DO </B>look for objects that arise naturally out of your design.<B> DO</B> redesign
	as your understanding of the problem space improves.<B> DON'T</B> share more information
	among the classes than is absolutely necessary. <B>DO</B> look for opportunities
	to take advantage of C++'s polymorphism. 
<HR>


</BLOCKQUOTE>

<H3 ALIGN="CENTER"><A NAME="Heading31"></A><FONT COLOR="#000077">Working with Driver
Programs</FONT></H3>
<P>One approach to surfacing design issues is to create a driver program early in
the process. For example, the driver program for PostMaster might offer a very simple
menu, which will create <TT>PostMasterMessage</TT> objects, manipulate them, and
otherwise exercise some of the design.</P>

<DL>
	<DD>
<HR>
<FONT COLOR="#000077"><B>New Term:</B></FONT><B> </B>A <I>driver program</I> is a
	function that exists only to demonstrate or test other functions. 
<HR>

</DL>

<P>Listing 18.3 illustrates a somewhat more robust definition of the <TT>PostMasterMessage</TT>
class and a simple driver program.</P>
<P><A NAME="Heading32"></A><FONT SIZE="4" COLOR="#000077"><B>Listing 18.3. A driver
program for PostMasterMessage.</B></FONT></P>
<PRE><FONT COLOR="#0066FF">1:     #include &lt;iostream.h&gt;
2:     #include &lt;string.h&gt;
3:
4:     typedef unsigned long pDate;
5:     enum SERVICE 
6:       { PostMaster, Interchange, CompuServe, Prodigy, AOL, Internet };
7:     class String
8:     {
9:        public:
10:          // constructors
11:          String();
12:           String(const char *const);
13:           String(const String &amp;);
14:          ~String();
15:
16:          // overloaded operators
17:          char &amp; operator[](int offset);
18:          char operator[](int offset) const;
19:          String operator+(const String&amp;);
20:          void operator+=(const String&amp;);
21:          String &amp; operator= (const String &amp;);
22:          friend ostream&amp; operator&lt;&lt;
23:             ( ostream&amp; theStream,String&amp; theString);
24:          // General accessors
25:          int GetLen()const { return itsLen; }
26:          const char * GetString() const { return itsString; }
27:          // static int ConstructorCount;
28:       private:
29:          String (int);         // private constructor
30:          char * itsString;
31:          unsigned short itsLen;
32:
33:    };
34:
35:    // default constructor creates string of 0 bytes
36:    String::String()
37:    {
38:       itsString = new char[1];
39:       itsString[0] = `\0';
40:       itsLen=0;
41:       // cout &lt;&lt; &quot;\tDefault string constructor\n&quot;;
42:       // ConstructorCount++;
43:    }
44:
45:    // private (helper) constructor, used only by
46:    // class methods for creating a new string of
47:    // required size.  Null filled.
48:    String::String(int len)
49:    {
50:       itsString = new char[len+1];
51:       for (int i = 0; i&lt;=len; i++)
52:          itsString[1] = `\0';
53:       itsLen=len;
54:       // cout &lt;&lt; &quot;\tString(int) constructor\n&quot;;
55:       // ConstructorCount++;
56:    }
57:
58:    // Converts a character array to a String
59:    String::String(const char * const cString)
60:    {
61:       itsLen = strlen(cString);
62:       itsString = new char[itsLen+1];
63:       for (int i = 0; i&lt;itsLen; i++)
64:          itsString[i] = cString[i];
65:       itsString[itsLen]='\0';
66:       // cout &lt;&lt; &quot;\tString(char*) constructor\n&quot;;
67:       // ConstructorCount++;
68:    }
69:
70:    // copy constructor
71:    String::String (const String &amp; rhs)
72:    {
73:       itsLen=rhs.GetLen();
74:       itsString = new char[itsLen+1];
75:       for (int i = 0; i&lt;itsLen;i++)
76:          itsString[i] = rhs[i];
77:       itsString[itsLen] = `\0';
78:       // cout &lt;&lt; &quot;\tString(String&amp;) constructor\n&quot;;
79:       // ConstructorCount++;
80:    }
81:
82:    // destructor, frees allocated memory
83:    String::~String ()
84:    {
85:       delete [] itsString;
86:       itsLen = 0;
87:       // cout &lt;&lt; &quot;\tString destructor\n&quot;;
88:    }
89:
90:    // operator equals, frees existing memory
91:    // then copies string and size
92:    String&amp; String::operator=(const String &amp; rhs)
93:    {
94:       if (this == &amp;rhs)
95:          return *this;
96:       delete [] itsString;
97:       itsLen=rhs.GetLen();
98:       itsString = new char[itsLen+1];
99:       for (int i = 0; i&lt;itsLen;i++)
100:         itsString[i] = rhs[i];
101:      itsString[itsLen] = `\0';
102:      return *this;
103:      // cout &lt;&lt; &quot;\tString operator=\n&quot;;
104:   }
105:
106:   //non constant offset operator, returns
107:   // reference to character so it can be
108:   // changed!
109:   char &amp; String::operator[](int offset)
110:   {
111:      if (offset &gt; itsLen)
112:         return itsString[itsLen-1];
113:      else
114:         return itsString[offset];
115:   }
116:
117:   // constant offset operator for use
118:   // on const objects (see copy constructor!)
119:   char String::operator[](int offset) const
120:   {
121:      if (offset &gt; itsLen)
122:         return itsString[itsLen-1];
123:      else
124:         return itsString[offset];
125:   }
126:
127:   // creates a new string by adding current
128:   // string to rhs
129:   String String::operator+(const String&amp; rhs)
130:   {
131:      int  totalLen = itsLen + rhs.GetLen();
132:      int i,j;
133:      String temp(totalLen);
134:      for ( i = 0; i&lt;itsLen; i++)
135:         temp[i] = itsString[i];
136:      for ( j = 0; j&lt;rhs.GetLen(); j++, i++)
137:         temp[i] = rhs[j];
138:      temp[totalLen]='\0';
139:      return temp;
140:   }
141:   
142:   void String::operator+=(const String&amp; rhs)
143:   {
144:      unsigned short rhsLen = rhs.GetLen();
145:      unsigned short totalLen = itsLen + rhsLen;
146:      String  temp(totalLen);
147:      for (int i = 0; i&lt;itsLen; i++)
148:         temp[i] = itsString[i];
149:      for (int j = 0; j&lt;rhs.GetLen(); j++, i++)
150:         temp[i] = rhs[i-itsLen];
151:      temp[totalLen]='\0';
152:      *this = temp;
153:   }
154:
155:   // int String::ConstructorCount = 0;
156:
157:   ostream&amp; operator&lt;&lt;( ostream&amp; theStream,String&amp; theString)
158:   {
159:       theStream &lt;&lt; theString.GetString();
160:       return theStream;
161:   }
162:
163:   class pAddress
164:   {
165:   public:
166:      pAddress(SERVICE theService,
167:               const String&amp; theAddress,
168:               const String&amp; theDisplay):
169:         itsService(theService),
170:         itsAddressString(theAddress),
171:         itsDisplayString(theDisplay)
172:         {}
173:      // pAddress(String, String);
174:      // pAddress();
175:      // pAddress (const pAddress&amp;);
176:      ~pAddress(){}
177:      friend ostream&amp; operator&lt;&lt;( ostream&amp; theStream, pAddress&amp; theAddress);
178:      String&amp; GetDisplayString() { return itsDisplayString; }
179:   private:
180:      SERVICE itsService;
181:      String itsAddressString;
182:      String itsDisplayString;
183:   };
184:
185:   ostream&amp; operator&lt;&lt;( ostream&amp; theStream, pAddress&amp; theAddress)
186:   {
187:       theStream &lt;&lt; theAddress.GetDisplayString();
188:       return theStream;
189:   }
190:
191:   class PostMasterMessage
192:   {
193:   public:
194:     // PostMasterMessage();
195:
196:     PostMasterMessage(const pAddress&amp; Sender,
197:                     const pAddress&amp; Recipient,
198:                     const String&amp; Subject,
199:                     const pDate&amp; creationDate);
200:
201:     // other constructors here
202:     // remember to include copy constructor
203:     // as well as constructor from storage
204:     // and constructor from wire format
205:     // Also include constructors from other formats
206:     ~PostMasterMessage(){}
207:
208:     void Edit(); // invokes editor on this message
209:
210:     pAddress&amp; GetSender() const { return itsSender; }
211:     pAddress&amp; GetRecipient() const { return itsRecipient; }
212:     String&amp; GetSubject() const { return itsSubject; }
213:     //  void SetSender(pAddress&amp; );
214:     // other member accessors
215:
216:     // operator methods here, including operator equals
217:     // and conversion routines to turn PostMaster messages
218:     // into messages of other formats.
219:
220:   private:
221:      pAddress itsSender;
222:      pAddress itsRecipient;
223:      String  itsSubject;
224:      pDate itsCreationDate;
225:      pDate itsLastModDate;
226:      pDate itsReceiptDate;
227:      pDate itsFirstReadDate;
228:      pDate itsLastReadDate;
229:   };
230:
231:   PostMasterMessage::PostMasterMessage(
232:         const pAddress&amp; Sender,
233:         const pAddress&amp; Recipient,
234:         const String&amp; Subject,
235:         const pDate&amp; creationDate):
236:         itsSender(Sender),
237:         itsRecipient(Recipient),
238:         itsSubject(Subject),
239:         itsCreationDate(creationDate),
240:         itsLastModDate(creationDate),
241:         itsFirstReadDate(0),
242:         itsLastReadDate(0)
243:     {
244:       cout &lt;&lt; &quot;Post Master Message created. \n&quot;;
245:     }
246:
247:     void PostMasterMessage::Edit()
248:      {
249:         cout &lt;&lt; &quot;PostMasterMessage edit function called\n&quot;;
250:      }
251:
252:
253:   int main()
254:   {
255:      pAddress Sender(PostMaster, &quot;jliberty@PostMaster&quot;, &quot;Jesse Liberty&quot;);
256:      pAddress Recipient(PostMaster, &quot;sl@PostMaster&quot;,&quot;Stacey Liberty&quot;);
257:      PostMasterMessage PostMessage(Sender, Recipient, &quot;Saying Hello&quot;, 0);
258:      cout &lt;&lt; &quot;Message review... \n&quot;;
259:      cout &lt;&lt; &quot;From:\t\t&quot; &lt;&lt; PostMessage.GetSender() &lt;&lt; endl;
260:      cout &lt;&lt; &quot;To:\t\t&quot; &lt;&lt; PostMessage.GetRecipient() &lt;&lt; endl;
261:      cout &lt;&lt; &quot;Subject:\t&quot; &lt;&lt; PostMessage.GetSubject() &lt;&lt; endl;
262:     return 0;
<TT>263: }</TT></FONT></PRE>


<BLOCKQUOTE>
	<P>
<HR>
<FONT COLOR="#000077"><B>WARNING:</B></FONT><B> </B>If you receive a &quot;can't
	convert&quot; error, remove the <TT>const</TT> keywords from lines 210-212. 
<HR>


</BLOCKQUOTE>

<PRE><FONT COLOR="#0066FF">Output: Post Master Message created.
Message review...
From:           Jesse Liberty
To:             Stacey Liberty
Subject:        Saying Hello
</FONT></PRE>
<P><FONT COLOR="#000077"><B>Analysis: </B></FONT>On line 4, <TT>pDate</TT> is type-defined
to be an <TT>unsigned long</TT>. It is not uncommon for dates to be stored as a <TT>long</TT>
integer (typically as the number of seconds since an arbitrary starting date such
as <TT>January 1, 1900</TT>). In this program, this is a placeholder; you would expect
to eventually turn <TT>pDate</TT> into a real class.<BR>
<BR>
On line 5, an enumerated constant, <TT>SERVICE</TT>, is defined to allow the <TT>Address</TT>
objects to keep track of what type of address they are, including PostMaster, CompuServe,
and so forth.</P>
<P>Lines 7-161 represent the interface to and implementation of <TT>String</TT>,
along much the same lines as you have seen in previous chapters. The <TT>String</TT>
class is used for a number of member variables in all of the <TT>Message</TT> classes
and various other classes used by messages, and as such it is pivotal in your program.
A full and robust <TT>String</TT> class will be essential to making your <TT>Message</TT>
classes complete.</P>
<P>On lines 162-183, the <TT>pAddress</TT> class is declared. This represents only
the fundamental functionality of this class, and you would expect to flesh this out
once your program is better understood. These objects represent essential components
in every message: both the sender's address and that of the recipient. A fully functional
<TT>pAddress</TT> object will be able to handle forwarding messages, replies, and
so forth.</P>
<P>It is the <TT>pAddress</TT> object's job to keep track of the display string as
well as the internal routing string for its service. One open question for your design
is whether there should be one <TT>pAddress</TT> object or if this should be subclassed
for each service type. For now, the service is tracked as an enumerated constant,
which is a member variable of each <TT>pAddress</TT> object.</P>
<P>Lines 191-229 show the interface to the <TT>PostMasterMessage</TT> class. In this
particular listing, this class stands on its own, but very soon you'll want to make
this part of its inheritance hierarchy. When you do redesign this to inherit from
<TT>Message</TT>, some of the member variables may move into the base classes, and
some of the member functions may become overrides of base class methods.</P>
<P>A variety of other constructors, accessor functions, and other member functions
will be required to make this class fully functional. Note that what this listing
illustrates is that your class does not have to be 100 percent complete before you
can write a simple driver program to test some of your assumptions.</P>
<P>On lines 247-250, the <TT>Edit()</TT> function is &quot;stubbed out&quot; in just
enough detail to indicate where the editing functionality will be put once this class
is fully operational.</P>
<P>Lines 253-263 represent the driver program. Currently this program does nothing
more than exercise a few of the accessor functions and the <TT>operator&lt;&lt;</TT>
overload. Nonetheless, this gives you the starting point for experimenting with <TT>PostMasterMessage</TT>s
and a framework within which you can modify these classes and examine the impact.
<H3 ALIGN="CENTER"><A NAME="Heading34"></A><FONT COLOR="#000077">Summary</FONT></H3>
<P>Today you saw a review of how to bring together many of the elements of C++ syntax
and apply them to object-oriented analysis, design, and programming. The development
cycle is not a linear progression from clean analysis through design and culminating
in programming; rather, it is cyclical. The first phase is typically analysis of
the problem, with the results of that analysis forming the basis for the preliminary
design.</P>
<P>Once a preliminary design is complete, programming can begin, but the lessons
learned during the programming phase are fed back into the analysis and design. As
programming progresses, testing and then debugging begins. The cycle continues, never
really ending; although discrete points are reached, at which time it is appropriate
to ship the product.</P>
<P>When analyzing a large problem from an object-oriented viewpoint, the interacting
parts of the problem are often the objects of the preliminary design. The designer
keeps an eye out for process, hoping to encapsulate discrete activities into objects
whenever possible.</P>
<P>A class hierarchy must be designed, and fundamental relationships among the interacting
parts must be established. The preliminary design is not meant to be final, and functionality
will migrate among objects as the design solidifies.</P>
<P>It is a principal goal of object-oriented analysis to hide as much of the data
and implementation as possible and to build discrete objects that have a narrow and
well-defined interface. The clients of your object should not need to understand
the implementation details of how they fulfill their responsibilities.
<H3 ALIGN="CENTER"><A NAME="Heading35"></A><FONT COLOR="#000077">Q&amp;A</FONT></H3>

<DL>
	<DD><B>Q. In what way is object-oriented analysis and design fundamentally different
	from other approaches?<BR>
	<BR>
	A.</B> Prior to the development of these object-oriented techniques, analysts and
	programmers tended to think of programs as functions that acted on data. Object-oriented
	programming focuses on the integrated data and functionality as discrete units that
	have both knowledge (data) and capabilities (functions). Procedural programs, on
	the other hand, focus on functions and how they act on data. It has been said that
	Pascal and C programs are collections of procedures and C++ programs are collections
	of classes.<BR>
	<BR>
	<B>Q. Is object-oriented programming finally the silver bullet that will solve all
	programming problems?<BR>
	</B><BR>
	<B>A.</B> No, it was never intended to be. For large, complex problems, however,
	object-oriented analysis, design, and programming can provide the programmer with
	tools to manage enormous complexity in ways that were previously impossible.<BR>
	<BR>
	<B>Q. Is C++ the perfect object-oriented language?<BR>
	</B><BR>
	<B>A.</B> C++ has a number of advantages and disadvantages when compared with alternative
	object-oriented programming languages, but it has one killer advantage above and
	beyond all others: It is the single most popular object-oriented programming language
	on the face of the Earth. Frankly, most programmers don't decide to program in C++
	after an exhaustive analysis of the alternative object-oriented programming languages;
	they go where the action is, and in the 1990s the action is with C++. There are good
	reasons for that; C++ has a lot to offer, but this book exists, and I'd wager you
	are reading it, because C++ is the development language of choice at so many corporations.<BR>
	<BR>
	<B>Q. Where can I learn more about object-oriented analysis and design?<BR>
	</B><BR>
	<B>A.</B> Day 21 offers some further suggestions, but it is my personal opinion that
	there are a number of terrific object-oriented analysis and design books available.
	My personal favorites include:<BR>
	Object-Oriented Analysis and Design with Applications by Grady Booch (2nd Edition).
	Published by Benjamin/Cummings Publishing Company, Inc., ISBN: 0-8053-5340-2.<BR>
	Object-Oriented Modeling and Design by Rumbaugh, Blaha, Premerlani, Eddy, and Lorenson.
	Published by Prentice-Hall, ISBN 0-13-629841-9.<BR>
	There are many other excellent alternatives. Also be sure to join one of the newsgroups
	or conferences on the Internet, Interchange, or one of the alternative dial-up services.
</DL>

<H3 ALIGN="CENTER"><A NAME="Heading36"></A><FONT COLOR="#000077">Workshop</FONT></H3>
<P>The Workshop provides quiz questions to help you solidify your understanding of
the material covered and exercises to provide you with experience in using what you've
learned. Try to answer the quiz and exercise questions before checking the answers
in Appendix D, and make sure you understand the answers before continuing to the
next chapter.
<H4 ALIGN="CENTER"><A NAME="Heading37"></A><FONT COLOR="#000077">Quiz</FONT></H4>

<DL>
	<DD><B>1.</B> What is the difference between object-oriented programming and procedural
	programming?<BR>
	<BR>
	<B>2.</B> To what does &quot;event-driven&quot; refer?<BR>
	<BR>
	<B>3.</B> What are the stages in the development cycle?<BR>
	<BR>
	<B>4.</B> What is a rooted hierarchy?<BR>
	<BR>
	<B>5.</B> What is a driver program?<TT><BR>
	<BR>
	<B>6.</B> W</TT>hat is encapsulation?
</DL>

<H4 ALIGN="CENTER"><A NAME="Heading38"></A><FONT COLOR="#000077">Exercises</FONT></H4>

<DL>
	<DD><B>1.</B> Suppose you had to simulate the intersection of Massachusetts Avenue
	and Vassar Street--two typical two-lane roads, with traffic lights and crosswalks.
	The purpose of the simulation is to determine if the timing of the traffic signal
	allows for a smooth flow of traffic.<BR>
	What kinds of objects should be modeled in the simulation? What would the classes
	be for the simulation?<BR>
	<BR>
	<B>2.</B> Suppose the intersection from Exercise 1 were in a suburb of Boston, which
	has arguably the unfriendliest streets in the United States. At any time there are
	three kinds of Boston drivers:<BR>
	Locals, who continue to drive through intersections after the light turns red; tourists,
	who drive slowly and cautiously (in a rental car, typically); and taxis, who have
	a wide variation of driving patterns, depending on the kinds of passengers in the
	cabs.<BR>
	Also, Boston has two kinds of pedestrians: locals, who cross the street whenever
	they feel like it and seldom use the crosswalk buttons; and tourists, who always
	use the crosswalk buttons and only cross when the Walk/Don't Walk light permits.<BR>
	Finally, Boston has bicyclists who never pay attention to stop lights.<BR>
	How do these considerations change the model?<BR>
	<BR>
	<B>3. </B>You are asked to design a group scheduler. The software allows you to arrange
	meetings among individuals or groups and to reserve a limited number of conference
	rooms. Identify the principal subsystems.<BR>
	<BR>
	<B>4. </B>Design and show the interfaces to the classes in the room reservation portion
	of the program discussed in Exercise 3.
</DL>

<P ALIGN="CENTER"><A HREF="ch17.htm"><IMG SRC="../buttons/BLANPREV.GIF"
WIDTH="37" HEIGHT="37" ALIGN="BOTTOM" BORDER="0"></A><A HREF="http://www.mcp.com/sams"><IMG
SRC="../buttons/BLANHOME.GIF" WIDTH="37" HEIGHT="37" ALIGN="BOTTOM"
BORDER="0"></A><A HREF="../index.htm"><IMG SRC="../buttons/BLANTOC.GIF"
WIDTH="37" HEIGHT="37" ALIGN="BOTTOM" BORDER="0"></A><A HREF="ch19.htm"><IMG SRC="../buttons/BLANNEXT.GIF"
WIDTH="37" HEIGHT="37" ALIGN="BOTTOM" BORDER="0"></A><A HREF="#heading1"><IMG SRC="../buttons/BLANTOP.GIF"
WIDTH="37" HEIGHT="37" ALIGN="BOTTOM" BORDER="0"></A>


</BODY>

</HTML>