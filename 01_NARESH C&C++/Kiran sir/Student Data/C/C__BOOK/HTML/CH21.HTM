<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>

<HEAD>
<!-- This document was created from RTF source by rtftohtml version 3.0.1 -->

	<META NAME="GENERATOR" Content="Symantec Visual Page 1.0">
	<META HTTP-EQUIV="Content-Type" CONTENT="text/html;CHARSET=iso-8859-1">
	<TITLE>Teach Yourself C++ in 21 Days</TITLE>
</HEAD>

<BODY TEXT="#000000" BGCOLOR="#FFFFFF">

<H1 ALIGN="CENTER"><A HREF="ch20.htm"><IMG SRC="../buttons/BLANPREV.GIF"
WIDTH="37" HEIGHT="37" ALIGN="BOTTOM" BORDER="0"></A><A HREF="http://www.mcp.com/sams"><IMG
SRC="../buttons/BLANHOME.GIF" WIDTH="37" HEIGHT="37" ALIGN="BOTTOM"
BORDER="0"></A><A HREF="../index.htm"><IMG SRC="../buttons/BLANTOC.GIF"
WIDTH="37" HEIGHT="37" ALIGN="BOTTOM" BORDER="0"></A><A HREF="ch21rv3.htm"><IMG SRC="../buttons/BLANNEXT.GIF"
WIDTH="37" HEIGHT="37" ALIGN="BOTTOM" BORDER="0"></A></H1>
<H1></H1>

<UL>
	<LI><A HREF="#Heading1">Day 21</A>
	<UL>
		<LI><A HREF="#Heading2">Whats Next</A>
		<UL>
			<LI><A HREF="#Heading3">The Standard Libraries</A>
			<LI><A HREF="#Heading4">String</A>
			<LI><A HREF="#Heading5">Listing 21.1. strlen().</A>
			<UL>
				<LI><A HREF="#Heading6">strcpy() and strncpy()</A>
			</UL>
			<LI><A HREF="#Heading7">Listing 21.2. Using strcpy.</A>
			<LI><A HREF="#Heading8">Listing 21.3. Using strncpy().</A>
			<UL>
				<LI><A HREF="#Heading9">strcat() and strncat()</A>
			</UL>
			<LI><A HREF="#Heading10">Listing 21.4. Using strcat() and strncat().</A>
			<UL>
				<LI><A HREF="#Heading11">Other String Functions</A>
			</UL>
			<LI><A HREF="#Heading12">Time and Date</A>
			<LI><A HREF="#Heading13">Listing 21.5. Using ctime().</A>
			<LI><A HREF="#Heading14">stdlib</A>
			<LI><A HREF="#Heading15">Listing 21.6. Using atoi() and related functions.</A>
			<UL>
				<LI><A HREF="#Heading16">qsort()</A>
			</UL>
			<LI><A HREF="#Heading17">Listing 21.7. Using qsort().</A>
			<UL>
				<LI><A HREF="#Heading18">Other Libraries</A>
			</UL>
			<LI><A HREF="#Heading19">Bit Twiddling</A>
			<UL>
				<LI><A HREF="#Heading20">Operator AND</A>
				<LI><A HREF="#Heading21">Operator OR</A>
				<LI><A HREF="#Heading22">Operator Exclusive OR</A>
				<LI><A HREF="#Heading23">The Complement Operator</A>
				<LI><A HREF="#Heading24">Setting Bits</A>
				<LI><A HREF="#Heading25">Clearing Bits</A>
				<LI><A HREF="#Heading26">Flipping Bits</A>
				<LI><A HREF="#Heading27">Bit Fields</A>
			</UL>
			<LI><A HREF="#Heading28">Listing 21.8. Using bit fields</A><A HREF="#Heading29">.</A>
			<LI><A HREF="#Heading30">Style</A>
			<UL>
				<LI><A HREF="#Heading31">Indenting</A>
				<LI><A HREF="#Heading32">Braces</A>
				<LI><A HREF="#Heading33">Long Lines</A>
				<LI><A HREF="#Heading34">switch Statements</A>
				<LI><A HREF="#Heading35">Program Text</A>
				<LI><A HREF="#Heading36">Identifier Names</A>
				<LI><A HREF="#Heading37">Spelling and Capitalization of Names</A>
				<LI><A HREF="#Heading38">Comments</A>
				<LI><A HREF="#Heading39">Access</A>
				<LI><A HREF="#Heading40">Class Definitions</A>
				<LI><A HREF="#Heading41">include Files</A>
				<LI><A HREF="#Heading42">assert()</A>
				<LI><A HREF="#Heading43">const</A>
			</UL>
			<LI><A HREF="#Heading44">Next Steps</A>
			<UL>
				<LI><A HREF="#Heading45">Where to Get Help and Advice</A>
				<LI><A HREF="#Heading46">Required Reading</A>
				<LI><A HREF="#Heading47">Magazines</A>
				<LI><A HREF="#Heading48">Staying in Touch</A>
			</UL>
			<LI><A HREF="#Heading49">Summary</A>
			<LI><A HREF="#Heading50">Q&amp;A</A>
			<UL>
				<LI><A HREF="#Heading51">Quiz</A>
				<LI><A HREF="#Heading52">Exercises</A>
			</UL>
		</UL>
	</UL>
</UL>

<P>
<HR SIZE="4">

<H2 ALIGN="CENTER"><A NAME="Heading1"></A><FONT COLOR="#000077">Day 21</FONT></H2>

<H2 ALIGN="CENTER"><A NAME="Heading2"></A><FONT COLOR="#000077">Whats Next</FONT></H2>
<P>Congratulations! You are nearly done with a full three-week intensive introduction
to C++. By now you should have a solid understanding of C++, but in modern programming
there is always more to learn. This chapter will fill in some missing details and
then set the course for continued study.</P>
<P>Today you will learn

<UL>
	<LI>What the standard libraries are.
	<P>
	<LI>How to manipulate individual bits and use them as flags.
	<P>
	<LI>What the next steps are in learning to use C++ effectively.
</UL>

<H3 ALIGN="CENTER"><A NAME="Heading3"></A><FONT COLOR="#000077">The Standard Libraries</FONT></H3>
<P>Every implementation of C++ includes the standard libraries, and most include
additional libraries as well. Libraries are sets of functions that can be linked
into your code. You've already used a number of standard library functions and classes,
most notably from the <TT>iostreams</TT> library.</P>
<P>To use a library, you typically include a header file in your source code, much
as you did by writing <TT>#include &lt;iostream.h&gt;</TT> in many of the examples
in this book. The angle brackets around the filename are a signal to the compiler
to look in the directory where you keep the header files for your compiler's standard
libraries.</P>
<P>There are dozens of libraries, covering everything from file manipulation to setting
the date and time to math functions. Today I will review just a few of the most popular
functions and classes in the standard library that have not yet been covered in this
book.
<H3 ALIGN="CENTER"><A NAME="Heading4"></A><FONT COLOR="#000077">String</FONT></H3>
<P>The most popular library is almost certainly the string library, with perhaps
the function <TT>strlen()</TT> called most often. <TT>strlen()</TT> returns the length
of a null-terminated string. Listing 21.1 illustrates its use.</P>

<P><A NAME="Heading5"></A><FONT SIZE="4" COLOR="#000077"><B>Listing 21.1. strlen().</B></FONT>
<PRE><FONT COLOR="#0066FF">1:     #include &lt;iostream.h&gt;
2:     #include &lt;string.h&gt;
3:
4:     int main()
5:     {
6:        char buffer80];
7:        do
8:        {
9:           cout &lt;&lt; &quot;Enter a string up to 80 characters: &quot;;
10:          cin.getline(buffer,80);
11:          cout &lt;&lt; &quot;Your string is &quot; &lt;&lt; strlen(buffer);
12:          cout &lt;&lt; &quot; characters long.&quot; &lt;&lt; endl;
13:       }    while (strlen(buffer));
14:       cout &lt;&lt; &quot;\nDone.&quot; &lt;&lt; endl;
15:     return 0;
<TT>16: }</TT></FONT>
<FONT COLOR="#0066FF">
Output: Enter a string up to 80 characters: This sentence has 31 characters
Your string is 31 characters long.
Enter a string up to 80 characters: This sentence no verb
Your string is 21 characters long.
Enter a string up to 80 characters:
Your string is 0 characters long.

Done.
</FONT></PRE>
<P><FONT COLOR="#000077"><B>Analysis: </B></FONT>On line 6, a character buffer is
created, and on line 9 the user is prompted to enter a string. As long as the user
enters a string, the length of the string is reported on line 11.<BR>
<BR>
Note the test in the <TT>do...while()</TT> statement: <TT>while (strlen(buffer))</TT>.
Since <TT>strlen()</TT> will return <TT>0</TT> when the buffer is empty, and since
<TT>0</TT> evaluates <TT>FALSE</TT>, this <TT>while</TT> loop will continue as long
as there are any characters in the buffer.
<H4 ALIGN="CENTER"><A NAME="Heading6"></A><FONT COLOR="#000077">strcpy() and strncpy()</FONT></H4>
<P>The second most popular function in <TT>string.h</TT> probably was <TT>strcpy()</TT>,
which copied one string to another. This may now be diminished somewhat as C-style
null-terminated strings have become less important in C++; typically, string manipulation
is done from within a vendor-supplied or user-written <TT>string</TT> class. Nonetheless,
your <TT>string</TT> class must support an assignment operator and a copy constructor,
and often these are implemented using <TT>strcpy()</TT>, as illustrated in Listing
21.2.</P>

<P><A NAME="Heading7"></A><FONT SIZE="4" COLOR="#000077"><B>Listing 21.2. Using strcpy.</B></FONT>
<PRE><FONT COLOR="#0066FF">1:     #include &lt;iostream.h&gt;
2:     #include &lt;string.h&gt;
3:
4:     int main()
5:     {
6:        char stringOne80];
7:        char stringTwo80];
8:
9:        stringOne0]='\0';
10:       stringTwo0]='\0';
11:
12:       cout &lt;&lt; &quot;String One: &quot; &lt;&lt; stringOne &lt;&lt; endl;
13:       cout &lt;&lt; &quot;String Two: &quot; &lt;&lt; stringTwo &lt;&lt; endl;
14:
15:       cout &lt;&lt; &quot;Enter a string: &quot;;
16:       cin.getline(stringOne,80);
17:
18:       cout &lt;&lt; &quot;\nString One: &quot; &lt;&lt; stringOne &lt;&lt; endl;
19:       cout &lt;&lt; &quot;String Two: &quot; &lt;&lt; stringTwo &lt;&lt; endl;
20:
21:       cout &lt;&lt; &quot;copying...&quot; &lt;&lt; endl;
22:       strcpy(stringTwo,stringOne);
23:
24:       cout &lt;&lt; &quot;\nString One: &quot; &lt;&lt; stringOne &lt;&lt; endl;
25:       cout &lt;&lt; &quot;String Two: &quot; &lt;&lt; stringTwo &lt;&lt; endl;
26:       cout &lt;&lt; &quot;\nDone &quot; &lt;&lt; endl;
27:     return 0;
<TT>28: }</TT></FONT>
<FONT COLOR="#0066FF">
Output: String One:
String Two:
Enter a string: Test of strcpy()

String One:  Test of strcpy()
String Two:
copying...

String One:  Test of strcpy()
String Two:  Test of strcpy()

Done</FONT></PRE>
<P><FONT COLOR="#000077"><B>Analysis: </B></FONT>Two C-style null-terminated strings
are declared on lines 6 and 7. They are initialized to empty on lines 9 and 10, and
their values are printed on lines 12 and 13. The user is prompted to enter a string,
and the result is put in <TT>stringOne</TT>; the two strings are printed again, and
only <TT>stringOne</TT> has the input. <TT>Strcpy()</TT> is then called, and <TT>stringOne</TT>
is copied into <TT>stringTwo</TT>.<BR>
<BR>
Note that the syntax of <TT>strcpy()</TT> can be read as &quot;copy into the first
parameter the string in the second parameter.&quot; What happens if the target string
(<TT>stringTwo</TT>) is too small to hold the copied string? This problem and its
solution are illustrated in Listing 21.3.</P>

<P><A NAME="Heading8"></A><FONT SIZE="4" COLOR="#000077"><B>Listing 21.3. Using strncpy().</B></FONT>
<PRE><FONT COLOR="#0066FF">1:     #include &lt;iostream.h&gt;
2:     #include &lt;string.h&gt;
3:
4:     int main()
5:     {
6:        char stringOne[80];
7:        char stringTwo[10];
8:        char stringThree[80];
9:
10:       stringOne[0]='\0';
11:       stringTwo[0]='\0';
12:       stringThree[0]='\0';
13:
14:       cout &lt;&lt; &quot;String One: &quot; &lt;&lt; stringOne &lt;&lt; endl;
15:       cout &lt;&lt; &quot;String Two: &quot; &lt;&lt; stringTwo &lt;&lt; endl;
16:       cout &lt;&lt; &quot;String Three: &quot; &lt;&lt; stringThree &lt;&lt; endl;
17:
18:       cout &lt;&lt; &quot;Enter a long string: &quot;;
19:       cin.getline(stringOne,80);
20:       strcpy(stringThree,stringOne);
21:      //   strcpy(stringTwo,stringOne);
22:
23:       cout &lt;&lt; &quot;\nString One: &quot; &lt;&lt; stringOne &lt;&lt; endl;
24:       cout &lt;&lt; &quot;String Two: &quot; &lt;&lt; stringTwo &lt;&lt; endl;
25:       cout &lt;&lt; &quot;String Three: &quot; &lt;&lt; stringThree &lt;&lt; endl;
26:
27:       strncpy(stringTwo,stringOne,9);
28:
29:       cout &lt;&lt; &quot;\nString One: &quot; &lt;&lt; stringOne &lt;&lt; endl;
30:       cout &lt;&lt; &quot;String Two: &quot; &lt;&lt; stringTwo &lt;&lt; endl;
31:       cout &lt;&lt; &quot;String Three: &quot; &lt;&lt; stringThree &lt;&lt; endl;
32:
33:       stringTwo[9]='\0';
34:
35:       cout &lt;&lt; &quot;\nString One: &quot; &lt;&lt; stringOne &lt;&lt; endl;
36:       cout &lt;&lt; &quot;String Two: &quot; &lt;&lt; stringTwo &lt;&lt; endl;
37:       cout &lt;&lt; &quot;String Three: &quot; &lt;&lt; stringThree &lt;&lt; endl;
38:       cout &lt;&lt; &quot;\nDone.&quot; &lt;&lt; endl;
39:     return 0;
<TT>40: }</TT></FONT>
<FONT COLOR="#0066FF">
Output: String One:
String Two:
String Three:
Enter a long string: Now is the time for all...

String One: Now is the time for all...
String Two:
String Three: Now is the time for all...

String One: Now is the time for all...
String Two: Now is th_+||
String Three: Now is the time for all...

String One: Now is the time for all...
String Two: Now is th
String Three: Now is the time for all...

Done.
</FONT></PRE>
<P><FONT COLOR="#000077"><B>Analysis:</B></FONT><B> </B>On lines 6, 7, and 8, three
string buffers are declared. Note that <TT>stringTwo</TT> is declared to be only
10 characters, while the others are 80. All three are initialized to zero length
on lines 10 to 12 and are printed on lines 14 to 16.<BR>
<BR>
The user is prompted to enter a string, and that string is copied to string three
on line 20. Line 21 is commented out; copying this long string to <TT>stringTwo</TT>
caused a crash on my computer because it wrote into memory that was critical to the
program.</P>
<P>The standard function <TT>strcpy()</TT> starts copying at the address pointed
to by the first parameter (the array name), and it copies the entire string without
ensuring that you've allocated room for it!</P>
<P>The standard library offers a second, safer function, <TT>strncpy()</TT>, which
copies only a specified number of characters to the target string. The <TT>n</TT>
in the middle of the function name <TT>strncpy()</TT> stands for number. This is
a convention used throughout the standard libraries.</P>
<P>On line 27, the first nine characters of <TT>stringOne</TT> are copied to <TT>stringTwo</TT>
and the result is printed. Because <TT>strncpy()</TT> does not put a null at the
end of the copied string, the result is not what was intended. Note that <TT>strcpy()</TT>
does null-terminate the copied string, but <TT>strncpy()</TT> does not, just to keep
life interesting.</P>
<P>The null is added on line 33, and the strings are then printed a final time.
<H4 ALIGN="CENTER"><A NAME="Heading9"></A><FONT COLOR="#000077">strcat() and strncat()</FONT></H4>
<P>Related to <TT>strcpy()</TT> and <TT>strncpy()</TT> are the standard functions
<TT>strcat()</TT> and <TT>strncat()</TT>. The former concatenates one string to another;
that is, it appends the string it takes as its second parameter to the end of the
string it takes as its first parameter. <TT>strncat()</TT>, as you might expect,
appends the first <TT>n</TT> characters of one string to the other. Listing 21.4
illustrates their use.</P>

<P><A NAME="Heading10"></A><FONT SIZE="4" COLOR="#000077"><B>Listing 21.4. Using
strcat() and strncat().</B></FONT>
<PRE><FONT COLOR="#0066FF">1:     #include &lt;iostream.h&gt;
2:     #include &lt;string.h&gt;
3:
4:
5:     int main()
6:     {
7:        char stringOne[255];
8:        char stringTwo[255];
9:
10:       stringOne[0]='\0';
11:       stringTwo[0]='\0';
12:
13:       cout &lt;&lt; &quot;Enter a  string: &quot;;
14:       cin.getline(stringOne,80);
15:
16:       cout &lt;&lt; &quot;Enter a second string: &quot;;
17:       cin.getline(stringTwo,80);
18:
19:       cout &lt;&lt; &quot;String One: &quot; &lt;&lt; stringOne &lt;&lt; endl;
20:       cout &lt;&lt; &quot;String Two: &quot; &lt;&lt; stringTwo &lt;&lt; endl;
21:
22:       strcat(stringOne,&quot; &quot;);
23:       strncat(stringOne,stringTwo,10);
24:
25:       cout &lt;&lt; &quot;String One: &quot; &lt;&lt; stringOne &lt;&lt; endl;
26:       cout &lt;&lt; &quot;String Two: &quot; &lt;&lt; stringTwo &lt;&lt; endl;
27:
28:     return 0;
<TT>29: }</TT></FONT>
<FONT COLOR="#0066FF">
Output: Enter a string: Oh beautiful
Enter a second string: for spacious skies for amber waves of grain
String One: Oh beautiful
String Two: for spacious skies for amber waves of grain
String One: Oh beautiful for spacio
String Two: for spacious skies for amber waves of grain
</FONT></PRE>
<P><FONT COLOR="#000077"><B>Analysis:</B></FONT><B> </B>On lines 7 and 8, two character
arrays are created, and the user is prompted for two strings, which are put into
the two arrays.<BR>
<BR>
A space is appended to <TT>stringOne</TT> on line 22, and on line 23, the first ten
characters of <TT>stringTwo</TT> are appended to <TT>stringOne</TT>. The result is
printed on lines 25 and 26.
<H4 ALIGN="CENTER"><A NAME="Heading11"></A><FONT COLOR="#000077">Other String Functions</FONT></H4>
<P>The string library provides a number of other string functions, including those
used to find occurrences of various characters or &quot;tokens&quot; within a string.
If you need to find a comma or a particular word as it occurs in a string, look to
the string library to see whether the function you need already exists.
<H3 ALIGN="CENTER"><A NAME="Heading12"></A><FONT COLOR="#000077">Time and Date</FONT></H3>
<P>The time library provides a number of functions for obtaining a close approximation
of the current time and date, and for comparing times and dates to one another.</P>
<P>The center of this library is a structure, <TT>tm</TT>, which consists of nine
integer values for the second, minute, hour, day of the month, number of the month
(where January=0), the number of years since 1900, the day (where Sunday=0), the
day of the year (0-365), and a Boolean value establishing whether daylight saving
time is in effect. (This last may not be supported on some systems.)</P>
<P>Most time functions expect a variable of type <TT>time_t</TT> or a pointer to
a variable of this type. There are conversion routines to turn such a variable into
a <TT>tm</TT> data structure.</P>
<P>The standard library supplies the function <TT>time()</TT>, which takes a pointer
to a <TT>time_t</TT> variable and fills it with the current time. It also provides
<TT>ctime()</TT>, which takes the <TT>time_t</TT> variable filled by <TT>time()</TT>
and returns an ASCII string that can be used for printing. If you need more control
over the output, however, you can pass the <TT>time_t</TT> variable to <TT>local_time()</TT>,
which will return a pointer to a <TT>tm</TT> structure. Listing 21.5 illustrates
these various time functions.</P>

<P><A NAME="Heading13"></A><FONT SIZE="4" COLOR="#000077"><B>Listing 21.5. Using
ctime().</B></FONT>
<PRE><FONT COLOR="#0066FF">1:     #include &lt;time.h&gt;
2:     #include &lt;iostream.h&gt;
3:
4:     int main()
5:     {
6:        time_t currentTime;
7:
8:        // get and print the current time
9:        time (&amp;currentTime); // fill now with the current time
10:       cout &lt;&lt; &quot;It is now &quot; &lt;&lt; ctime(&amp;currentTime) &lt;&lt; endl;
11:
12:       struct tm * ptm= localtime(&amp;currentTime);
13:
14:       cout &lt;&lt; &quot;Today is &quot; &lt;&lt; ((ptm-&gt;tm_mon)+1) &lt;&lt; &quot;/&quot;;
15:       cout &lt;&lt; ptm-&gt;tm_mday &lt;&lt; &quot;/&quot;;
16:       cout &lt;&lt; ptm-&gt;tm_year &lt;&lt; endl;
17:
18:       cout &lt;&lt; &quot;\nDone.&quot;;
19:     return 0;
<TT>20: }</TT>
Output: It is now Mon Mar 31 13:50:10 1997

Today is 3/31/97

Done.
</FONT></PRE>
<P><FONT COLOR="#000077"><B>Analysis:</B></FONT><B> </B>On line 6, <TT>CurrentTime</TT>
is declared to be a variable of type <TT>time_t</TT>. The address of this variable
is passed to the standard time library function <TT>time()</TT>, and the variable
<TT>currentTime</TT> is set to the current date and time. The address of this variable
is then passed to <TT>ctime()</TT>, which returns an ASCII string that is in turn
passed to the <TT>cout</TT> statement on line 12.The address of <TT>currentTime</TT>
is then passed to the standard time library function <TT>localtime()</TT>, and a
pointer to a <TT>tm</TT> structure is returned, which is used to initialize the local
variable <TT>ptm</TT>. The member data of this structure is then accessed to print
the current month, day of the month, and year. 
<H3 ALIGN="CENTER"><A NAME="Heading14"></A><FONT COLOR="#000077">stdlib</FONT></H3>
<P><TT>stdlib</TT> is something of a miscellaneous collection of functions that did
not fit into the other libraries. It includes simple integer math functions, sorting
functions (including <TT>qsort()</TT>, one of the fastest sorts available), and text
conversions for moving from ASCII text to integers, <TT>long</TT>, <TT>float</TT>,
and so forth.</P>
<P>The functions in <TT>stdlib</TT> you are likely to use most often include <TT>atoi()</TT>,
<TT>itoa()</TT>, and the family of related functions. <TT>atoi()</TT> provides ASCII
to integer conversion. <TT>atoi()</TT> takes a single argument: a pointer to a constant
character string. It returns an integer (as you might expect). Listing 21.6 illustrates
its use.</P>

<P><A NAME="Heading15"></A><FONT SIZE="4" COLOR="#000077"><B>Listing 21.6. Using
atoi() and related functions.</B></FONT>
<PRE><FONT COLOR="#0066FF">1:     #include &lt;stdlib.h&gt;
2:     #include &lt;iostream.h&gt;
3:
4:     int main()
5:     {
6:        char buffer[80];
7:        cout &lt;&lt; &quot;Enter a number: &quot;;
8:        cin &gt;&gt; buffer;
9:
10:       int number;
11:       // number = buffer; compile error
12:       number = atoi(buffer);
13:       cout &lt;&lt; &quot;Here's the number: &quot; &lt;&lt; number &lt;&lt; endl;
14:
15:       // int sum = buffer + 5;
16:       int sum = atoi(buffer) + 5;
17:       cout &lt;&lt; &quot;Here's sum: &quot; &lt;&lt; sum &lt;&lt; endl;
18:     return 0;
<TT>19: }</TT></FONT>
<FONT COLOR="#0066FF">
Output: Enter a number: 9
Here's the number: 9
Here's sum: 14
</FONT></PRE>
<P><FONT COLOR="#000077"><B>Analysis:</B></FONT><B> </B>On line 6 of this simple
program, an 80-character buffer is allocated, and on line 7 the user is prompted
for a number. The input is taken as text and written into the buffer.<BR>
On line 10, an <TT>int</TT> variable, <TT>number</TT>, is declared, and on line 11
the program attempts to assign the contents of the buffer to the <TT>int</TT> variable.
This generates a compile-time error and is commented out.</P>
<P>On line 12, the problem is solved by invoking the standard library function <TT>atoi()</TT>,
passing in the buffer as the parameter. The return value, the integer value of the
text string, is assigned to the integer variable number and printed on line 13.</P>
<P>On line 15, a new integer variable, <TT>sum</TT>, is declared, and an attempt
is made to assign to it the result of adding the integer constant <TT>5</TT> to the
buffer. This, too, fails and is solved by calling the standard function <TT>atoi()</TT>.


<BLOCKQUOTE>
	<P>
<HR>
<FONT COLOR="#000077"><B>NOTE:</B></FONT><B> </B>Some compilers implement standard
	conversion procedures (such as <TT>atoi()</TT>) using macros. You can usually use
	these functions without worrying about how they are implemented. Check your compiler's
	documentation for details. 
<HR>


</BLOCKQUOTE>

<H4 ALIGN="CENTER"><A NAME="Heading16"></A><FONT COLOR="#000077">qsort()</FONT></H4>
<P>At times you may want to sort a table or an array; <TT>qsort()</TT> provides a
quick and easy way to do so. The hard part of using <TT>qsort()</TT> is setting up
the structures to pass in.</P>
<P><TT>qsort()</TT> takes four arguments. The first is a pointer to the start of
the table to be sorted (an array name works just fine), the second is the number
of elements in the table, the third is the size of each element, and the fourth is
a pointer to a comparison function.</P>
<P>The comparison function must return an <TT>int</TT>, and must take as its parameters
two constant <TT>void</TT> pointers. <TT>void</TT> pointers aren't used very often
in C++, as they diminish the type checking, but they have the advantage that they
can be used to point to items of any type. If you were writing your own <TT>qsort()</TT>
function, you might consider using templates instead. Listing 21.7 illustrates how
to use the standard <TT>qsort()</TT> function.</P>

<P><A NAME="Heading17"></A><FONT SIZE="4" COLOR="#000077"><B>Listing 21.7. Using
qsort().</B></FONT>
<PRE><FONT COLOR="#0066FF">1:     /* qsort example */
2:
3:     #include &lt;iostream.h&gt;
4:     #include &lt;stdlib.h&gt;
5:
6:     // form of sort_function required by qsort
7:     int sortFunction( const void *intOne, const void *intTwo);
8:
9:     const int TableSize = 10;  // array size
10:
11:    int main(void)
12:    {
13:       int i,table[TableSize];
14:
15:       // fill the table with values
16:       for (i = 0; i&lt;TableSize; i++)
17:       {
18:          cout &lt;&lt; &quot;Enter a number: &quot;;
19:          cin &gt;&gt; table[i];
20:       }
21:       cout &lt;&lt; &quot;\n&quot;;
22:
23:       // sort the values
24:       qsort((void *)table, TableSize, sizeof(table[0]), sortFunction);
25:
26:       // print the results
27:       for (i = 0; i &lt; TableSize; i++)
28:          cout &lt;&lt; &quot;Table [&quot; &lt;&lt; i &lt;&lt; &quot;]: &quot; &lt;&lt; table[i] &lt;&lt; endl;
29:
30:       cout &lt;&lt; &quot;Done.&quot; &lt;&lt; endl;
31:     return 0;
32:    }
33:
34:    int sortFunction( const void *a, const void *b)
35:    {
36:       int intOne = *((int*)a);
37:       int intTwo = *((int*)b);
38:       if (intOne &lt; intTwo)
39:          return -1;
40:       if (intOne == intTwo)
41:          return 0;
42:       return 1;
<TT>43: }</TT>
Output: Enter a number: 2
Enter a number: 9
Enter a number: 12
Enter a number: 873
Enter a number: 0
Enter a number: 45
Enter a number: 93
Enter a number: 2
Enter a number: 66
Enter a number: 1

Table[0]: 0
Table[1]: 1
Table[2]: 2
Table[3]: 2
Table[4]: 9
Table[5]: 12
Table[6]: 45
Table[7]: 66
Table[8]: 93
Table[9]: 873
Done.
</FONT></PRE>
<P><FONT COLOR="#000077"><B>Analysis:</B></FONT><B> </B>On line 4, the standard library
header is included, which is required by the <TT>qsort()</TT> function. On line 7,
the function <TT>sortFunction()</TT> is declared, which takes the required four parameters.<BR>
<BR>
An array is declared on line 13 and filled by user input on lines 16-20. <TT>qsort()</TT>
is called on line 24, casting the address of the array name <TT>table</TT> to be
a <TT>void*</TT>.</P>
<P>Note that the parameters for <TT>sortFunction</TT> are not passed to the call
to <TT>qsort()</TT>. The name of the <TT>sortFunction</TT>, which is itself a pointer
to that function, is the parameter to <TT>qsort()</TT>.</P>
<P>Once <TT>qsort()</TT> is running, it will fill the constant <TT>void</TT> pointers
<TT>a</TT> and <TT>b</TT> with each value of the array. If the first value is smaller
than the second, the comparison function must return <TT>-1</TT>. If it is equal,
the comparison function must return <TT>0</TT>. Finally, if the first value is greater
than the second value, the comparison function must return <TT>1</TT>. This is reflected
in the <TT>sortFunction()</TT>, as shown on lines 34 to 43.
<H4 ALIGN="CENTER"><A NAME="Heading18"></A><FONT COLOR="#000077">Other Libraries</FONT></H4>
<P>Your C++ compiler supplies a number of other libraries, among them the standard
input and output libraries and the stream libraries that you've been using throughout
this book. It is well worth your time and effort to explore the documentation that
came with your compiler to find out what these libraries have to offer.
<H3 ALIGN="CENTER"><A NAME="Heading19"></A><FONT COLOR="#000077">Bit Twiddling</FONT></H3>
<P>Often you will want to set flags in your objects to keep track of the state of
your object. (Is it in <TT>AlarmState</TT>? Has this been initialized yet? Are you
coming or going?)</P>
<P>You can do this with user-defined Booleans, but when you have many flags, and
when storage size is an issue, it is convenient to be able to use the individual
bits as flags.</P>
<P>Each byte has eight bits, so in a four-byte <TT>long</TT> you can hold 32 separate
flags. A bit is said to be &quot;set&quot; if its value is <TT>1</TT>, and clear
if its value is <TT>0</TT>. When you set a bit, you make its value <TT>1</TT>, and
when you clear it, you make its value <TT>0</TT>. (Set and clear are both adjectives
and verbs). You can set and clear bits by changing the value of the <TT>long</TT>,
but that can be tedious and confusing.


<BLOCKQUOTE>
	<P>
<HR>
<FONT COLOR="#000077"><B>NOTE:</B></FONT><B> </B>Appendix C, &quot;Binary and Hexadecimal,&quot;
	provides valuable additional information about binary and hexadecimal manipulation.
	
<HR>


</BLOCKQUOTE>

<P>C++ provides bitwise operators that act upon the individual bits.These look like,
but are different from, the logical operators, so many novice programmers confuse
them. The bitwise operators are presented in Table 21.1. <BR>
<BR>
<FONT SIZE="4"><B>Table 21.1. The Bitwise Operators. </B></FONT>
<TABLE BORDER="0" WIDTH="145">
	<TR ALIGN="LEFT" rowspan="1">
		<TD WIDTH="64" ALIGN="LEFT"><B><I>symbol</I></B></TD>
		<TD ALIGN="LEFT"><B><I>operator</I></B></TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD WIDTH="64" ALIGN="LEFT"><TT>&amp;</TT></TD>
		<TD ALIGN="LEFT"><TT>AND</TT></TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD WIDTH="64" ALIGN="LEFT"><TT>|</TT></TD>
		<TD ALIGN="LEFT"><TT>OR</TT></TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD WIDTH="64" ALIGN="LEFT"><TT>^</TT></TD>
		<TD ALIGN="LEFT">exclusive <TT>OR</TT></TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD WIDTH="64" ALIGN="LEFT"><TT>~</TT></TD>
		<TD ALIGN="LEFT">complement</TD>
	</TR>
</TABLE>

<CENTER>
<H4><A NAME="Heading20"></A><FONT COLOR="#000077">Operator AND</FONT></H4>
</CENTER>
<P>The <TT>AND</TT> operator (<TT>&amp;</TT>) is a single ampersand, as opposed to
the logical <TT>AND</TT>, which is two ampersands. When you <TT>AND</TT> two bits,
the result is <TT>1</TT> if both bits are <TT>1</TT>, but <TT>0</TT> if either or
both bits are <TT>0</TT>. The way to think of this is: The result is <TT>1</TT> if
bit 1 is set and if bit 2 is set.
<CENTER>
<H4><A NAME="Heading21"></A><FONT COLOR="#000077">Operator OR</FONT></H4>
</CENTER>
<P>The second bitwise operator is <TT>OR</TT> (<TT>|</TT>). Again, this is a single
vertical bar, as opposed to the logical <TT>OR</TT>, which is two vertical bars.
When you <TT>OR</TT> two bits, the result is <TT>1</TT> if either bit is set or if
both are.
<CENTER>
<H4><A NAME="Heading22"></A><FONT COLOR="#000077">Operator Exclusive OR</FONT></H4>
</CENTER>
<P>The third bitwise operator is exclusive <TT>OR</TT> (<TT>^</TT>). When you exclusive
<TT>OR</TT> two bits, the result is <TT>1</TT> if the two bits are different.
<CENTER>
<H4><A NAME="Heading23"></A><FONT COLOR="#000077">The Complement Operator</FONT></H4>
</CENTER>
<P>The complement operator (<TT>~</TT>) clears every bit in a number that is set
and sets every bit that is clear. If the current value of the number is <TT>1010
0011</TT>, the complement of that number is <TT>0101 1100</TT>.
<CENTER>
<H4><A NAME="Heading24"></A><FONT COLOR="#000077">Setting Bits</FONT></H4>
</CENTER>
<P>When you want to set or clear a particular bit, you use masking operations. If
you have a 4-byte flag and you want to set bit 8 TRUE, you need to <TT>OR</TT> the
flag with the value <TT>128</TT>. Why? <TT>128</TT> is <TT>1000 0000</TT> in binary;
thus the value of the eighth bit is <TT>128</TT>. Whatever the current value of that
bit (<TT>set</TT> or <TT>clear</TT>), if you <TT>OR</TT> it with the value <TT>128</TT>
you will set that bit and not change any of the other bits. Let's assume that the
current value of the 8 bits is <TT>1010 0110 0010 0110</TT>. <TT>OR</TT>ing 128 to
it looks like this:</P>
<PRE><FONT COLOR="#0066FF">9 8765 4321
1010 0110 0010 0110   // bit 8 is clear
|   0000 0000 1000 0000   // 128
----------------------
1010 0110 1010 0110   // bit 8 is set
</FONT></PRE>
<P>There are a few things to note. First, as usual, bits are counted from right to
left. Second, the value <TT>128</TT> is all zeros except for bit 8, the bit you want
to set. Third, the starting number <TT>1010 0110 0010 0110</TT> is left unchanged
by the <TT>OR</TT> operation, except that bit 8 was set. Had bit 8 already been set,
it would have remained set, which is what you want.
<CENTER>
<H4><A NAME="Heading25"></A><FONT COLOR="#000077">Clearing Bits</FONT></H4>
</CENTER>
<P>If you want to clear bit 8, you can <TT>AND</TT> the bit with the complement of
128. The complement of 128 is the number you get when you take the bit pattern of
128 (1000 0000), set every bit that is <TT>clear</TT>, and clear every bit that is
<TT>set</TT> (0111 1111). When you <TT>AND</TT> these numbers, the original number
is unchanged, except for the eighth bit, which is forced to zero.</P>
<PRE><FONT COLOR="#0066FF">1010 0110 1010 0110  // bit 8 is set
&amp; 1111 1111 0111 1111  // ~128
----------------------
1010 0110 0010 0110  // bit 8 cleared
</FONT></PRE>
<P>To fully understand this solution, do the math yourself. Each time both bits are
<TT>1</TT>, write 1 in the answer. If either bit is <TT>0</TT>, write 0 in the answer.
Compare the answer with the original number. It should be the same except that bit
8 was cleared.
<CENTER>
<H4><A NAME="Heading26"></A><FONT COLOR="#000077">Flipping Bits</FONT></H4>
</CENTER>
<P>Finally, if you want to flip bit 8, no matter what its state, you exclusive <TT>OR</TT>
the number with 128. Thus:</P>
<PRE><FONT COLOR="#0066FF">1010 0110 1010 0110  // number
^ 0000 0000 1000 0000  // 128
----------------------
1010 0110 0010 0110  // bit flipped
^ 0000 0000 1000 0000  // 128
----------------------
1010 0110 1010 0110  // flipped back
</FONT></PRE>


<BLOCKQUOTE>
	<P>
<HR>
<B>DO</B> set bits by using masks and the <TT>OR</TT> operator. <B>DO</B> clear bits
	by using masks and the <TT>AND</TT> operator.<B> DO </B>flip bits using masks and
	the exclusive <TT>OR</TT> operator. 
<HR>


</BLOCKQUOTE>

<CENTER>
<H4><A NAME="Heading27"></A><FONT COLOR="#000077">Bit Fields</FONT></H4>
</CENTER>
<P>There are circumstances under which every byte counts, and saving six or eight
bytes in a class can make all the difference. If your class or structure has a series
of Boolean variables, or variables that can have only a very small number of possible
values, you may save some room using bit fields.</P>
<P>Using the standard C++ data types, the smallest type you can use in your class
is a type <TT>char</TT>, which is one byte. You will usually end up using an <TT>int</TT>,
which is two, or more often four, bytes. By using bit fields, you can store eight
binary values in a <TT>char</TT> and 32 such values in a <TT>long</TT>.</P>
<P>Here's how bit fields work: bit fields are named and accessed like any class member.
Their type is always declared to be <TT>unsigned</TT> <TT>int</TT>. After the bit
field name, write a colon followed by a number. The number is an instruction to the
compiler as to how many bits to assign to this variable. If you write 1, the bit
will represent either the value <TT>0</TT> or <TT>1</TT>. If you write 2, the bit
can represent <TT>0</TT>, <TT>1</TT>, <TT>2</TT>, or <TT>3</TT>, a total of four
values. A three-bit field can represent eight values, and so forth. Appendix C reviews
binary numbers. Listing 21.8 illustrates the use of bit fields.</P>

<P><A NAME="Heading28"></A><FONT SIZE="4" COLOR="#000077"><B>Listing 21.8. Using
bit fields.</B></FONT>
<PRE><FONT COLOR="#0066FF">0:        #include &lt;iostream.h&gt;
1:        #include &lt;string.h&gt;
2:    
3:        enum STATUS { FullTime, PartTime } ;
4:        enum GRADLEVEL { UnderGrad, Grad } ;
5:        enum HOUSING { Dorm, OffCampus };
6:        enum FOODPLAN { OneMeal, AllMeals, WeekEnds, NoMeals };
7:    
8:        class student
9:        {
10:        public:
11:        student():
12:            myStatus(FullTime),
13:            myGradLevel(UnderGrad),
14:            myHousing(Dorm),
15:            myFoodPlan(NoMeals)
16:            {}
17:            ~student(){}
18:            STATUS GetStatus();
19:            void SetStatus(STATUS);
20:            unsigned GetPlan() { return myFoodPlan; }
21:    
22:        private:
23:           unsigned myStatus : 1;
24:           unsigned myGradLevel: 1;
25:           unsigned myHousing : 1;
26:           unsigned myFoodPlan : 2;
27:        };
28:    
29:        STATUS student::GetStatus()
30:        {
31:           if (myStatus)
32:              return FullTime;
33:           else
34:              return PartTime;
35:        }
36:        void student::SetStatus(STATUS theStatus)
37:        {
38:           myStatus = theStatus;
39:        }
40:    
41:    
42:        int main()
43:        {
44:           student Jim;
45:    
46:           if (Jim.GetStatus()== PartTime)
47:              cout &lt;&lt; &quot;Jim is part time&quot; &lt;&lt; endl;
48:           else
49:              cout &lt;&lt; &quot;Jim is full time&quot; &lt;&lt; endl;
50:    
51:           Jim.SetStatus(PartTime);
52:    
53:           if (Jim.GetStatus())
54:              cout &lt;&lt; &quot;Jim is part time&quot; &lt;&lt; endl;
55:           else
56:              cout &lt;&lt; &quot;Jim is full time&quot; &lt;&lt; endl;
57:    
58:           cout &lt;&lt; &quot;Jim is on the &quot; ;
59:    
60:           char Plan[80];
61:           switch (Jim.GetPlan())
62:           {
63:              case  OneMeal: strcpy(Plan,&quot;One meal&quot;); break;
64:              case  AllMeals: strcpy(Plan,&quot;All meals&quot;); break;
65:              case WeekEnds: strcpy(Plan,&quot;Weekend meals&quot;); break;
66:              case NoMeals: strcpy(Plan,&quot;No Meals&quot;);break;
67:              default : cout &lt;&lt; &quot;Something bad went wrong!\n&quot;; break;
68:           }
69:           cout &lt;&lt; Plan &lt;&lt; &quot; food plan.&quot; &lt;&lt; endl;
70:         return 0;
<TT>71: }</TT></FONT>
<FONT COLOR="#0066FF">
Output: Jim is part time
Jim is full time
Jim is on the No Meals food plan.
</FONT></PRE>
<P><FONT COLOR="#000077"><B>Analysis:</B></FONT><B> </B>On lines 3 to 7, several
enumerated types are defined. These serve to define the possible values for the bit
fields within the student class.<BR>
<TT><BR>
Student</TT> is declared in lines 8-27. While this is a trivial class, it is interesting
in that all the data is packed into five bits. The first bit represents the student's
status, full-time or part-time. The second bit represents whether or not this is
an undergraduate. The third bit represents whether or not the student lives in a
dorm. The final two bits represent the four possible food plans.</P>
<P>The class methods are written as for any other class, and are in no way affected
by the fact that these are bit fields and not integers or enumerated types.</P>
<P>The member function <TT>GetStatus()</TT> reads the Boolean bit and returns an
enumerated type, but this is not necessary. It could just as easily have been written
to return the value of the bit field directly. The compiler would have done the translation.</P>
<PRE>To prove that to yourself, replace the <TT>GetStatus()</TT> implementation with this code:</PRE>
<PRE><FONT COLOR="#0066FF">STATUS student::GetStatus()
{
return myStatus;
}</FONT></PRE>
<P>There should be no change whatsoever to the functioning of the program. It is
a matter of clarity when reading the code; the compiler isn't particular.</P>
<P>Note that the code on line 46 must check the status and then print the meaningful
message. It is tempting to write this:</P>
<PRE><FONT COLOR="#0066FF">cout &lt;&lt; &quot;Jim is &quot; &lt;&lt; Jim.GetStatus() &lt;&lt; endl;</FONT></PRE>
<P>That will simply print this:</P>
<PRE><FONT COLOR="#0066FF">Jim is 0</FONT></PRE>
<P>The compiler has no way to translate the enumerated constant <TT>PartTime</TT>
into meaningful text.</P>
<P>On line 61, the program switches on the food plan, and for each possible value
it puts a reasonable message into the buffer, which is then printed on line 69. Note
again that the <TT>switch</TT> statement could have been written as follows:</P>
<PRE><FONT COLOR="#0066FF">case  0: strcpy(Plan,&quot;One meal&quot;); break;
case  1: strcpy(Plan,&quot;All meals&quot;); break;
case  2: strcpy(Plan,&quot;Weekend meals&quot;); break;
case  3: strcpy(Plan,&quot;No Meals&quot;);break;</FONT></PRE>
<P>The most important thing about using bit fields is that the client of the class
need not worry about the data storage implementation. Because the bit fields are
private, you can feel free to change them later and the interface will not need to
change.
<CENTER>
<H3><A NAME="Heading30"></A><FONT COLOR="#000077">Style</FONT></H3>
</CENTER>
<P>As stated elsewhere in this book, it is important to adopt a consistent coding
style, though in many ways it doesn't matter which style you adopt. A consistent
style makes it easier to guess what you meant by a particular part of the code, and
you avoid having to look up whether you spelled the function with an initial cap
or not the last time you invoked it.</P>
<P>The following guidelines are arbitrary; they are based on the guidelines used
in projects I've worked on in the past, and they've worked well. You can just as
easily make up your own, but these will get you started.</P>
<P>As Emerson said, &quot;Foolish consistency is the hobgoblin of small minds,&quot;
but having some consistency in your code is a good thing. Make up your own, but then
treat it as if it were dispensed by the programming gods.
<CENTER>
<H4><A NAME="Heading31"></A><FONT COLOR="#000077">Indenting</FONT></H4>
</CENTER>
<P>Tab size should be four spaces. Make sure your editor converts each tab to four
spaces.
<CENTER>
<H4><A NAME="Heading32"></A><FONT COLOR="#000077">Braces</FONT></H4>
</CENTER>
<P>How to align braces can be the most controversial topic between C and C++ programmers.
Here are the tips I suggest:

<UL>
	<LI>Matching braces should be aligned vertically.
	<P>
	<LI>The outermost set of braces in a definition or declaration should be at the left
	margin. Statements within should be indented. All other sets of braces should be
	in line with their leading statements.
	<P>
	<LI>No code should appear on the same line as a brace. For example:
</UL>

<PRE><FONT COLOR="#0066FF">if (condition==true)
{
j = k;
SomeFunction();
}
m++;
</FONT></PRE>
<CENTER>
<H4><A NAME="Heading33"></A><FONT COLOR="#000077">Long Lines</FONT></H4>
</CENTER>
<P>Keep lines to the width displayable on a single screen. Code that is off to the
right is easily overlooked, and scrolling horizontally is annoying. When a line is
broken, indent the following lines. Try to break the line at a reasonable place,
and try to leave the intervening operator at the end of the previous line (as opposed
to the beginning of the following line) so that it is clear that the line does not
stand alone and that there is more coming.</P>
<P>In C++, functions tend to be far shorter than they were in C, but the old, sound
advice still applies. Try to keep your functions short enough to print the entire
function on one page.
<CENTER>
<H4><A NAME="Heading34"></A><FONT COLOR="#000077">switch Statements</FONT></H4>
</CENTER>
<P>Indent switches as follows to conserve horizontal space:</P>
<PRE><FONT COLOR="#0066FF">switch(variable)
{
case ValueOne:
ActionOne();
break;
case ValueTwo:
ActionTwo();
break;
default:
assert(&quot;bad Action&quot;);
break;
}
</FONT></PRE>
<CENTER>
<H4><A NAME="Heading35"></A><FONT COLOR="#000077">Program Text</FONT></H4>
</CENTER>
<P>There are several tips you can use to create code that is easy to read. Code that
is easy to read is easy to maintain.

<UL>
	<LI>Use whitespace to help readability.
	<P>
	<LI>Objects and arrays are really referring to one thing. Don't use spaces within
	object references (<TT>.</TT>, <TT>-&gt;</TT>, <TT>[]</TT>).
	<P>
	<LI>Unary operators are associated with their operands, so don't put a space between
	them. Do put a space on the side away from the operand. Unary operators include <TT>!</TT>,
	<TT>~</TT>, <TT>++</TT>, <TT>--</TT>, <TT>-</TT>, <TT>*</TT> (for pointers), <TT>&amp;</TT>
	(casts), <TT>sizeof</TT>.
	<P>
	<LI>Binary operators should have spaces on both sides: <TT>+</TT>, <TT>=</TT>, <TT>*</TT>,
	<TT>/</TT>, <TT>%</TT>, <TT>&gt;&gt;</TT>, <TT>&lt;&lt;</TT>, <TT>&lt;</TT>, <TT>&gt;</TT>,
	<TT>==</TT>, <TT>!=</TT>, <TT>&amp;</TT>, <TT>|</TT>, <TT>&amp;&amp;</TT>, <TT>||</TT>,
	<TT>?:</TT>, <TT>=</TT>, <TT>+=</TT>, and so on.
	<P>
	<LI>Don't use lack of spaces to indicate precedence (<TT>4+ 3*2</TT>).
	<P>
	<LI>Put a space after commas and semicolons, not before.
	<P>
	<LI>Parentheses should not have spaces on either side.
	<P>
	<LI>Keywords, such as <TT>if</TT>, should be set off by a space: <TT>if (a == b)</TT>.
	<P>
	<LI>The body of a comment should be set off from the <TT>//</TT> with a space.
	<P>
	<LI>Place the pointer or reference indicator next to the type name, not the variable
	name:
</UL>

<PRE><FONT COLOR="#0066FF">char* foo;
int&amp; theInt;
</FONT></PRE>

<UL>
	<LI>rather than
</UL>

<PRE><FONT COLOR="#0066FF">char *foo;
int &amp;theInt;
</FONT></PRE>

<UL>
	<LI>Do not declare more than one variable on the same line.
</UL>

<CENTER>
<H4><A NAME="Heading36"></A><FONT COLOR="#000077">Identifier Names</FONT></H4>
</CENTER>
<P>Here are some guidelines for working with identifiers.

<UL>
	<LI>Identifier names should be long enough to be descriptive.
	<P>
	<LI>Avoid cryptic abbreviations.
	<P>
	<LI>Take the time and energy to spell things out.
	<P>
	<LI>Do not use Hungarian notation. C++ is strongly typed and there is no reason to
	put the type into the variable name. With user-defined types (classes), Hungarian
	notation quickly breaks down. The exceptions to this may be to use a prefix for pointers
	(<TT>p</TT>) and references (<TT>r</TT>), as well as for class member variables (<TT>its</TT>).
	<P>
	<LI>Short names (<TT>i</TT>, <TT>p</TT>, <TT>x</TT>, and so on) should only be used
	where their brevity makes the code more readable and where the usage is so obvious
	that a descriptive name is not needed.
	<P>
	<LI>The length of a variable's name should be proportional to its scope.
	<P>
	<LI>Make sure identifiers look and sound different from one another to minimize confusion.
	<P>
	<LI>Function (or method) names are usually verbs or verb-noun phrases: <TT>Search()</TT>,
	<TT>Reset()</TT>, <TT>FindParagraph()</TT>, <TT>ShowCursor()</TT>. Variable names
	are usually abstract nouns, possibly with an additional noun: <TT>count</TT>, <TT>state</TT>,
	<TT>windSpeed</TT>, <TT>windowHeight</TT>. Boolean variables should be named appropriately:
	<TT>windowIconized</TT>, <TT>fileIsOpen</TT>.
</UL>

<CENTER>
<H4><A NAME="Heading37"></A><FONT COLOR="#000077">Spelling and Capitalization of
Names</FONT></H4>
</CENTER>
<P>Spelling and capitalization should not be overlooked when creating your own style.
Some tips for these areas include the following:

<UL>
	<LI>Use all uppercase and underscore to separate the logical words of names, such
	as <TT>SOURCE_FILE_TEMPLATE</TT>. Note, however, that these are rare in C++. Consider
	using constants and templates in most cases.
	<P>
	<LI>All other identifiers should use mixed case--no underscores. Function names,
	methods, class, <TT>typedef</TT>, and <TT>struct</TT> names should begin with a capitalized
	letter. Elements such as data members or locals should begin with a lowercase letter.
	<P>
	<LI>Enumerated constants should begin with a few lowercase letters as an abbreviation
	for the <TT>enum</TT>. For example:
</UL>

<PRE><FONT COLOR="#0066FF">enum TextStyle
{
    tsPlain,
    tsBold,
    tsItalic,
    tsUnderscore,
};
</FONT></PRE>
<CENTER>
<H4><A NAME="Heading38"></A><FONT COLOR="#000077">Comments</FONT></H4>
</CENTER>
<P>Comments can make it much easier to understand a program. Sometimes you will not
work on a program for several days or even months. In this time you can forget what
certain code does or why it has been included. Problems in understanding code can
also occur when someone else reads your code. Comments that are applied in a consistent,
well thought out style can be well worth the effort. There are several tips to remember
concerning comments:

<UL>
	<LI>Wherever possible, use C++ <TT>//</TT> comments rather than the <TT>/* */</TT>
	style.
	<P>
	<LI>Higher-level comments are infinitely more important than process details. Add
	value; do not merely restate the code.
</UL>

<PRE><FONT COLOR="#0066FF">n++; // n is incremented by one
</FONT></PRE>

<UL>
	<LI>This comment isn't worth the time it takes to type it in. Concentrate on the
	semantics of functions and blocks of code. Say what a function does. Indicate side
	effects, types of parameters, and return values. Describe all assumptions that are
	made (or not made), such as &quot;<TT>assumes </TT>n<TT> is non-negative</TT>&quot;
	or &quot;<TT>will return -1 if </TT>x<TT> is invalid</TT>&quot;. Within complex logic,
	use comments to indicate the conditions that exist at that point in the code.
	<P>
	<LI>Use complete English sentences with appropriate punctuation and capitalization.
	The extra typing is worth it. Don't be overly cryptic and don't abbreviate. What
	seems exceedingly clear to you as you write code will be amazingly obtuse in a few
	months.
	<P>
	<LI>Use blank lines freely to help the reader understand what is going on. Separate
	statements into logical groups.
</UL>

<CENTER>
<H4><A NAME="Heading39"></A><FONT COLOR="#000077">Access</FONT></H4>
</CENTER>
<P>The way you access portions of your program should also be consistent. Some tips
for access include these:

<UL>
	<LI>Always use <TT>public:</TT>, <TT>private:</TT>, and <TT>protected:</TT> labels;
	don't rely on the defaults.
	<P>
	<LI>List the public members first, then protected, then private. List the data members
	in a group after the methods.
	<P>
	<LI>Put the constructor(s) first in the appropriate section, followed by the destructor.
	List overloaded methods with the same name adjacent to each other. Group accessor
	functions together when possible.
	<P>
	<LI>Consider alphabetizing the method names within each group and alphabetizing the
	member variables. Be sure to alphabetize the filenames in <TT>include</TT> statements.
	<P>
	<LI>Even though the use of the <TT>virtual</TT> keyword is optional when overriding,
	use it anyway; it helps to remind you that it is virtual, and also keeps the declaration
	consistent.
</UL>

<CENTER>
<H4><A NAME="Heading40"></A><FONT COLOR="#000077">Class Definitions</FONT></H4>
</CENTER>
<P>Try to keep the definitions of methods in the same order as the declarations.
It makes things easier to find.</P>
<P>When defining a function, place the return type and all other modifiers on a previous
line so that the class name and function name begin on the left margin. This makes
it much easier to find functions.
<CENTER>
<H4><A NAME="Heading41"></A><FONT COLOR="#000077">include Files</FONT></H4>
</CENTER>
<P>Try as hard as you can to keep from including files into header files. The ideal
minimum is the header file for the class this one derives from. Other mandatory <TT>include</TT>s
will be those for objects that are members of the class being declared. Classes that
are merely pointed to or referenced only need forward references of the form.</P>
<P>Don't leave out an <TT>include</TT> file in a header just because you assume that
whatever CPP file includes this one will also have the needed <TT>include</TT>.


<BLOCKQUOTE>
	<P>
<HR>
<FONT COLOR="#000077"><B>TIP:</B></FONT><B> </B>All header files should use inclusion
	guards. 
<HR>


</BLOCKQUOTE>

<CENTER>
<H4><A NAME="Heading42"></A><FONT COLOR="#000077">assert()</FONT></H4>
</CENTER>
<P>Use <TT>assert()</TT> freely. It helps find errors, but it also greatly helps
a reader by making it clear what the assumptions are. It also helps to focus the
writer's thoughts around what is valid and what isn't.
<CENTER>
<H4><A NAME="Heading43"></A><FONT COLOR="#000077">const</FONT></H4>
</CENTER>
<P>Use <TT>const</TT> wherever appropriate: for parameters, variables, and methods.
Often there is a need for both a <TT>const</TT> and a non-<TT>const</TT> version
of a method; don't use this as an excuse to leave one out. Be very careful when explicitly
casting from <TT>const</TT> to non-<TT>const</TT> and vice versa (there are times
when this is the only way to do something), but be certain that it makes sense, and
include a comment.
<CENTER>
<H3><A NAME="Heading44"></A><FONT COLOR="#000077">Next Steps</FONT></H3>
</CENTER>
<P>You've spent three long, hard weeks working at C++, and you are now a competent
C++ programmer, but you are by no means finished. There is much more to learn and
many more places you can get valuable information as you move from novice C++ programmer
to expert.</P>
<P>The following sections recommend a number of specific sources of information,
and these recommendations reflect only my personal experience and opinions. There
are dozens of books on each of these topics, however, so be sure to get other opinions
before purchasing.
<CENTER>
<H4><A NAME="Heading45"></A><FONT COLOR="#000077">Where to Get Help and Advice</FONT></H4>
</CENTER>
<P>The very first thing you will want to do as a C++ programmer will be to tap into
one or another C++ conference on an online service. These groups supply immediate
contact with hundreds or thousands of C++ programmers who can answer your questions,
offer advice, and provide a sounding board for your ideas.</P>
<P>I participate in the C++ Internet newsgroups (<TT>comp.lang.c++ </TT>and<TT> comp.lang.c++.moderated</TT>),
and I recommend them as excellent sources of information and support.</P>
<P>Also, you may want to look for local user groups. Many cities have C++ interest
groups where you can meet other programmers and exchange ideas.
<CENTER>
<H4><A NAME="Heading46"></A><FONT COLOR="#000077">Required Reading</FONT></H4>
</CENTER>
<P>The very next book I'd run out and buy and read is</P>
<P>Meyers, Scott. Effective C++ (ISBN: 0-201-56364-9). Addison-Wesley Publishing,
1993.</P>
<P>This is by far the most useful book I've ever read, and I've read it three times.
<CENTER>
<H4><A NAME="Heading47"></A><FONT COLOR="#000077">Magazines</FONT></H4>
</CENTER>
<P>There is one more thing you can do to strengthen your skills: subscribe to a good
magazine on C++ programming. The absolute best magazine of this kind, I believe,
is C++ Report from SIGS Publications. Every issue is packed with useful articles.
Save them; what you don't care about today will become critically important tomorrow.</P>
<P>You can reach C++ Report at SIGS Publications, P.O. Box 2031, Langhorne, PA 19047-9700.
I have no affiliation with the magazine (I work for two other publishers!), but their
magazine is the best, bar none.
<CENTER>
<H4><A NAME="Heading48"></A><FONT COLOR="#000077">Staying in Touch</FONT></H4>
</CENTER>
<P>If you have comments, suggestions, or ideas about this book or other books, I'd
love to hear them. Please write to me at <TT>jliberty@libertyassociates.com</TT>,
or check out my Web site: <TT>www.libertyassociates.com</TT>. I look forward to hearing
from you.


<BLOCKQUOTE>
	<P>
<HR>
<B>DO</B> look at other books. There's plenty to learn and no single book can teach
	you everything you need to know. <B>DON'T</B> just read code! The best way to learn
	C++ is to write C++ programs. <B>DO </B>subscribe to a good C++ magazine and join
	a good C++ user group. 
<HR>


</BLOCKQUOTE>

<CENTER>
<H3><A NAME="Heading49"></A><FONT COLOR="#000077">Summary</FONT></H3>
</CENTER>
<P>Today you saw how some of the standard libraries shipped with your C++ compiler
can be used to manage some routine tasks. <TT>Strcpy()</TT>, <TT>strlen()</TT>, and
related functions can be used to manipulate null-terminated strings. Although these
won't work with the string classes you create, you may find that they provide functionality
essential to implementing your own classes.</P>
<P>The time and date functions allow you to obtain and manipulate time structures.
These can be used to provide access to the system time for your programs, or they
can be used to manipulate time and date objects you create.</P>
<P>You also learned how to set and test individual bits, and how to allocate a limited
number of bits to class members.</P>
<P>Finally, C++ style issues were addressed, and resources were provided for further
study.
<CENTER>
<H3><A NAME="Heading50"></A><FONT COLOR="#000077"><B>Q&amp;A</B></FONT></H3>
</CENTER>

<DL>
	<DD><B>Q. Why are the standard libraries included with C++ compilers, and when would
	you use them?</B><BR>
	<BR>
	<B>A. </B>They are included for backwards-compatibility with C. They are not type-safe,
	and they don't work well with user-created classes, so their use is limited. Over
	time, you might expect all of their functionality to be migrated into C++ specific
	libraries, at which time the standard C libraries would become obsolete.<BR>
	<BR>
	<B>Q. When would you use bit structures rather than simply using integers?<BR>
	</B><BR>
	<B>A.</B> When the size of the object is crucial. If you are working with limited
	memory or with communications software, you may find that the savings offered by
	these structures is essential to the success of your product.<BR>
	<BR>
	<B>Q. Why do style wars generate so much emotion?<BR>
	</B><BR>
	<B>A.</B> Programmers become very attached to their habits. If you are used to this
	indentation,
</DL>

<PRE><FONT COLOR="#0066FF">if (SomeCondition){
     // statements
}    // closing brace
</FONT></PRE>

<DL>
	<DD>it is a difficult transition to give it up. New styles look wrong and create
	confusion. If you get bored, try logging onto a popular online service and asking
	which indentation style works best, which editor is best for C++, or which product
	is the best word processor. Then sit back and watch as ten thousand messages are
	generated, all contradicting one another.<BR>
	<BR>
	<B>Q. What is the very next thing to read?<BR>
	</B><BR>
	<B>A.</B> Tough question. If you want to review the fundamentals, read one of the
	other primers. If you want to hone C++, run out and get Scott Meyers' Effective C++.
	Finally, if you want to write for Windows or the Mac, it might make sense to pick
	up a primer on the <BR>
	platform.<BR>
	<BR>
	<B>Q. Is that it?<BR>
	</B><BR>
	<B>A.</B> Yes! You've learned C++, but...no. Ten years ago it was possible for one
	person to learn all there was to know about microcomputers, or at least to feel pretty
	confident that he was close. Today it is out of the question: You can't possibly
	catch up, and even as you try the industry is changing. Be sure to keep reading,
	and stay in touch with the resources that will keep you up with the latest changes:
	magazines and online services.
</DL>

<CENTER>
<H4><A NAME="Heading51"></A><FONT COLOR="#000077">Quiz</FONT></H4>
</CENTER>

<DL>
	<DD><B>1.</B> What is the difference between <TT>strcpy()</TT> and <TT>strncpy()</TT>?<BR>
	<BR>
	<B>2.</B> What does <TT>ctime()</TT> do?<BR>
	<BR>
	<B>3.</B> What is the function to call to turn an ASCII string into a <TT>long</TT>?<BR>
	<BR>
	<B>4.</B> What does the complement operator do?<BR>
	<BR>
	<B>5.</B> What is the difference between <TT>OR</TT> and exclusive <TT>OR</TT>?<BR>
	<BR>
	<B>6.</B> What is the difference between <TT>&amp;</TT> and <TT>&amp;&amp;</TT>?<BR>
	<BR>
	<B>7.</B> What is the difference between <TT>|</TT> and <TT>||</TT>?
</DL>

<CENTER>
<H4><A NAME="Heading52"></A><FONT COLOR="#000077">Exercises</FONT></H4>
</CENTER>

<DL>
	<DD><B>1.</B> Write a program to safely copy the contents of a 20-byte string to
	a 10-byte string, truncating whatever won't fit.<BR>
	<BR>
	<B>2.</B> Write a program that tells the current date in the form 7/28/94.<BR>
	<BR>
	<B>3.</B> Write a program that creates 26 flags (labeled a-z). Prompt the user to
	enter a sentence, and then quickly report on which letters were used by setting and
	then reading the flags.<BR>
	<B><BR>
	4.</B> Write a program that adds two numbers without using the addition operator
	(<TT>+</TT>). Hint: use the bit operators!
	<CENTER>
	<DD><BR>
	<BR>
	<A HREF="ch20.htm"><IMG SRC="../buttons/BLANPREV.GIF" WIDTH="37"
	HEIGHT="37" ALIGN="BOTTOM" BORDER="0"></A><A HREF="http://www.mcp.com/sams"><IMG
	SRC="../buttons/BLANHOME.GIF" WIDTH="37" HEIGHT="37" ALIGN="BOTTOM"
	BORDER="0"></A><A HREF="../index.htm"><IMG SRC="../buttons/BLANTOC.GIF"
	WIDTH="37" HEIGHT="37" ALIGN="BOTTOM" BORDER="0"></A><A HREF="ch21rv3.htm"><IMG SRC="../buttons/BLANNEXT.GIF"
	WIDTH="37" HEIGHT="37" ALIGN="BOTTOM" BORDER="0"></A><A HREF="#heading1"><IMG SRC="../buttons/BLANTOP.GIF"
	WIDTH="37" HEIGHT="37" ALIGN="BOTTOM" BORDER="0"></A></CENTER>
</DL>



</BODY>

</HTML>