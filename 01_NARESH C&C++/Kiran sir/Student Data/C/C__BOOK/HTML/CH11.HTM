<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>

<HEAD>
<!-- This document was created from RTF source by rtftohtml version 3.0.1 -->

	<META NAME="GENERATOR" Content="Symantec Visual Page 1.0">
	<META HTTP-EQUIV="Content-Type" CONTENT="text/html;CHARSET=iso-8859-1">
	<TITLE>Teach Yourself C++ in 21 Days</TITLE>
</HEAD>

<BODY TEXT="#000000" BGCOLOR="#FFFFFF">

<H1 ALIGN="CENTER"><A HREF="ch10.htm"><IMG SRC="../buttons/BLANPREV.GIF"
WIDTH="37" HEIGHT="37" ALIGN="BOTTOM" BORDER="0"></A><A HREF="http://www.mcp.com/sams"><IMG
SRC="../buttons/BLANHOME.GIF" WIDTH="37" HEIGHT="37" ALIGN="BOTTOM"
BORDER="0"></A><A HREF="../index.htm"><IMG SRC="../buttons/BLANTOC.GIF"
WIDTH="37" HEIGHT="37" ALIGN="BOTTOM" BORDER="0"></A><A HREF="ch12.htm"><IMG SRC="../buttons/BLANNEXT.GIF"
WIDTH="37" HEIGHT="37" ALIGN="BOTTOM" BORDER="0"></A></H1>
<H1></H1>

<UL>
	<LI><A HREF="#Heading1">Day 11</A>
	<UL>
		<LI><A HREF="#Heading2">Arrays</A>
		<UL>
			<LI><A HREF="#Heading3">What Is an Array?</A>
			<UL>
				<LI><A HREF="#Heading4">Figure 11.1.</A>
			</UL>
			<LI><A HREF="#Heading5">Array Elements</A>
			<LI><A HREF="#Heading6">Listing 11.1. Using an integer array</A><A HREF="#Heading7">.</A>
			<LI><A HREF="#Heading8">Writing Past the End of an Array</A>
			<LI><A HREF="#Heading9">Listing 11.2. Writing past the end of an array</A><A HREF="#Heading10">.</A>
			<LI><A HREF="#Heading11">Fence Post Errors</A>
			<UL>
				<LI><A HREF="#Heading12">Figure 11.2.</A>
			</UL>
			<LI><A HREF="#Heading13">Initializing Arrays</A>
			<LI><A HREF="#Heading14">Declaring Arrays</A>
			<LI><A HREF="#Heading15">Listing 11.3. Using consts and enums in arrays</A><A HREF="#Heading16">.</A>
			<LI><A HREF="#Heading17">Arrays</A>
			<LI><A HREF="#Heading18">Arrays of Objects</A>
			<LI><A HREF="#Heading19">Listing 11.4. Creating an array of objects</A><A HREF="#Heading20">.</A>
			<LI><A HREF="#Heading21">Multidimensional Arrays</A>
			<UL>
				<LI><A HREF="#Heading22">Figure 11.3.</A>
			</UL>
			<LI><A HREF="#Heading23">Initializing Multidimensional Arrays</A>
			<LI><A HREF="#Heading24">Listing 11.5. Creating a multidimensional array</A><A HREF="#Heading25">.</A>
			<UL>
				<LI><A HREF="#Heading26">Figure 11.4.</A>
			</UL>
			<LI><A HREF="#Heading27">A Word About Memory</A>
			<LI><A HREF="#Heading28">Arrays of Pointers</A>
			<LI><A HREF="#Heading29">Listing 11.6. Storing an array on the free store</A><A HREF="#Heading30">.</A>
			<LI><A HREF="#Heading31">Declaring Arrays on the Free Store</A>
			<LI><A HREF="#Heading32">A Pointer to an Array Versus an Array of Pointers</A>
			<LI><A HREF="#Heading33">Pointers and Array Names</A>
			<LI><A HREF="#Heading34">Listing 11.7. Creating an array by using new</A><A HREF="#Heading35">.</A>
			<LI><A HREF="#Heading36">Deleting Arrays on the Free Store</A>
			<LI><A HREF="#Heading37">char Arrays</A>
			<LI><A HREF="#Heading38">Listing 11.8. Filling an array</A><A HREF="#Heading39">.</A>
			<LI><A HREF="#Heading40">Listing 11.9. Filling an array.</A>
			<LI><A HREF="#Heading41">strcpy() and strncpy()</A>
			<LI><A HREF="#Heading42">Listing 11.10. Using strcpy().</A>
			<LI><A HREF="#Heading43">Listing 11.11. Using strncpy().</A>
			<LI><A HREF="#Heading44">String Classes</A>
			<LI><A HREF="#Heading45">Listing 11.12. Using a String class</A><A HREF="#Heading46">.</A>
			<LI><A HREF="#Heading47">Linked Lists and Other Structures</A>
			<UL>
				<LI><A HREF="#Heading48">Figure 11.5.</A>
			</UL>
			<LI><A HREF="#Heading49">Listing 11.13. Implementing a linked list</A><A HREF="#Heading50">.</A>
			<UL>
				<LI><A HREF="#Heading51">Figure 11.6.</A>
			</UL>
			<LI><A HREF="#Heading52">Array Classes</A>
			<LI><A HREF="#Heading53">Summary</A>
			<LI><A HREF="#Heading54">Q&amp;A</A>
			<LI><A HREF="#Heading55">Workshop</A>
			<UL>
				<LI><A HREF="#Heading56">Quiz</A>
				<LI><A HREF="#Heading57">Exercises</A>
			</UL>
		</UL>
	</UL>
</UL>

<P>
<HR SIZE="4">

<H2 ALIGN="CENTER"><A NAME="Heading1"></A><FONT COLOR="#000077">Day 11</FONT></H2>
<H2 ALIGN="CENTER"><A NAME="Heading2"></A><FONT COLOR="#000077">Arrays</FONT></H2>
<P>In previous chapters, you declared a single <TT>int</TT>, <TT>char</TT>, or other
object. You often want to declare a collection of objects, such as 20 <TT>int</TT>s
or a litter of <TT>CAT</TT>s. Today, you learn

<UL>
	<LI>What arrays are and how to declare them.
	<P>
	<LI>What strings are and how to use character arrays to make them.
	<P>
	<LI>The relationship between arrays and pointers.
	<P>
	<LI>How to use pointer arithmetic with arrays.
</UL>

<H3 ALIGN="CENTER"><A NAME="Heading3"></A><FONT COLOR="#000077">What Is an Array?</FONT></H3>
<P>An array is a collection of data storage locations, each of which holds the same
type of data. Each storage location is called an element of the array.</P>
<P>You declare an array by writing the type, followed by the array name and the subscript.
The subscript is the number of elements in the array, surrounded by square brackets.
For example,</P>
<PRE><FONT COLOR="#0066FF">long LongArray[25];
</FONT></PRE>
<P>declares an array of 25 <TT>long</TT> integers, named <TT>LongArray</TT>. When
the compiler sees this declaration, it sets aside enough memory to hold all 25 elements.
Because each <TT>long</TT> integer requires 4 bytes, this declaration sets aside
100 contiguous bytes of memory, as illustrated in Figure 11.1.<BR>
<BR>
<A NAME="Heading4"></A><A HREF="../art/ch11/11zcp01.jpg"><FONT COLOR="#000077">Figure
11.1.</FONT></A><FONT COLOR="#000077"><I> </I></FONT><I>Declaring an array.</I>
<H3 ALIGN="CENTER"><A NAME="Heading5"></A><FONT COLOR="#000077">Array Elements</FONT></H3>
<P>You access each of the array elements by referring to an offset from the array
name. Array elements are counted from zero. Therefore, the first array element is
<TT>arrayName[0]</TT>. In the <TT>LongArray</TT> example, <TT>LongArray[0]</TT> is
the first array element, <TT>LongArray[1]</TT> the second, and so forth.</P>
<P>This can be somewhat confusing. The array <TT>SomeArray[3]</TT> has three elements.
They are <TT>SomeArray[0]</TT>, <TT>SomeArray[1]</TT>, and <TT>SomeArray[2]</TT>.
More generally, <TT>SomeArray[n]</TT> has n elements that are numbered <TT>SomeArray[0]</TT>
through <TT>SomeArray[n-1]</TT>.</P>
<P>Therefore, <TT>LongArray[25]</TT> is numbered from <TT>LongArray[0]</TT> through
<TT>LongArray[24]</TT>. Listing 11.1 shows how to declare an array of five integers
and fill each with a value.</P>
<P><A NAME="Heading6"></A><FONT SIZE="4" COLOR="#000077"><B>Listing 11.1. Using an
integer array.</B></FONT></P>
<PRE><FONT COLOR="#0066FF">
1:     //Listing 11.1 - Arrays
2:     #include &lt;iostream.h&gt;
3:
4:     int main()
5:     {
6:        int myArray[5];
7:        int i;
8:        for ( i=0; i&lt;5; i++)  // 0-4
9:        {
10:           cout &lt;&lt; &quot;Value for myArray[&quot; &lt;&lt; i &lt;&lt; &quot;]: &quot;;
11:          cin &gt;&gt; myArray[i];
12:       }
13:       for (i = 0; i&lt;5; i++)
14:          cout &lt;&lt; i &lt;&lt; &quot;: &quot; &lt;&lt; myArray[i] &lt;&lt; &quot;\n&quot;;
15:     return 0;
<TT>16: }</TT>
Output: Value for myArray[0]:  3
Value for myArray[1]:  6
Value for myArray[2]:  9
Value for myArray[3]:  12
Value for myArray[4]:  15
0: 3
1: 6
2: 9
3: 12
4: 15
</FONT></PRE>
<P><FONT COLOR="#000077"><B>Analysis:</B></FONT><B> </B>Line 6 declares an array
called <TT>myArray</TT>, which holds five integer variables. Line 8 establishes a
loop that counts from 0 through 4, which is the proper set of offsets for a five-element
array. The user is prompted for a value, and that value is saved at the correct offset
into the array.<BR>
<BR>
The first value is saved at <TT>myArray[0]</TT>, the second at <TT>myArray[1]</TT>,
and so forth. The second <TT>for</TT> loop prints each value to the screen.


<BLOCKQUOTE>
	<P>
<HR>
<FONT COLOR="#000077"><B>NOTE:</B></FONT><B> </B>Arrays count from 0, not from 1.
	This is the cause of many bugs in programs written by C++ novices. Whenever you use
	an array, remember that an array with 10 elements counts from <TT>ArrayName[0]</TT>
	to <TT>ArrayName[9]</TT>. There is no <TT>ArrayName[10]</TT>. 
<HR>


</BLOCKQUOTE>

<H3 ALIGN="CENTER"><A NAME="Heading8"></A><FONT COLOR="#000077">Writing Past the
End of an Array</FONT></H3>
<P>When you write a value to an element in an array, the compiler computes where
to store the value based on the size of each element and the subscript. Suppose that
you ask to write over the value at <TT>LongArray[5]</TT>, which is the sixth element.
The compiler multiplies the offset (5) by the size of each element--in this case,
4. It then moves that many bytes (20) from the beginning of the array and writes
the new value at that location.</P>
<P>If you ask to write at <TT>LongArray[50]</TT>, the compiler ignores the fact that
there is no such element. It computes how far past the first element it should look
(200 bytes) and then writes over whatever is at that location. This can be virtually
any data, and writing your new value there might have unpredictable results. If you're
lucky, your program will crash immediately. If you're unlucky, you'll get strange
results much later in your program, and you'll have a difficult time figuring out
what went wrong.</P>
<P>The compiler is like a blind man pacing off the distance from a house. He starts
out at the first house, <TT>MainStreet[0]</TT>. When you ask him to go to the sixth
house on Main Street, he says to himself, &quot;I must go five more houses. Each
house is four big paces. I must go an additional 20 steps.&quot; If you ask him to
go to <TT>MainStreet[100]</TT>, and Main Street is only 25 houses long, he will pace
off 400 steps. Long before he gets there, he will, no doubt, step in front of a moving
bus. So be careful where you send him.</P>
<P>Listing 11.2 shows what happens when you write past the end of an array.


<BLOCKQUOTE>
	<P>
<HR>
<FONT COLOR="#000077"><B>WARNING:</B></FONT><B> </B>Do not run this program; it may
	crash your system! 
<HR>


</BLOCKQUOTE>

<P><A NAME="Heading9"></A><FONT SIZE="4" COLOR="#000077"><B>Listing 11.2. Writing
past the end of an array.</B></FONT></P>
<PRE><FONT COLOR="#0066FF">
1:     //Listing 11.2
2:     // Demonstrates what happens when you write past the end
3:     // of an array
4:
5:     #include &lt;iostream.h&gt;
6:     int main()
7:     {
8:        // sentinels
9:        long sentinelOne[3];
10:       long TargetArray[25]; // array to fill
11:       long sentinelTwo[3];
12:       int i;
13:       for (i=0; i&lt;3; i++)
14:          sentinelOne[i] = sentinelTwo[i] = 0;
15:
16:       for (i=0; i&lt;25; i++)
17:          TargetArray[i] = 0;
18:
19:       cout &lt;&lt; &quot;Test 1: \n&quot;;  // test current values (should be 0)
20:       cout &lt;&lt; &quot;TargetArray[0]: &quot; &lt;&lt; TargetArray[0] &lt;&lt; &quot;\n&quot;;
21:       cout &lt;&lt; &quot;TargetArray[24]: &quot; &lt;&lt; TargetArray[24] &lt;&lt; &quot;\n\n&quot;;
22:
23:       for (i = 0; i&lt;3; i++)
24:       {
25:          cout &lt;&lt; &quot;sentinelOne[&quot; &lt;&lt; i &lt;&lt; &quot;]: &quot;;
26:          cout &lt;&lt; sentinelOne[i] &lt;&lt; &quot;\n&quot;;
27:          cout &lt;&lt; &quot;sentinelTwo[&quot; &lt;&lt; i &lt;&lt; &quot;]: &quot;;
28:           cout &lt;&lt; sentinelTwo[i]&lt;&lt; &quot;\n&quot;;
29:       }
30:
31:       cout &lt;&lt; &quot;\nAssigning...&quot;;
32:       for (i = 0; i&lt;=25; i++)
33:          TargetArray[i] = 20;
34:
35:       cout &lt;&lt; &quot;\nTest 2: \n&quot;;
36:       cout &lt;&lt; &quot;TargetArray[0]: &quot; &lt;&lt; TargetArray[0] &lt;&lt; &quot;\n&quot;;
37:       cout &lt;&lt; &quot;TargetArray[24]: &quot; &lt;&lt; TargetArray[24] &lt;&lt; &quot;\n&quot;;
38:       cout &lt;&lt; &quot;TargetArray[25]: &quot; &lt;&lt; TargetArray[25] &lt;&lt; &quot;\n\n&quot;;
39:       for (i = 0; i&lt;3; i++)
40:       {
41:          cout &lt;&lt; &quot;sentinelOne[&quot; &lt;&lt; i &lt;&lt; &quot;]: &quot;;
42:          cout &lt;&lt; sentinelOne[i]&lt;&lt; &quot;\n&quot;;
43:          cout &lt;&lt; &quot;sentinelTwo[&quot; &lt;&lt; i &lt;&lt; &quot;]: &quot;;
44:          cout &lt;&lt; sentinelTwo[i]&lt;&lt; &quot;\n&quot;;
45:       }
46:
47:     return 0;
<TT>48: }</TT></FONT>
<FONT COLOR="#0066FF">
Output: Test 1:
TargetArray[0]: 0
TargetArray[24]: 0

SentinelOne[0]: 0
SentinelTwo[0]: 0
SentinelOne[1]: 0
SentinelTwo[1]: 0
SentinelOne[2]: 0
SentinelTwo[2]: 0

Assigning...
Test 2:
TargetArray[0]: 20
TargetArray[24]: 20
TargetArray[25]: 20

SentinelOne[0]: 20
SentinelTwo[0]: 0
SentinelOne[1]: 0
SentinelTwo[1]: 0
SentinelOne[2]: 0
SentinelTwo[2]: 0
</FONT></PRE>
<P><FONT COLOR="#000077"><B>Analysis: </B></FONT>Lines 9 and 10 declare two arrays
of three integers that act as sentinels around <TT>TargetArray</TT>. These sentinel
arrays are initialized with the value <TT>0</TT>. If memory is written to beyond
the end of <TT>TargetArray</TT>, the sentinels are likely to be changed. Some compilers
count down in memory; others count up. For this reason, the sentinels are placed
on both sides of <TT>TargetArray</TT>.<BR>
<BR>
Lines 19-29 confirm the sentinel values in Test 1. In line 33 <TT>TargetArray</TT>'s
members are all initialized to the value <TT>20</TT>, but the counter counts to <TT>TargetArray</TT>
offset 25, which doesn't exist in <TT>TargetArray</TT>.</P>
<P>Lines 36-38 print <TT>TargetArray</TT>'s values in Test 2. Note that <TT>TargetArray[25]</TT>
is perfectly happy to print the value <TT>20</TT>. However, when <TT>SentinelOne</TT>
and <TT>SentinelTwo</TT> are printed, <TT>SentinelTwo[0]</TT> reveals that its value
has changed. This is because the memory that is 25 elements after <TT>TargetArray[0]</TT>
is the same memory that is at <TT>SentinelTwo[0]</TT>. When the nonexistent <TT>TargetArray[0]</TT>
was accessed, what was actually accessed was <TT>SentinelTwo[0]</TT>.</P>
<P>This nasty bug can be very hard to find, because <TT>SentinelTwo[0]</TT>'s value
was changed in a part of the code that was not writing to <TT>SentinelTwo</TT> at
all.</P>
<P>This code uses &quot;magic numbers&quot; such as 3 for the size of the sentinel
arrays and 25 for the size of <TT>TargetArray</TT>. It is safer to use constants,
so that you can change all these values in one place.
<H3 ALIGN="CENTER"><A NAME="Heading11"></A><FONT COLOR="#000077">Fence Post Errors</FONT></H3>
<P>It is so common to write to one past the end of an array that this bug has its
own name. It is called a fence post error. This refers to the problem in counting
how many fence posts you need for a 10-foot fence if you need one post for every
foot. Most people answer 10, but of course you need 11. Figure 11.2 makes this clear.<BR>
<BR>
<A NAME="Heading12"></A><A HREF="../art/ch11/11zcp02.jpg"><FONT COLOR="#000077">Figure
11.2.</FONT></A><FONT COLOR="#000077"> </FONT><I>Fence post errors.</I> <BR>
<BR>
This sort of &quot;off by one&quot; counting can be the bane of any programmer's
life. Over time, however, you'll get used to the idea that a 25-element array counts
only to element 24, and that everything counts from 0. (Programmers are often confused
why office buildings don't have a floor zero. Indeed, some have been known to push
the 4 elevator button when they want to get to the fifth floor.)


<BLOCKQUOTE>
	<P>
<HR>
<FONT COLOR="#000077"><B>NOTE:</B></FONT><B> </B>Some programmers refer to <TT>ArrayName[0]</TT>
	as the zeroth element. Getting into this habit is a big mistake. If <TT>ArrayName[0]</TT>
	is the zeroth element, what is <TT>ArrayName[1]</TT>? The oneth? If so, when you
	see <TT>ArrayName[24]</TT>, will you realize that it is not the 24th element, but
	rather the 25th? It is far better to say that <TT>ArrayName[0]</TT> is at offset
	zero and is the first element. 
<HR>


</BLOCKQUOTE>

<H3 ALIGN="CENTER"><A NAME="Heading13"></A><FONT COLOR="#000077">Initializing Arrays</FONT></H3>
<P>You can initialize a simple array of built-in types, such as integers and characters,
when you first declare the array. After the array name, you put an equal sign (<TT>=</TT>)
and a list of comma-separated values enclosed in braces. For example,</P>
<PRE><FONT COLOR="#0066FF">int IntegerArray[5] = { 10, 20, 30, 40, 50 };
</FONT></PRE>
<P>declares <TT>IntegerArray</TT> to be an array of five integers. It assigns <TT>IntegerArray[0]</TT>
the value <TT>10</TT>, <TT>IntegerArray[1]</TT> the value <TT>20</TT>, and so forth.</P>
<P>If you omit the size of the array, an array just big enough to hold the initialization
is created. Therefore, if you write</P>
<PRE><FONT COLOR="#0066FF">int IntegerArray[] = { 10, 20, 30, 40, 50 };
</FONT></PRE>
<P>you will create exactly the same array as you did in the previous example.</P>
<P>If you need to know the size of the array, you can ask the compiler to compute
it for you. For example,</P>
<PRE><FONT COLOR="#0066FF">const USHORT IntegerArrayLength;
IntegerArrayLength = sizeof(IntegerArray)/sizeof(IntegerArray[0]);
</FONT></PRE>
<P>sets the constant <TT>USHORT</TT> variable <TT>IntegerArrayLength</TT> to the
result obtained from dividing the size of the entire array by the size of each individual
entry in the array. That quotient is the number of members in the array.</P>
<P>You cannot initialize more elements than you've declared for the array. Therefore,</P>
<PRE><FONT COLOR="#0066FF">int IntegerArray[5] = { 10, 20, 30, 40, 50, 60};
</FONT></PRE>
<P>generates a compiler error because you've declared a five-member array and initialized
six values. It is legal, however, to write</P>
<PRE><FONT COLOR="#0066FF">int IntegerArray[5] = { 10, 20};
</FONT></PRE>
<P>Although uninitialized array members have no guaranteed values, actually, aggregates
will be initialized to <TT>0</TT>. If you don't initialize an array member, its value
will be set to <TT>0</TT>.


<BLOCKQUOTE>
	<P>
<HR>
<B>DO</B> let the compiler set the size of initialized arrays. <B>DON'T</B> write
	past the end of the array. <B>DO</B> give arrays meaningful names, as you would with
	any variable.<B>DO</B> remember that the first member of the array is at offset 0.
	
<HR>


</BLOCKQUOTE>

<H3 ALIGN="CENTER"><A NAME="Heading14"></A><FONT COLOR="#000077">Declaring Arrays</FONT></H3>
<P>Arrays can have any legal variable name, but they cannot have the same name as
another variable or array within their scope. Therefore, you cannot have an array
named <TT>myCats[5]</TT> and a variable named <TT>myCats</TT> at the same time.</P>
<P>You can dimension the array size with a <TT>const</TT> or with an enumeration.
Listing 11.3 illustrates this.</P>
<P><A NAME="Heading15"></A><FONT SIZE="4" COLOR="#000077"><B>Listing 11.3. Using
consts and enums in arrays.</B></FONT></P>
<PRE><FONT COLOR="#0066FF">1:     // Listing 11.3
2:     // Dimensioning arrays with consts and enumerations
3:
4:     #include &lt;iostream.h&gt;
5:     int main()
6:     {
7:        enum WeekDays { Sun, Mon, Tue, 
8:             Wed, Thu, Fri, Sat, DaysInWeek };
9:        int ArrayWeek[DaysInWeek] = { 10, 20, 30, 40, 50, 60, 70 };
10:
11:       cout &lt;&lt; &quot;The value at Tuesday is: &quot; &lt;&lt; ArrayWeek[Tue];
12:     return 0;
<TT>13: }</TT>
Output: The value at Tuesday is: 30
</FONT></PRE>
<P><FONT COLOR="#000077"><B>Analysis:</B></FONT><B> </B>Line 7 creates an enumeration
called <TT>WeekDays</TT>. It has eight members. Sunday is equal to 0, and <TT>DaysInWeek</TT>
is equal to 7.<BR>
<BR>
Line 11 uses the enumerated constant <TT>Tue</TT> as an offset into the array. Because
<TT>Tue</TT> evaluates to <TT>2</TT>, the third element of the array, <TT>DaysInWeek[2]</TT>,
is returned and printed in line 11.
<H3 ALIGN="CENTER"><A NAME="Heading17"></A><FONT COLOR="#000077">Arrays</FONT></H3>
<P>To declare an array, write the type of object stored, followed by the name of
the array and a subscript with the number of objects to be held in the array. Example
1</P>
<PRE><FONT COLOR="#0066FF">int MyIntegerArray[90];
</FONT></PRE>
<P>Example 2</P>
<PRE><FONT COLOR="#0066FF">long * ArrayOfPointersToLongs[100];
</FONT></PRE>
<P>To access members of the array, use the subscript operator. Example 1</P>
<PRE><FONT COLOR="#0066FF">int theNinethInteger = MyIntegerArray[8];
</FONT></PRE>
<P>Example 2</P>
<PRE><FONT COLOR="#0066FF">long * pLong = ArrayOfPointersToLongs[8]
</FONT></PRE>
<P>Arrays count from zero. An array of n items is numbered from 0 to n-1.
<H3 ALIGN="CENTER"><A NAME="Heading18"></A><FONT COLOR="#000077">Arrays of Objects</FONT></H3>
<P>Any object, whether built-in or user-defined, can be stored in an array. When
you declare the array, you tell the compiler the type of object to store and the
number of objects for which to allocate room. The compiler knows how much room is
needed for each object based on the class declaration. The class must have a default
constructor that takes no arguments so that the objects can be created when the array
is defined.</P>
<P>Accessing member data in an array of objects is a two-step process. You identify
the member of the array by using the index operator (<TT>[ ]</TT>), and then you
add the member operator (<TT>.</TT>) to access the particular member variable. Listing
11.4 demonstrates how you would create an array of five <TT>CAT</TT>s.</P>
<P><A NAME="Heading19"></A><FONT SIZE="4" COLOR="#000077"><B>Listing 11.4. Creating
an array of objects.</B></FONT></P>
<PRE><FONT COLOR="#0066FF">
1:     // Listing 11.4 - An array of objects
2:
3:     #include &lt;iostream.h&gt;
4:
5:     class CAT
6:     {
7:        public:
8:           CAT() { itsAge = 1; itsWeight=5; } 
9:           ~CAT() {}        
10:          int GetAge() const { return itsAge; }
11:          int GetWeight() const { return itsWeight; }
12:          void SetAge(int age) { itsAge = age; }
13:
14:       private:
15:          int itsAge;
16:          int itsWeight;
17:    };
18:
19:    int main()
20:    {
21:       CAT Litter[5];
22:       int i;
23:       for (i = 0; i &lt; 5; i++)
24:          Litter[i].SetAge(2*i +1);
25:
26:       for (i = 0; i &lt; 5; i++)
27:       {
28:          cout &lt;&lt; &quot;Cat #&quot; &lt;&lt; i+1&lt;&lt; &quot;: &quot;;
29:          cout &lt;&lt; Litter[i].GetAge() &lt;&lt; endl;
30:       }
31:     return 0;
<TT>32: }</TT>

Output: cat #1: 1
cat #2: 3
cat #3: 5
cat #4: 7
cat #5: 9
</FONT></PRE>
<P><FONT COLOR="#000077"><B>Analysis</B></FONT><B>: </B>Lines 5-17 declare the <TT>CAT</TT>
class. The <TT>CAT</TT> class must have a default constructor so that <TT>CAT</TT>
objects can be created in an array. Remember that if you create any other constructor,
the compiler-supplied default constructor is not created; you must create your own.<BR>
<BR>
The first <TT>for</TT> loop (lines 23 and 24) sets the age of each of the five <TT>CAT</TT>s
in the array. The second <TT>for</TT> loop (lines 26 and 27) accesses each member
of the array and calls <TT>GetAge()</TT>.</P>
<P>Each individual <TT>CAT</TT>'s <TT>GetAge()</TT> method is called by accessing
the member in the array, <TT>Litter[i]</TT>, followed by the dot operator (<TT>.</TT>),
and the member function.
<H3 ALIGN="CENTER"><A NAME="Heading21"></A><FONT COLOR="#000077">Multidimensional
Arrays</FONT></H3>
<P>It is possible to have arrays of more than one dimension. Each dimension is represented
as a subscript in the array. Therefore, a two-dimensional array has two subscripts;
a three-dimensional array has three subscripts; and so on. Arrays can have any number
of dimensions, although it is likely that most of the arrays you create will be of
one or two dimensions.</P>
<P>A good example of a two-dimensional array is a chess board. One dimension represents
the eight rows; the other dimension represents the eight columns. Figure 11.3 illustrates
this idea.</P>
<P>Suppose that you have a class named <TT>SQUARE</TT>. The declaration of an array
named <TT>Board</TT> that represents it would be</P>
<PRE><FONT COLOR="#0066FF">SQUARE Board[8][8];
</FONT></PRE>
<P>You could also represent the same data with a one-dimensional, 64-square array.
For example,</P>
<PRE><FONT COLOR="#0066FF">SQUARE Board[64]
</FONT></PRE>
<P>This doesn't correspond as closely to the real-world object as the two-dimension.
When the game begins, the king is located in the fourth position in the first row.
Counting from zero array, that position corresponds to</P>
<PRE><FONT COLOR="#0066FF">Board[0][3];
</FONT></PRE>
<P>assuming that the first subscript corresponds to <TT>row</TT>, and the second
to <TT>column</TT>. The layout of positions for the entire board is illustrated in
Figure 11.3.<BR>
<BR>
<A NAME="Heading22"></A><A HREF="../art/ch11/11zcp03.jpg"><FONT COLOR="#000077">Figure
11.3.</FONT></A><FONT COLOR="#000077"><I> </I></FONT><I>A chess board and a two-dimensional
array.</I>
<H3 ALIGN="CENTER"><A NAME="Heading23"></A><FONT COLOR="#000077">Initializing Multidimensional
Arrays</FONT></H3>
<P>You can initialize multidimensional arrays. You assign the list of values to array
elements in order, with the last array subscript changing while each of the former
holds steady. Therefore, if you have an array</P>
<PRE><FONT COLOR="#0066FF">int theArray[5][3]
</FONT></PRE>
<P>the first three elements go into <TT>theArray[0]</TT>; the next three into <TT>theArray[1]</TT>;
and so forth.</P>
<P>You initialize this array by writing</P>
<PRE><FONT COLOR="#0066FF">int theArray[5][3] = { 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 }
</FONT></PRE>
<P>For the sake of clarity, you could group the initializations with braces. For
example,</P>
<PRE><FONT COLOR="#0066FF">int theArray[5][3] = {  {1,2,3},
{4,5,6},
{7,8,9},
{10,11,12},
{13,14,15} };
</FONT></PRE>
<P>The compiler ignores the inner braces, which make it easier to understand how
the numbers are distributed.</P>
<P>Each value must be separated by a comma, without regard to the braces. The entire
initialization set must be within braces, and it must end with a semicolon.</P>
<P>Listing 11.5 creates a two-dimensional array. The first dimension is the set of
numbers from 0 to 5. The second dimension consists of the double of each value in
the first dimension.</P>
<P><A NAME="Heading24"></A><FONT SIZE="4" COLOR="#000077"><B>Listing 11.5. Creating
a multidimensional array.</B></FONT></P>
<PRE><FONT COLOR="#0066FF">
1:     #include &lt;iostream.h&gt;
2:     int main()
3:     {
4:        int SomeArray[5][2] = { {0,0}, {1,2}, {2,4}, {3,6}, {4,8}};
5:        for (int i = 0; i&lt;5; i++)
6:           for (int j=0; j&lt;2; j++)
7:           {
8:              cout &lt;&lt; &quot;SomeArray[&quot; &lt;&lt; i &lt;&lt; &quot;][&quot; &lt;&lt; j &lt;&lt; &quot;]: &quot;;
9:              cout &lt;&lt; SomeArray[i][j]&lt;&lt; endl;
10:          }
11:
12:     return 0;
<TT>13: }</TT></FONT>
<FONT COLOR="#0066FF">
Output: SomeArray[0][0]: 0
SomeArray[0][1]: 0
SomeArray[1][0]: 1
SomeArray[1][1]: 2
SomeArray[2][0]: 2
SomeArray[2][1]: 4
SomeArray[3][0]: 3
SomeArray[3][1]: 6
SomeArray[4][0]: 4
SomeArray[4][1]: 8
</FONT></PRE>
<P><FONT COLOR="#0000AA"><B>Analysis:</B></FONT><B> </B>Line 4 declares <TT>SomeArray</TT>
to be a two-dimensional array. The first dimension consists of five integers; the
second dimension consists of two integers. This creates a 5x2 grid, as Figure 11.4
shows. <BR>
<A HREF="../art/ch11/11zcp04.jpg"><BR>
</A><A NAME="Heading26"></A><A HREF="../art/ch11/11zcp04.jpg"><FONT COLOR="#000077">Figure
11.4.</FONT></A><FONT COLOR="#000077"> </FONT><I>A 5x2 array. </I><BR>
<BR>
The values are initialized in pairs, although they could be computed as well. Lines
5 and 6 create a nested <TT>for</TT> loop. The outer <TT>for</TT> loop ticks through
each member of the first dimension. For every member in that dimension, the inner
<TT>for</TT> loop ticks through each member of the second dimension. This is consistent
with the printout. <TT>SomeArray[0][0]</TT> is followed by <TT>SomeArray[0][1]</TT>.
The first dimension is incremented only after the second dimension is incremented
by 1. Then the second dimension starts over.
<H3 ALIGN="CENTER"><A NAME="Heading27"></A><FONT COLOR="#000077">A Word About Memory</FONT></H3>
<P>When you declare an array, you tell the compiler exactly how many objects you
expect to store in it. The compiler sets aside memory for all the objects, even if
you never use it. This isn't a problem with arrays for which you have a good idea
of how many objects you'll need. For example, a chess board has 64 squares, and cats
have between 1 and 10 kittens. When you have no idea of how many objects you'll need,
however, you must use more advanced data structures.</P>
<P>This book looks at arrays of pointers, arrays built on the free store, and various
other collections. Other more advanced data structures that solve large data storage
problems are beyond the scope of this book. Two of the great things about programming
are that there are always more things to learn and that there are always more books
from which to learn.
<H3 ALIGN="CENTER"><A NAME="Heading28"></A><FONT COLOR="#000077">Arrays of Pointers</FONT></H3>
<P>The arrays discussed so far store all their members on the stack. Usually stack
memory is severely limited, whereas free store memory is far larger. It is possible
to declare each object on the free store and then to store only a pointer to the
object in the array. This dramatically reduces the amount of stack memory used. Listing
11.6 rewrites the array from Listing 11.4, but it stores all the objects on the free
store. As an indication of the greater memory that this enables, the array is expanded
from 5 to 500, and the name is changed from <TT>Litter</TT> to <TT>Family</TT>.</P>
<P><A NAME="Heading29"></A><FONT SIZE="4" COLOR="#000077"><B>Listing 11.6. Storing
an array on the free store.</B></FONT></P>
<PRE><FONT COLOR="#0066FF">
1:     // Listing 11.6 - An array of pointers to objects
2:
3:     #include &lt;iostream.h&gt;
4:
5:     class CAT
6:     {
7:        public:
8:           CAT() { itsAge = 1; itsWeight=5; }   
9:           ~CAT() {}                                 // destructor
10:          int GetAge() const { return itsAge; }
11:          int GetWeight() const { return itsWeight; }
12:          void SetAge(int age) { itsAge = age; }
13:
14:       private:
15:          int itsAge;
16:          int itsWeight;
17:    };
18:
19:    int main()
20:    {
21:       CAT * Family[500];
22:       int i;
23:       CAT * pCat;
24:       for (i = 0; i &lt; 500; i++)
25:       {
26:          pCat = new CAT;
27:          pCat-&gt;SetAge(2*i +1);
28:          Family[i] = pCat;
29:       }
30:
31:       for (i = 0; i &lt; 500; i++)
32:       {
33:          cout &lt;&lt; &quot;Cat #&quot; &lt;&lt; i+1 &lt;&lt; &quot;: &quot;;
34:          cout &lt;&lt; Family[i]-&gt;GetAge() &lt;&lt; endl;
35:       }
36:     return 0;
<TT>37: }</TT></FONT>
<FONT COLOR="#0066FF">
Output: Cat #1: 1
Cat #2: 3
Cat #3: 5
...
Cat #499: 997
Cat #500: 999</FONT></PRE>

<DL>
	<DD><FONT COLOR="#0066FF"></FONT>
</DL>

<P><FONT COLOR="#000077"><B>Analysis:</B></FONT><B> </B>The <TT>CAT</TT> object declared
in lines 5-17 is identical with the <TT>CAT</TT> object declared in Listing 11.4.
This time, however, the array declared in line 21 is named <TT>Family</TT>, and it
is declared to hold 500 pointers to <TT>CAT</TT> objects.</P>
<P>In the initial loop (lines 24-29), 500 new <TT>CAT</TT> objects are created on
the free store, and each one has its age set to twice the index plus one. Therefore,
the first <TT>CAT</TT> is set to <TT>1</TT>, the second <TT>CAT</TT> to <TT>3</TT>,
the third <TT>CAT</TT> to <TT>5</TT>, and so on. Finally, the pointer is added to
the array.</P>
<P>Because the array has been declared to hold pointers, the pointer--rather than
the dereferenced value in the pointer--is added to the array.</P>
<P>The second loop (lines 31 and 32) prints each of the values. The pointer is accessed
by using the index, <TT>Family[i]</TT>. That address is then used to access the <TT>GetAge()</TT>
method.</P>
<P>In this example, the array <TT>Family</TT> and all its pointers are stored on
the stack, but the 500 <TT>CAT</TT>s that are created are stored on the free store.
<H3 ALIGN="CENTER"><A NAME="Heading31"></A><FONT COLOR="#000077">Declaring Arrays
on the Free Store</FONT></H3>
<P>It is possible to put the entire array on the free store, also known as the heap.
You do this by calling <TT>new</TT> and using the subscript operator. The result
is a pointer to an area on the free store that holds the array. For example,</P>
<PRE><FONT COLOR="#0066FF">CAT *Family = new CAT[500];
</FONT></PRE>
<P>declares <TT>Family</TT> to be a pointer to the first in an array of 500 <TT>CAT</TT>s.
In other words, <TT>Family</TT> points to--or has the address of--<TT>Family[0]</TT>.</P>
<P>The advantage of using <TT>Family</TT> in this way is that you can use pointer
arithmetic to access each member of <TT>Family</TT>. For example, you can write</P>
<PRE><FONT COLOR="#0066FF">CAT *Family = new CAT[500];
CAT *pCat = Family;              //pCat points to Family[0]
pCat-&gt;SetAge(10);                // set Family[0] to 10
pCat++;                          // advance to Family[1]
pCat-&gt;SetAge(20);                // set Family[1] to 20
</FONT></PRE>
<P>This declares a new array of 500 <TT>CAT</TT>s and a pointer to point to the start
of the array. Using that pointer, the first <TT>CAT</TT>'s <TT>SetAge()</TT> function
is called with a value of <TT>10</TT>. The pointer is then incremented to point to
the next <TT>CAT</TT>, and the second <TT>Cat</TT>'s <TT>SetAge()</TT> method is
then called.
<H3 ALIGN="CENTER"><A NAME="Heading32"></A><FONT COLOR="#000077">A Pointer to an
Array Versus an Array of Pointers</FONT></H3>
<P>Examine these three declarations:</P>
<PRE><FONT COLOR="#0066FF">1:  Cat   FamilyOne[500]
2:  CAT * FamilyTwo[500];
3:  CAT * FamilyThree = new CAT[500];
</FONT></PRE>
<P><TT>FamilyOne</TT> is an array of 500 <TT>CAT</TT>s. <TT>FamilyTwo</TT> is an
array of 500 pointers to <TT>CAT</TT>s. <TT>FamilyThree</TT> is a pointer to an array
of 500 <TT>CAT</TT>s.</P>
<P>The differences among these three code lines dramatically affect how these arrays
operate. What is perhaps even more surprising is that <TT>FamilyThree</TT> is a variant
of <TT>FamilyOne</TT>, but is very different from <TT>FamilyTwo</TT>.</P>
<P>This raises the thorny issue of how pointers relate to arrays. In the third case,
<TT>FamilyThree</TT> is a pointer to an array. That is, the address in <TT>FamilyThree</TT>
is the address of the first item in that array. This is exactly the case for <TT>FamilyOne</TT>.
<H3 ALIGN="CENTER"><A NAME="Heading33"></A><FONT COLOR="#000077">Pointers and Array
Names</FONT></H3>
<P>In C++ an array name is a constant pointer to the first element of the array.
Therefore, in the declaration</P>
<PRE><FONT COLOR="#0066FF">CAT Family[50];
</FONT></PRE>
<P><TT>Family</TT> is a pointer to <TT>&amp;Family[0]</TT>, which is the address
of the first element of the array <TT>Family</TT>.</P>
<P>It is legal to use array names as constant pointers, and vice versa. Therefore,
<TT>Family + 4</TT> is a legitimate way of accessing the data at <TT>Family[4]</TT>.</P>
<P>The compiler does all the arithmetic when you add to, increment, and decrement
pointers. The address accessed when you write <TT>Family + 4</TT> isn't 4 bytes past
the address of <TT>Family</TT>--it is four objects. If each object is 4 bytes long,
<TT>Family + 4</TT> is 16 bytes. If each object is a <TT>CAT</TT> that has four <TT>long</TT>
member variables of 4 bytes each and two <TT>short</TT> member variables of 2 bytes
each, each <TT>CAT</TT> is 20 bytes, and <TT>Family + 4</TT> is 80 bytes past the
start of the array.</P>
<P>Listing 11.7 illustrates declaring and using an array on the free store.</P>
<P><A NAME="Heading34"></A><FONT SIZE="4" COLOR="#000077"><B>Listing 11.7. Creating
an array by using new.</B></FONT></P>
<PRE><FONT COLOR="#0066FF">
1:     // Listing 11.7 - An array on the free store
2:
3:     #include &lt;iostream.h&gt;
4:
5:     class CAT
6:     {
7:        public:
8:           CAT() { itsAge = 1; itsWeight=5; } 
9:           ~CAT();         
10:          int GetAge() const { return itsAge; }
11:          int GetWeight() const { return itsWeight; }
12:          void SetAge(int age) { itsAge = age; }
13:
14:       private:
15:          int itsAge;
16:          int itsWeight;
17:    };
18:
19:    CAT :: ~CAT()
20:    {
21:      // cout &lt;&lt; &quot;Destructor called!\n&quot;;
22:    }
23:
24:    int main()
25:    {
26:       CAT * Family = new CAT[500];
27:       int i;
28:       CAT * pCat;
29:       for (i = 0; i &lt; 500; i++)
30:       {
31:          pCat = new CAT;
32:          pCat-&gt;SetAge(2*i +1);
33:          Family[i] = *pCat;
34:          delete pCat;
35:       }
36:
37:       for (i = 0; i &lt; 500; i++)
38:       {
38:          cout &lt;&lt; &quot;Cat #&quot; &lt;&lt; i+1 &lt;&lt; &quot;: &quot;;
39:          cout &lt;&lt; Family[i].GetAge() &lt;&lt; endl;
40:       }
41:
42:       delete [] Family;
43:
44:     return 0;
<TT>45: }</TT></FONT>
<FONT COLOR="#0066FF">
Output: Cat #1: 1
Cat #2: 3
Cat #3: 5
...
Cat #499: 997
Cat #500: 999
</FONT></PRE>
<P><FONT COLOR="#000077"><B>Analysis:</B></FONT><B> </B>Line 26 declares the array
<TT>Family</TT>, which holds 500 <TT>CAT</TT> objects. The entire array is created
on the free store with the call to <TT>new</TT> <TT>CAT[500]</TT>.<BR>
<BR>
Each <TT>CAT</TT> object added to the array also is created on the free store (line
31). Note, however, that the pointer isn't added to the array this time; the object
itself is. This array isn't an array of pointers to <TT>CAT</TT>s. It is an array
of <TT>CAT</TT>s.
<H3 ALIGN="CENTER"><A NAME="Heading36"></A><FONT COLOR="#000077">Deleting Arrays
on the Free Store</FONT></H3>
<P><TT>Family</TT> is a pointer, a pointer to the array on the free store. When,
on line 33, the pointer <TT>pCat</TT> is dereferenced, the <TT>CAT</TT> object itself
is stored in the array (why not? the array is on the free store). But <TT>pCat</TT>
is used again in the next iteration of the loop. Isn't there a danger that there
will now be no pointer to that <TT>CAT</TT> object, and a memory leak has been created?</P>
<P>This would be a big problem, except that deleting <TT>Family</TT> returns all
the memory set aside for the array. The compiler is smart enough to destroy each
object in the array and to return its memory to the free store.</P>
<P>To see this, change the size of the array from 500 to 10 in lines 26, 29, and
37. Then uncomment the <TT>cout</TT> statement in line 21. When line 40 is reached
and the array is destroyed, each <TT>CAT</TT> object destructor is called.</P>
<P>When you create an item on the heap by using <TT>new</TT>, you always delete that
item and free its memory with <TT>delete</TT>. Similarly, when you create an array
by using <TT>new &lt;class&gt;[size]</TT>, you delete that array and free all its
memory with <TT>delete[]</TT>. The brackets signal the compiler that this array is
being deleted.</P>
<P>If you leave the brackets off, only the first object in the array will be deleted.
You can prove this to yourself by removing the bracket on line 40. If you edited
line 21 so that the destructor prints, you should now see only one <TT>CAT</TT> object
destroyed. Congratulations! You just created a memory leak.


<BLOCKQUOTE>
	<P>
<HR>
<B>DO</B> remember that an array of n items is numbered from zero through n-1. <B>DON'T</B>
	write or read past the end of an array. <B>DON'T</B> confuse an array of pointers
	with a pointer to an array. <B>DO </B>use array indexing with pointers that point
	to arrays. 
<HR>


</BLOCKQUOTE>

<H3 ALIGN="CENTER"><A NAME="Heading37"></A><FONT COLOR="#000077">char Arrays</FONT></H3>
<P>A string is a series of characters. The only strings you've seen until now have
been unnamed string constants used in <TT>cout</TT> statements, such as</P>
<PRE><FONT COLOR="#0066FF">cout &lt;&lt; &quot;hello world.\n&quot;;
</FONT></PRE>
<P>In C++ a string is an array of <TT>char</TT>s ending with a null character. You
can declare and initialize a string just as you would any other array. For example,</P>
<PRE><FONT COLOR="#0066FF">char Greeting[] = 
{ `H', `e', `l', `l', `o', ` `, `W','o','r','l','d', `\0' };
</FONT></PRE>
<P>The last character, <TT>`\0'</TT>, is the null character, which many C++ functions
recognize as the terminator for a string. Although this character-by-character approach
works, it is difficult to type and admits too many opportunities for error. C++ enables
you to use a shorthand form of the previous line of code. It is</P>
<PRE><FONT COLOR="#0066FF">char Greeting[] = &quot;Hello World&quot;;
</FONT></PRE>
<P>You should note two things about this syntax:

<UL>
	<LI>Instead of single quoted characters separated by commas and surrounded by braces,
	you have a double-quoted string, no commas, and no braces.
	<P>
	<LI>You don't need to add the null character because the compiler adds it for you.
</UL>

<P>The string <TT>Hello World</TT> is 12 bytes. <TT>Hello</TT> is 5 bytes, the space
1, <TT>World</TT> 5, and the null character 1.</P>
<P>You can also create uninitialized character arrays. As with all arrays, it is
important to ensure that you don't put more into the buffer than there is room for.</P>
<P>Listing 11.8 demonstrates the use of an uninitialized buffer.</P>
<P><A NAME="Heading38"></A><FONT SIZE="4" COLOR="#000077"><B>Listing 11.8. Filling
an array.</B></FONT></P>
<PRE><FONT COLOR="#0066FF">1:     //Listing 11.8 char array buffers
2:
3:     #include &lt;iostream.h&gt;
4:
5:     int main()
6:     {
7:        char buffer[80];
8:        cout &lt;&lt; &quot;Enter the string: &quot;;
9:        cin &gt;&gt; buffer;
10:       cout &lt;&lt; &quot;Here's the buffer:  &quot; &lt;&lt; buffer &lt;&lt; endl;
11:     return 0;
<TT>12: }</TT></FONT>
<FONT COLOR="#0066FF">
Output: Enter the string: Hello World
Here's the buffer:  Hello
</FONT></PRE>
<P><FONT COLOR="#000077"><B>Analysis: </B></FONT>On line 7, a buffer is declared
to hold 80 characters. This is large enough to hold a 79-character string and a terminating
null character.<BR>
On line 8, the user is prompted to enter a string, which is entered into buffer on
line 9. It is the syntax of <TT>cin</TT> to write a terminating null to buffer after
it writes the string.</P>
<P>There are two problems with the program in Listing 11.8. First, if the user enters
more than 79 characters, <TT>cin</TT> writes past the end of the buffer. Second,
if the user enters a space, <TT>cin</TT> thinks that it is the end of the string,
and it stops writing to the buffer.</P>
<P>To solve theseproblems, you must call a special method on <TT>cin</TT>: <TT>get()</TT>.
<TT>cin.get()</TT> takes three parameters:

<DL>
	<DD>The buffer to fill<BR>
	<BR>
	The maximum number of characters to get<BR>
	<BR>
	The delimiter that terminates input
</DL>

<P><BR>
The default delimiter is <TT>newline</TT>. Listing 11.9 illustrates its use.</P>
<P><A NAME="Heading40"></A><FONT SIZE="4" COLOR="#000077"><B>Listing 11.9. Filling
an array.</B></FONT></P>
<PRE><FONT COLOR="#0066FF">
1:     //Listing 11.9 using cin.get()
2:
3:     #include &lt;iostream.h&gt;
4:
5:     int main()
6:     {
7:        char buffer[80];
8:        cout &lt;&lt; &quot;Enter the string: &quot;;
9:        cin.get(buffer, 79);       // get up to 79 or newline
10:       cout &lt;&lt; &quot;Here's the buffer:  &quot; &lt;&lt; buffer &lt;&lt; endl;
11:     return 0;
<TT>12: }</TT></FONT>
<FONT COLOR="#0066FF">
Output: Enter the string: Hello World
Here's the buffer:  Hello World
</FONT></PRE>
<P><FONT COLOR="#000077"><B>Analysis</B></FONT><B>: </B>Line 9 calls the method <TT>get()</TT>
of <TT>cin</TT>. The buffer declared in line 7 is passed in as the first argument.
The second argument is the maximum number of characters to get. In this case, it
must be 79 to allow for the terminating <TT>null</TT>. There is no need to provide
a terminating character because the default value of <TT>newline</TT> is sufficient.<BR>
<TT><BR>
cin</TT> and all its variations are covered on Day 17, &quot;The Preprocessor,&quot;
when streams are discussed in depth.
<H3 ALIGN="CENTER"><A NAME="Heading41"></A><FONT COLOR="#000077">strcpy() and strncpy()</FONT></H3>
<P>C++ inherits from C a library of functions for dealing with strings. Among the
many functions provided are two for copying one string into another: <TT>strcpy()</TT>
and <TT>strncpy()</TT>. <TT>strcpy()</TT> copies the entire contents of one string
into a designated buffer. Listing 11.10 demonstrates the use of <TT>strcpy()</TT>.</P>
<P><A NAME="Heading42"></A><FONT SIZE="4" COLOR="#000077"><B>Listing 11.10. Using
strcpy().</B></FONT></P>
<PRE><FONT COLOR="#0066FF">1:     #include &lt;iostream.h&gt;
2:     #include &lt;string.h&gt;
3:     int main()
4:     {
5:        char String1[] = &quot;No man is an island&quot;;
6:        char String2[80];
7:
8:        strcpy(String2,String1);
9:
10:       cout &lt;&lt; &quot;String1: &quot; &lt;&lt; String1 &lt;&lt; endl;
11:       cout &lt;&lt; &quot;String2: &quot; &lt;&lt; String2 &lt;&lt; endl;
12:     return 0;
<TT>13: }</TT></FONT>
<FONT COLOR="#0066FF">
Output: String1: No man is an island
String2: No man is an island
</FONT></PRE>
<P><FONT COLOR="#000077"><B>Analysis:</B></FONT><B> </B>The header file <TT>string.h</TT>
is included in line 2. This file contains the prototype of the <TT>strcpy()</TT>
function. <TT>strcpy()</TT> takes two character arrays--a destination followed by
a source. If the source were larger than the destination, <TT>strcpy()</TT> would
overwrite past the end of the buffer.<BR>
<BR>
To protect against this, the standard library also includes <TT>strncpy()</TT>. This
variation takes a maximum number of characters to copy. <TT>strncpy()</TT> copies
up to the first null character or the maximum number of characters specified into
the destination buffer.</P>
<P>Listing 11.11 illustrates the use of<TT> strncpy()</TT>.</P>
<P><A NAME="Heading43"></A><FONT SIZE="4" COLOR="#000077"><B>Listing 11.11. Using
strncpy().</B></FONT></P>
<PRE><FONT COLOR="#0066FF">1:     #include &lt;iostream.h&gt;
2:     #include &lt;string.h&gt;
3:     int main()
4:     {
5:        const int MaxLength = 80;
6:        char String1[] = &quot;No man is an island&quot;;
7:        char String2[MaxLength+1];
8:
9:
10:       strncpy(String2,String1,MaxLength);
11:
12:       cout &lt;&lt; &quot;String1: &quot; &lt;&lt; String1 &lt;&lt; endl;
13:       cout &lt;&lt; &quot;String2: &quot; &lt;&lt; String2 &lt;&lt; endl;
14:     return 0;
<TT>15: }</TT></FONT>
<FONT COLOR="#0066FF">
Output: String1: No man is an island
String2: No man is an island
</FONT></PRE>
<P><FONT COLOR="#000077"><B>Analysis:</B></FONT><B> </B>In line 10, the call to <TT>strcpy()</TT>
has been changed to a call to <TT>strncpy()</TT>, which takes a third parameter:
the maximum number of characters to copy. The buffer <TT>String2</TT> is declared
to take <TT>MaxLength+1</TT> characters. The extra character is for the null, which
both <TT>strcpy()</TT> and <TT>strncpy()</TT> automatically add to the end of the
string.
<H3 ALIGN="CENTER"><A NAME="Heading44"></A><FONT COLOR="#000077">String Classes</FONT></H3>
<P>Most C++ compilers come with a class library that includes a large set of classes
for data manipulation. A standard component of a class library is a <TT>String</TT>
class.</P>
<P>C++ inherited the null-terminated string and the library of functions that includes
<TT>strcpy()</TT> from C, but these functions aren't integrated into an object-oriented
framework. A <TT>String</TT> class provides an encapsulated set of data and functions
for manipulating that data, as well as accessor functions so that the data itself
is hidden from the clients of the <TT>String</TT> class.</P>
<P>If your compiler doesn't already provide a <TT>String</TT> class--and perhaps
even if it does--you might want to write your own. The remainder of this chapter
discusses the design and partial implementation of <TT>String</TT> classes.</P>
<P>At a minimum, a <TT>String</TT> class should overcome the basic limitations of
character arrays. Like all arrays, character arrays are static. You define how large
they are. They always take up that much room in memory even if you don't need it
all. Writing past the end of the array is disastrous.</P>
<P>A good <TT>String</TT> class allocates only as much memory as it needs, and always
enough to hold whatever it is given. If it can't allocate enough memory, it should
fail gracefully.</P>
<P>Listing 11.12 provides a first approximation of a <TT>String</TT> class.</P>
<P><A NAME="Heading45"></A><FONT SIZE="4" COLOR="#000077"><B>Listing 11.12. Using
a String class.</B></FONT></P>
<PRE><FONT COLOR="#0066FF">1:     //Listing 11.12
2:
3:     #include &lt;iostream.h&gt;
4:     #include &lt;string.h&gt;
5:
6:     // Rudimentary string class
7:     class String
8:     {
9:        public:
10:          // constructors
11:          String();
12:          String(const char *const);
13:          String(const String &amp;);
14:          ~String();
15:
16:          // overloaded operators
17:          char &amp; operator[](unsigned short offset);
18:          char operator[](unsigned short offset) const;
19:          String operator+(const String&amp;);
20:          void operator+=(const String&amp;);
21:          String &amp; operator= (const String &amp;);
22:
23:          // General accessors
24:          unsigned short GetLen()const { return itsLen; }
25:          const char * GetString() const { return itsString; }
26:
27:       private:
28:          String (unsigned short);         // private constructor
29:          char * itsString;
30:          unsigned short itsLen;
31:    };
32:
33:    // default constructor creates string of 0 bytes
34:    String::String()
35:    {
36:       itsString = new char[1];
37:       itsString[0] = `\0';
38:       itsLen=0;
39:    }
40:
41:    // private (helper) constructor, used only by
42:    // class methods for creating a new string of
43:    // required size. Null filled.
44:    String::String(unsigned short len)
45:    {
46:       itsString = new char[len+1];
47:       for (unsigned short i = 0; i&lt;=len; i++)
48:          itsString[i] = `\0';
49:       itsLen=len;
50:    }
51:
52:    // Converts a character array to a String
53:    String::String(const char * const cString)
54:    {
55:       itsLen = strlen(cString);
56:       itsString = new char[itsLen+1];
57:       for (unsigned short i = 0; i&lt;itsLen; i++)
58:          itsString[i] = cString[i];
59:       itsString[itsLen]='\0';
60:    }
61:
62:    // copy constructor
63:    String::String (const String &amp; rhs)
64:    {
65:       itsLen=rhs.GetLen();
66:       itsString = new char[itsLen+1];
67:       for (unsigned short i = 0; i&lt;itsLen;i++)
68:          itsString[i] = rhs[i];
69:       itsString[itsLen] = `\0';
70:    }
71:
72:    // destructor, frees allocated memory
73:    String::~String ()
74:    {
75:       delete [] itsString;
76:       itsLen = 0;
77:    }
78:
79:    // operator equals, frees existing memory
80:    // then copies string and size
81:    String&amp; String::operator=(const String &amp; rhs)
82:    {
83:       if (this == &amp;rhs)
84:          return *this;
85:       delete [] itsString;
86:       itsLen=rhs.GetLen();
87:       itsString = new char[itsLen+1];
88:       for (unsigned short i = 0; i&lt;itsLen;i++)
89:          itsString[i] = rhs[i];
90:       itsString[itsLen] = `\0';
91:       return *this;
92:    }
93:
94:    //nonconstant offset operator, returns
95:    // reference to character so it can be
96:    // changed!
97:    char &amp; String::operator[](unsigned short offset)
98:    {
99:       if (offset &gt; itsLen)
100:         return itsString[itsLen-1];
101:      else
102:         return itsString[offset];
103:   }
104:
105:   // constant offset operator for use
106:   // on const objects (see copy constructor!)
107:   char String::operator[](unsigned short offset) const
108:   {
109:      if (offset &gt; itsLen)
110:         return itsString[itsLen-1];
111:      else
112:         return itsString[offset];
113:   }
114:
115:   // creates a new string by adding current
116:   // string to rhs
117:   String String::operator+(const String&amp; rhs)
118:   {
119:      unsigned short  totalLen = itsLen + rhs.GetLen();
120:      String temp(totalLen);
121:      for (unsigned short i = 0; i&lt;itsLen; i++)
122:         temp[i] = itsString[i];
123:      for (unsigned short j = 0; j&lt;rhs.GetLen(); j++, i++)
124:         temp[i] = rhs[j];
125:      temp[totalLen]='\0';
126:      return temp;
127:   }
128:
129:   // changes current string, returns nothing
130:   void String::operator+=(const String&amp; rhs)
131:   {
132:      unsigned short rhsLen = rhs.GetLen();
133:      unsigned short totalLen = itsLen + rhsLen;
134:      String  temp(totalLen);
135:      for (unsigned short i = 0; i&lt;itsLen; i++)
136:         temp[i] = itsString[i];
137:      for (unsigned short j = 0; j&lt;rhs.GetLen(); j++, i++)
138:         temp[i] = rhs[i-itsLen];
139:      temp[totalLen]='\0';
140:      *this = temp;
141:   }
142:
143:   int main()
144:   {
145:      String s1(&quot;initial test&quot;);
146:      cout &lt;&lt; &quot;S1:\t&quot; &lt;&lt; s1.GetString() &lt;&lt; endl;
147:
148:      char * temp = &quot;Hello World&quot;;
149:      s1 = temp;
150:      cout &lt;&lt; &quot;S1:\t&quot; &lt;&lt; s1.GetString() &lt;&lt; endl;
151:
152:      char tempTwo[20];
153:      strcpy(tempTwo,&quot;; nice to be here!&quot;);
154:      s1 += tempTwo;
155:      cout &lt;&lt; &quot;tempTwo:\t&quot; &lt;&lt; tempTwo &lt;&lt; endl;
156:      cout &lt;&lt; &quot;S1:\t&quot; &lt;&lt; s1.GetString() &lt;&lt; endl;
157:
158:      cout &lt;&lt; &quot;S1[4]:\t&quot; &lt;&lt; s1[4] &lt;&lt; endl;
159:      s1[4]='x';
160:      cout &lt;&lt; &quot;S1:\t&quot; &lt;&lt; s1.GetString() &lt;&lt; endl;
161:
162:      cout &lt;&lt; &quot;S1[999]:\t&quot; &lt;&lt; s1[999] &lt;&lt; endl;
163:
164:      String s2(&quot; Another string&quot;);
165:      String s3;
166:      s3 = s1+s2;
167:      cout &lt;&lt; &quot;S3:\t&quot; &lt;&lt; s3.GetString() &lt;&lt; endl;
168:
169:      String s4;
170:      s4 = &quot;Why does this work?&quot;;
171:      cout &lt;&lt; &quot;S4:\t&quot; &lt;&lt; s4.GetString() &lt;&lt; endl;
172:     return 0;
<TT>173: }</TT></FONT>
<FONT COLOR="#0066FF">
Output: S1:        initial test
S1:        Hello world
tempTwo:           ; nice to be here!
S1:        Hello world; nice to be here!
S1[4]:     o
S1:        Hellx World; nice to be here!
S1[999]:           !
S3:        Hellx World; nice to be here! Another string
S4:        Why does this work?
</FONT></PRE>
<P><FONT COLOR="#000077"><B><BR>
Analysis:</B></FONT><B> </B>Lines 7-31 are the declaration of a simple <TT>String</TT>
class. Lines 11-13 contain three constructors: the default constructor, the copy
constructor, and a constructor that takes an existing null-terminated (C-style) string.<BR>
This <TT>String</TT> class overloads the offset operator (<TT>[ ]</TT>), operator
plus (<TT>+</TT>), and operator plus-equals (<TT>+=</TT>). The offset operator is
overloaded twice: once as a constant function returning a <TT>char</TT> and again
as a nonconstant function returning a reference to a <TT>char</TT>.</P>
<P>The nonconstant version is used in statements such as</P>
<PRE><FONT COLOR="#0066FF">SomeString[4]='x';</FONT></PRE>
<P>as seen in line 159. This enables direct access to each of the characters in the
string. A reference to the character is returned so that the calling function can
manipulate it.</P>
<P>The constant version is used when a constant <TT>String</TT> object is being accessed,
such as in the implementation of the copy constructor, (line 63). Note that <TT>rhs[i]</TT>
is accessed, yet <TT>rhs</TT> is declared as a <TT>const String &amp;</TT>. It isn't
legal to access this object by using a nonconstant member function. Therefore, the
reference operator must be overloaded with a constant accessor.</P>
<P>If the object being returned were large, you might want to declare the return
value to be a constant reference. However, because a <TT>char</TT> is only one byte,
there would be no point in doing that.</P>
<P>The default constructor is implemented in lines 33-39. It creates a string whose
length is 0. It is the convention of this <TT>String</TT> class to report its length
not counting the terminating null. This default string contains only a terminating
null.</P>
<P>The copy constructor is implemented in lines 63-70. It sets the new string's length
to that of the existing string--plus 1 for the terminating null. It copies each character
from the existing string to the new string, and it null-terminates the new string.</P>
<P>Lines 53-60 implement the constructor that takes an existing C-style string. This
constructor is similar to the copy constructor. The length of the existing string
is established by a call to the standard <TT>String</TT> library function <TT>strlen()</TT>.</P>
<P>On line 28, another constructor, <TT>String(unsigned short)</TT>, is declared
to be a private member function. It is the intent of the designer of this class that
no client class ever create a <TT>String</TT> of arbitrary length. This constructor
exists only to help in the internal creation of <TT>String</TT>s as required, for
example, by <TT>operator+=</TT>, on line 130. This will be discussed in depth when
<TT>operator+=</TT> is described, below.</P>
<P>The <TT>String(unsigned short)</TT> constructor fills every member of its array
with <TT>NULL</TT>. Therefore, the <TT>for</TT> loop checks for <TT>i&lt;=len</TT>
rather than <TT>i&lt;len</TT>.</P>
<P>The destructor, implemented in lines 73-77, deletes the character string maintained
by the class. Be sure to include the brackets in the call to the delete operator,
so that every member of the array is deleted, instead of only the first.</P>
<P>The assignment operator first checks whether the right-hand side of the assignment
is the same as the left-hand side. If it isn't, the current string is deleted, and
the new string is created and copied into place. A reference is returned to facilitate
assignments lik</P>
<PRE><FONT COLOR="#0066FF">String1 = String2 = String3;</FONT></PRE>
<P>The offset operator is overloaded twice. Rudimentary bounds checking is performed
both times. If the user attempts to access a character at a location beyond the end
of the array, the last character--that is, <TT>len-1</TT>--is returned.</P>
<P>Lines 117-127 implement operator plus (+) as a concatenation operator. It is convenient
to be able to write</P>
<PRE><FONT COLOR="#0066FF">String3 = String1 + String2;</FONT></PRE>
<P>and have <TT>String3</TT> be the concatenation of the other two strings. To accomplish
this, the operator plus function computes the combined length of the two strings
and creates a temporary string <TT>temp</TT>. This invokes the private constructor,
which takes an integer, and creates a string filled with nulls. The nulls are then
replaced by the contents of the two strings. The left-hand side string (<TT>*this</TT>)
is copied first, followed by the right-hand side string (<TT>rhs</TT>).</P>
<P>The first <TT>for</TT> loop counts through the string on the left-hand side and
adds each character to the new string. The second <TT>for</TT> loop counts through
the right-hand side. Note that <TT>i</TT> continues to count the place for the new
string, even as <TT>j</TT> counts into the <TT>rhs</TT> string.</P>
<P>Operator plus returns the <TT>temp</TT> string by value, which is assigned to
the string on the left-hand side of the assignment (<TT>string1</TT>). Operator <TT>+=</TT>
operates on the existing string--that is, the left-hand side of the statement <TT>string1
+= string2</TT>. It works just like operator plus, except that the <TT>temp</TT>
value is assigned to the current string (<TT>*this = temp</TT>) in line 140.</P>
<P>The <TT>main()</TT>function (lines 143-173) acts as a test driver program for
this class. Line 145 creates a <TT>String</TT> object by using the constructor that
takes a null-terminated C-style string. Line 146 prints its contents by using the
accessor function <TT>GetString()</TT>. Line 148 creates another C-style string.
Line 149 tests the assignment operator, and line 150 prints the results.</P>
<P>Line 152 creates a third C-style string, <TT>tempTwo</TT>. Line 153 invokes <TT>strcpy</TT>
to fill the buffer with the characters <TT>; nice to be here!</TT> Line 154 invokes
operator <TT>+=</TT> and concatenates <TT>tempTwo</TT> onto the existing string <TT>s1.</TT>
Line 156 prints the results.</P>
<P>In line 158, the fifth character in <TT>s1</TT> is accessed and printed. It is
assigned a new value in line 159. This invokes the nonconstant offset operator (<TT>[
]</TT>). Line 160 prints the result, which shows that the actual value has, in fact,
been changed.</P>
<P>Line 162 attempts to access a character beyond the end of the array. The last
character of the array is returned, as designed.</P>
<P>Lines 164-165 create two more <TT>String</TT> objects, and line 166 calls the
addition operator. Line 167 prints the results.</P>
<P>Line 169 creates a new <TT>String</TT> object, <TT>s4</TT>. Line 170 invokes the
assignment operator. Line 171 prints the results. You might be thinking, &quot;The
assignment operator is defined to take a constant <TT>String</TT> reference in line
21, but here the program passes in a C-style string. Why is this legal?&quot;</P>
<P>The answer is that the compiler expects a <TT>String</TT>, but it is given a character
array. Therefore, it checks whether it can create a <TT>String</TT> from what it
is given. In line 12, you declared a constructor that creates <TT>String</TT>s from
character arrays. The compiler creates a temporary <TT>String</TT> from the character
array and passes it to the assignment operator. This is known as implicit casting,
or promotion. If you had not declared--and provided the implementation for--the constructor
that takes a character array, this assignment would have generated a compiler error.
<H3 ALIGN="CENTER"><A NAME="Heading47"></A><FONT COLOR="#000077">Linked Lists and
Other Structures</FONT></H3>
<P>Arrays are much like Tupperware. They are great containers, but they are of a
fixed size. If you pick a container that is too large, you waste space in your storage
area. If you pick one that is too small, its contents spill all over and you have
a big mess.</P>
<P>One way to solve this problem is with a linked list. A linked list is a data structure
that consists of small containers that are designed to fit and that are linked together
as needed. The idea is to write a class that holds one object of your data--such
as one <TT>CAT</TT> or one <TT>Rectangle</TT>--and that can point at the next container.
You create one container for each object that you need to store, and you chain them
together as needed.</P>
<P>The containers are called nodes. The first node in the list is called the head,
and the last node in the list is called the tail.</P>
<P>Lists come in three fundamental forms. From simplest to most complex, they are

<UL>
	<LI>Singly linked
	<P>
	<LI>Doubly linked
	<P>
	<LI>Trees
</UL>

<P>In a singly linked list, each node points forward to the next one, but not backward.
To find a particular node, start at the top and go from node to node, as in a treasure
hunt (&quot;The next node is under the sofa&quot;). A doubly linked list enables
you to move backward and forward in the chain. A tree is a complex structure built
from nodes, each of which can point in two or three directions. Figure 11.5 shows
these three fundamental structures.</P>
<P>Computer scientists have created even more complex and clever data structures,
nearly all of which rely on interconnecting nodes. Listing 11.13 shows how to create
and use a simple linked list.<BR>
<BR>
<A NAME="Heading48"></A><A HREF="../art/ch11/11zcp05.jpg"><FONT COLOR="#000077">Figure
11.5</FONT></A><FONT COLOR="#000077"> </FONT><I>Linked lists.</I></P>
<P><A NAME="Heading49"></A><FONT SIZE="4" COLOR="#000077"><B>Listing 11.13. Implementing
a linked list</B></FONT><FONT SIZE="2" COLOR="#000077"><B>.</B></FONT></P>
<PRE><FONT COLOR="#0066FF">1:       // Listing 11.13
2:       // Linked list simple implementation
3:
4:       #include &lt;iostream.h&gt;
5:
6:       // object to add to list
7:       class CAT
8:       {
9:       public:
10:         CAT() { itsAge = 1;}
11:         CAT(int age):itsAge(age){}
12:         ~CAT(){};
13:         int GetAge() const { return itsAge; }
14:      private:
15:         int itsAge;
16:      };
17:
18:      // manages list, orders by cat's age!
19:      class Node
20:      {
21:      public:
22:         Node (CAT*);
23:         ~Node();
24:         void SetNext(Node * node) { itsNext = node; }
25:         Node * GetNext() const { return itsNext; }
26:         CAT * GetCat() const { return itsCat; }
27:         void Insert(Node *);
28:         void Display();
29:      private:
30:         CAT *itsCat;
31:         Node * itsNext;
32:      };
33:
34:
35:      Node::Node(CAT* pCat):
36:      itsCat(pCat),
37:      itsNext(0)
38:      {}
39:
40:      Node::~Node()
41:      {
42:         cout &lt;&lt; &quot;Deleting node...\n&quot;;
43:         delete itsCat;
44:         itsCat = 0;
45:         delete itsNext;
46:         itsNext = 0;
47:      }
48:
49:      // ************************************
50:      // Insert
51:      // Orders cats based on their ages
52:      // Algorithim: If you are last in line, add the cat
53:      // Otherwise, if the new cat is older than you
54:      // and also younger than next in line, insert it after
55:      // this one. Otherwise call insert on the next in line
56:      // ************************************
57:      void Node::Insert(Node* newNode)
58:      {
59:         if (!itsNext)
60:            itsNext = newNode;
61:         else
62:         {
63:            int NextCatsAge = itsNext-&gt;GetCat()-&gt;GetAge();
64:            int NewAge =  newNode-&gt;GetCat()-&gt;GetAge();
65:            int ThisNodeAge = itsCat-&gt;GetAge();
66:
67:            if (  NewAge &gt;= ThisNodeAge &amp;&amp; NewAge &lt; NextCatsAge  )
68:            {
69:               newNode-&gt;SetNext(itsNext);
70:               itsNext = newNode;
71:            }
72:            else
73:               itsNext-&gt;Insert(newNode);
74:         }
75:      }
76:
77:      void Node::Display()
78:      {
79:         if (itsCat-&gt;GetAge() &gt; 0)
80:         {
81:            cout &lt;&lt; &quot;My cat is &quot;;
82:            cout &lt;&lt; itsCat-&gt;GetAge() &lt;&lt; &quot; years old\n&quot;;
83:         }
84:         if (itsNext)
85:            itsNext-&gt;Display();
86:      }
87:
88:      int main()
89:      {
90:
91:         Node *pNode = 0;
92:         CAT * pCat = new CAT(0);
93:         int age;
94:
95:         Node *pHead = new Node(pCat);
96:
97:         while (1)
98:         {
99:            cout &lt;&lt; &quot;New Cat's age? (0 to quit): &quot;;
100:            cin &gt;&gt;  age;
101:            if (!age)
102:               break;
103:           pCat = new CAT(age);
104:           pNode = new Node(pCat);
105:           pHead-&gt;Insert(pNode);
106:        }
107:        pHead-&gt;Display();
108:        delete pHead;
109:        cout &lt;&lt; &quot;Exiting...\n\n&quot;;
110:     return 0;
<TT>111: }</TT></FONT>
<FONT COLOR="#0066FF">
Output: New Cat's age? (0 to quit): 1
New Cat's age? (0 to quit): 9
New Cat's age? (0 to quit): 3
New Cat's age? (0 to quit): 7
New Cat's age? (0 to quit): 2
New Cat's age? (0 to quit): 5
New Cat's age? (0 to quit): 0
My cat is 1 years old
My cat is 2 years old
My cat is 3 years old
My cat is 5 years old
My cat is 7 years old
My cat is 9 years old
Deleting node...
Deleting node...
Deleting node...
Deleting node...
Deleting node...
Deleting node...
Deleting node...
Exiting...
</FONT></PRE>
<P><FONT COLOR="#000077"><B><BR>
Analysis:</B></FONT><B> </B>Lines 7-16 declare a simplified <TT>CAT</TT> class. It
has two constructors, a default constructor that initializes the member variable
<TT>itsAge</TT> to 1, and a constructor that takes an integer and initializes <TT>itsAge</TT>
to that value.<BR>
<BR>
Lines 19-32 declare the class <TT>Node</TT>. <TT>Node</TT> is designed specifically
to hold a <TT>CAT</TT> object in a list. Normally, you would hide <TT>Node</TT> inside
a <TT>CatList</TT> class. It is exposed here to illustrate how linked lists work.</P>
<P>It is possible to make a more generic <TT>Node</TT> that would hold any kind of
object in a list. You'll learn about doing that on Day 14, &quot;Special Classes
and Functions,&quot; when templates are discussed.</P>
<P><TT>Node</TT>'s constructor takes a pointer to a <TT>CAT</TT> object. The copy
constructor and assignment operator have been left out to save space. In a real-world
application, they would be included.</P>
<P>Three accessor functions are defined. <TT>SetNext()</TT> sets the member variable
<TT>itsNext</TT> to point to the <TT>Node</TT> object supplied as its parameter.
<TT>GetNext()</TT> and <TT>GetCat()</TT> return the appropriate member variables.
<TT>GetNext()</TT> and <TT>GetCat()</TT> are declared <TT>const</TT> because they
don't change the <TT>Node</TT> object.</P>
<P><TT>Insert()</TT> is the most powerful member function in the class. <TT>Insert()</TT>
maintains the linked list and adds <TT>Node</TT>s to the list based on the age of
the <TT>CAT</TT> that they point to.</P>
<P>The program begins at line 88. The pointer <TT>pNode</TT> is created and initialized
to <TT>0</TT>. A dummy <TT>CAT</TT> object is created, and its age is initialized
to <TT>0</TT>, to ensure that the pointer to the head of the list (<TT>pHead</TT>)
is always first.</P>
<P>Beginning on line 99, the user is prompted for an age. If the user presses 0,
this is taken as a signal that no more <TT>CAT</TT> objects are to be created. For
all other values, a <TT>CAT</TT> object is created on line 103, and the member variable
<TT>itsAge</TT> is set to the supplied value. The <TT>CAT</TT> objects are created
on the free store. For each <TT>CAT</TT> created, a <TT>Node</TT> object is created
on line 104.</P>
<P>After the <TT>CAT</TT> and <TT>Node</TT> objects are created, the first <TT>Node</TT>
in the list is told to insert the newly created node, on line 105.</P>
<P>Note that the program doesn't know--or care--how <TT>Node</TT> is inserted or
how the list is maintained. That is entirely up to the <TT>Node</TT> object itself.</P>
<P>The call to <TT>Insert()</TT> causes program execution to jump to line 57. <TT>Insert()</TT>
is always called on <TT>pHead</TT> first.</P>
<P>The test in line 59 fails the first time a new <TT>Node</TT> is added. Therefore,
<TT>pHead</TT> is pointed at the first new <TT>Node</TT>. In the output, this is
the node with a <TT>CAT</TT> whose <TT>itsAge</TT> value was set to <TT>1</TT>.</P>
<P>When the second <TT>CAT</TT> object's <TT>itsAge</TT> variable is set to <TT>9</TT>,
<TT>pHead</TT> is called again. This time, its member variable <TT>itsNext</TT> isn't
null, and the <TT>else</TT> statement in lines 61 to 74 is invoked.</P>
<P>Three local variables--<TT>NextCatsAge</TT>,<TT> NewAge</TT>, and<TT> ThisNodeAge</TT>--are
filled with the values of The current <TT>Node</TT>'s age--the age of <TT>pHead</TT>'s
<TT>CAT</TT> is 0</P>
<P>The age of the <TT>CAT</TT> held by the new <TT>Node</TT>--in this case, 9<BR>
<BR>
The age of the <TT>CAT</TT> object held by the next node in line--in this case, 1<BR>
<BR>
The test in line 67 could have been written as</P>
<PRE><FONT COLOR="#0066FF">if (  newNode-&gt;GetCat()-&gt;GetAge() &gt; itsCat-&gt;GetAge() &amp;&amp; \\
newNode-&gt;GetCat()-&gt;GetAge()&lt; itsNext-&gt;GetCat()-&gt;GetAge())</FONT></PRE>
<P>which would have eliminated the three temporary variables while creating code
that is more confusing and harder to read. Some C++ programmers see this as macho--until
they have a bug and can't figure out which one of the values is wrong.</P>
<P>If the new <TT>CAT</TT>'s age is greater than the current <TT>CAT</TT>'s age and
less than the next <TT>CAT</TT>'s age, the proper place to insert the new <TT>CAT</TT>'s
age is immediately after the current <TT>Node</TT>. In this case, the <TT>if</TT>
statement is true. The new <TT>Node</TT> is set to point to what the current <TT>Node</TT>
points to, and the current <TT>Node</TT> is set to point to the new <TT>Node</TT>.
Figure 11.6 illustrates this. <BR>
<BR>
<A NAME="Heading51"></A><A HREF="../art/ch11/11zcp06.jpg"><FONT COLOR="#000077">Figure
11.6.</FONT></A><FONT COLOR="#000077"> </FONT><I>Inserting a <TT>Node</TT>.</I> <BR>
<BR>
If the test fails, this isn't the proper place to insert the <TT>Node</TT>, and <TT>Insert()</TT>
is called on the next <TT>Node</TT> in the list. Note that the current call to <TT>Insert()</TT>
doesn't return until after the recursive call to <TT>Insert()</TT> returns. Therefore,
these calls pile up on the stack. If the list gets too long, it will blow the stack
and crash the program. There are other ways to do this that aren't so stack-intensive,
but they are beyond the scope of this book.</P>
<P>Once the user is finished adding <TT>CAT</TT> objects, display is called on the
first <TT>Node</TT>: <TT>pHead</TT>. The <TT>CAT</TT> object's age is displayed if
the current <TT>Node</TT> points to a <TT>CAT</TT> (<TT>pHead</TT> does not). Then,
if the current <TT>Node</TT> points to another <TT>Node</TT>, <TT>display()</TT>
is called on that <TT>Node</TT>.</P>
<P>Finally, <TT>delete</TT> is called on <TT>pHead</TT>. Because the destructor deletes
the pointer to the next <TT>Node</TT>, <TT>delete</TT> is called on that <TT>Node</TT>
as well. It walks the entire list, eliminating each <TT>Node</TT> and freeing the
memory of <TT>itsCat</TT>. Note that the last <TT>Node</TT> has its member variable
<TT>itsNext</TT> set to zero, and <TT>delete</TT> is called on that pointer as well.
It is always safe to call <TT>delete</TT> on zero, for it has no effect.
<H3 ALIGN="CENTER"><A NAME="Heading52"></A><FONT COLOR="#000077">Array Classes</FONT></H3>
<P>Writing your own <TT>Array</TT> class has many advantages over using the built-in
arrays. For starters, you can prevent array overruns. You might also consider making
your array class dynamically sized: At creation it might have only one member, growing
as needed during the course of the program.</P>
<P>You might want to sort or otherwise order the members of the array. There are
a number of powerful <TT>Array</TT> variants you might consider. Among the most popular
are:

<UL>
	<LI>Ordered collection: Each member is in sorted order.
	<P>
	<LI>Set: No member appears more than once.
	<P>
	<LI>Dictionary: This uses matched pairs in which one value acts as a key to retrieve
	the other value.
	<P>
	<LI>Sparse array: Indices are permitted for a large set, but only those values actually
	added to the array consume memory. Thus, you can ask for <TT>SparseArray[5]</TT>
	or <TT>SparseArray[200]</TT>, but it is possible that memory is allocated only for
	a small number of entries.
	<P>
	<LI>Bag: An unordered collection that is added to and retrieved in random order.
</UL>

<P>By overloading the index operator (<TT>[ ]</TT>), you can turn a linked list into
an ordered collection. By excluding duplicates, you can turn a collection into a
set. If each object in the list has a pair of matched values, you can use a linked
list to build a dictionary or a sparse array.
<H3 ALIGN="CENTER"><A NAME="Heading53"></A><FONT COLOR="#000077">Summary</FONT></H3>
<P>Today you learned how to create arrays in C++. An array is a fixed-size collection
of objects that are all of the same type.</P>
<P>Arrays don't do bounds checking. Therefore it is legal--even if disastrous--to
read or write past the end of an array. Arrays count from 0. A common mistake is
to write to offset n of an array of n members.</P>
<P>Arrays can be one dimensional or multidimensional. In either case, the members
of the array can be initialized, as long as the array contains either built-in types,
such as <TT>int</TT>, or objects of a class that has a default constructor.</P>
<P>Arrays and their contents can be on the free store or on the stack. If you delete
an array on the free store, remember to use the brackets in the call to <TT>delete</TT>.</P>
<P>Array names are constant pointers to the first elements of the array. Pointers
and arrays use pointer arithmetic to find the next element of an array.</P>
<P>You can create linked lists to manage collections whose size you won't know at
compile time. From linked lists, you can create any number of more complex data structures.</P>
<P>Strings are arrays of characters, or <TT>char</TT>s. C++ provides special features
for managing <TT>char</TT> arrays, including the ability to initialize them with
quoted strings.
<H3 ALIGN="CENTER"><A NAME="Heading54"></A><FONT COLOR="#000077">Q&amp;A</FONT></H3>

<DL>
	<DD><B>Q. What happens if I write to element 25 in a 24-member array?<BR>
	</B><BR>
	<B>A.</B> You will write to other memory, with potentially disastrous effects on
	your program.<BR>
	<BR>
	<B>Q. What is in an uninitialized array element?<BR>
	</B><BR>
	<B>A.</B> Whatever happens to be in memory at a given time. The results of using
	this member without assigning a value are unpredictable.<BR>
	<BR>
	<B>Q. Can I combine arrays?<BR>
	</B><BR>
	<B>A.</B> Yes. With simple arrays you can use pointers to combine them into a new,
	larger array. With strings you can use some of the built-in functions, such as <TT>strcat</TT>,
	to combine strings.<BR>
	<BR>
	<B>Q. Why should I create a linked list if an array will work?<BR>
	</B><BR>
	<B>A.</B> An array must have a fixed size, whereas a linked list can be sized dynamically
	at runtime.<BR>
	<B><BR>
	Q. Why would I ever use built-in arrays if I can make a better array class?<BR>
	</B><BR>
	<B>A.</B> Built-in arrays are quick and easy to use.<BR>
	<BR>
	<B>Q. Must a string class use a char * to hold the contents of the string?<BR>
	</B><BR>
	<B>A.</B> No. It can use any memory storage the designer thinks is best.
</DL>

<H3 ALIGN="CENTER"><A NAME="Heading55"></A><FONT COLOR="#000077">Workshop</FONT></H3>
<P>The Workshop provides quiz questions to help you solidify your understanding of
the material covered and exercises to provide you with experience in using what you've
learned. Try to answer the quiz and exercise questions before checking the answers
in Appendix D, and make sure you understand the answers before continuing to the
next chapter.
<H4 ALIGN="CENTER"><A NAME="Heading56"></A><FONT COLOR="#000077">Quiz</FONT></H4>

<DL>
	<DD><B>1.</B> What are the first and last elements in <TT>SomeArray[25]</TT>?<BR>
	<BR>
	<B>2</B>. How do you declare a multidimensional array?<BR>
	<BR>
	<B>3</B>. Initialize the members of the array in Question 2.<BR>
	<BR>
	<B>4</B>. How many elements are in the array <TT>SomeArray[10][5][20]</TT>?<BR>
	<BR>
	<B>5.</B> What is the maximum number of elements that you can add to a linked list?<BR>
	<BR>
	<B>6.</B> Can you use subscript notation on a linked list?<BR>
	<BR>
	<B>7.</B> What is the last character in the string &quot;Brad is a nice guy&quot;?
</DL>

<H4 ALIGN="CENTER"><A NAME="Heading57"></A><FONT COLOR="#000077">Exercises</FONT></H4>

<DL>
	<DD><B>1.</B> Declare a two-dimensional array that represents a tic-tac-toe game
	board.<BR>
	<BR>
	<B>2.</B> Write the code that initializes all the elements in the array you created
	in Exercise 1 to the value <TT>0</TT>.<BR>
	<BR>
	<B>3.</B> Write the declaration for a <TT>Node</TT> class that holds <TT>unsigned</TT>
	<TT>short</TT> integers.<BR>
	<B><BR>
	4.</B> BUG BUSTERS: What is wrong with this code fragment?
</DL>

<PRE><FONT COLOR="#0066FF">unsigned short SomeArray[5][4];
for (int i = 0; i&lt;4; i++)
     for (int j = 0; j&lt;5; j++)
          SomeArray[i][j] = i+j;
</FONT></PRE>

<DL>
	<DD><B>5.</B> BUG BUSTERS: What is wrong with this code fragment?
</DL>

<PRE><FONT COLOR="#0066FF">        unsigned short SomeArray[5][4];
for (int i = 0; i&lt;=5; i++)
     for (int j = 0; j&lt;=4; j++)
          SomeArray[i][j] = 0;</FONT></PRE>
<P>
<P ALIGN="CENTER"><A HREF="ch10.htm"><IMG SRC="../buttons/BLANPREV.GIF"
WIDTH="37" HEIGHT="37" ALIGN="BOTTOM" BORDER="0"></A><A HREF="http://www.mcp.com/sams"><IMG
SRC="../buttons/BLANHOME.GIF" WIDTH="37" HEIGHT="37" ALIGN="BOTTOM"
BORDER="0"></A><A HREF="../index.htm"><IMG SRC="../buttons/BLANTOC.GIF"
WIDTH="37" HEIGHT="37" ALIGN="BOTTOM" BORDER="0"></A><A HREF="ch12.htm"><IMG SRC="../buttons/BLANNEXT.GIF"
WIDTH="37" HEIGHT="37" ALIGN="BOTTOM" BORDER="0"></A><A HREF="#heading1"><IMG SRC="../buttons/BLANTOP.GIF"
WIDTH="37" HEIGHT="37" ALIGN="BOTTOM" BORDER="0"></A>


</BODY>

</HTML>